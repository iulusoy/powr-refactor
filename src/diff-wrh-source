diff -bur ./adapop.f ../../powr-refactor/src/adapop.f
--- ./adapop.f	2024-07-28 13:14:47.000000000 +0200
+++ ../../powr-refactor/src/adapop.f	2023-09-27 10:14:15.093755292 +0200
@@ -1,7 +1,8 @@
       SUBROUTINE ADAPOP (POPNUM, ND, N, POPOLD, NDOLD, NOLD, NCHARG,
      >          NATOM, ABXYZ, NFIRST, NLAST, RNE, NTRANS, POPLTE, 
      >          BDEPART, ADPWEIGHT, RADIUS, ROLD, POPHELP, TAURCONT, 
-     >          TAURCONTOLD, POPLTE_OLD, BTAUR, POPMIN) 
+     >          TAURCONTOLD, POPLTE_OLD, ENTOT, ENTOTOLD, 
+     >          BTAUR, bUseENTOT, POPMIN) 
 C***********************************************************************
 C***  TRANSFORMATION OF POPULATION NUMBERS FROM OLD TO NEW MODEL ATOM
 C***  Radically simplified version: wrh 10-Aug-2007
@@ -11,14 +12,30 @@
 C***    IF NTRANS(J) >  0 : assign POPOLD with index NTRANS
 C***********************************************************************
  
-      DIMENSION NCHARG(N), NTRANS(N), ADPWEIGHT(N)
-      DIMENSION ABXYZ(NATOM),NFIRST(NATOM),NLAST(NATOM)
-      DIMENSION RNE(ND), RADIUS(ND), TAURCONT(ND)
-      DIMENSION POPNUM(ND,N), POPLTE(ND,N)
-      DIMENSION POPOLD(ND,NOLD)
-      DIMENSION ROLD(NDOLD), TAURCONTOLD(NDOLD)
-      DIMENSION POPHELP(NDOLD,NOLD), POPLTE_OLD(NDOLD, NOLD)
-      LOGICAL BDEPART, BTAUR
+      IMPLICIT NONE
+      INCLUDE 'interfacebib.inc'
+ 
+      INTEGER, INTENT(IN) :: N, NOLD, ND, NDOLD, NATOM
+      REAL, INTENT(IN) :: POPMIN
+
+      INTEGER, DIMENSION(N) :: NCHARG, NTRANS
+      REAL, DIMENSION(N) :: ADPWEIGHT(N)      
+
+      INTEGER, DIMENSION(NATOM) :: NFIRST, NLAST
+      REAL, DIMENSION(NATOM) :: ABXYZ
+      
+      REAL, DIMENSION(ND) :: RNE, RADIUS, TAURCONT, ENTOT
+      REAL, DIMENSION(NDOLD) :: ROLD, TAURCONTOLD, ENTOTOLD, 
+     >                          ENTOTOLDLOG, POPHELPJLOG
+
+      REAL, DIMENSION(ND, N) :: POPNUM, POPLTE
+      REAL, DIMENSION(ND, NOLD) :: POPOLD
+      REAL, DIMENSION(NDOLD,NOLD) :: POPHELP, POPLTE_OLD
+
+      INTEGER :: L, J, NFIRNA, NLANA, NA
+      REAL :: SUM, POPJLOGL, ENTOTLOGL
+      
+      LOGICAL :: BDEPART, BTAUR, bUseENTOT
 
 C***  The old popnumbers in POPHELP are interpolated with respect
 C***  to the depth coordinate and stored in POPOLD (which then has
@@ -55,6 +72,31 @@
            ENDDO
          ENDDO
       
+      ELSEIF (bUseENTOT) THEN
+        WRITE (0,*) 'Interpolation of Popnumbers over LOG density'
+        DO J=1, NOLD
+          !prepare necessary vectors
+          DO L=1, NDOLD
+            ENTOTOLDLOG(L) = LOG10(ENTOTOLD(L))
+            POPHELPJLOG(L) = LOG10(MAX(POPHELP(L,J), POPMIN))
+          ENDDO          
+          !Perform interpolation on log(n_tot)
+          dploop: DO L=1, ND
+            ENTOTLOGL = LOG10(ENTOT(L))
+            IF (ENTOTLOGL > ENTOTOLDLOG(NDOLD)) THEN
+              !more dense than old innermost value => take old inner boundary value
+              POPJLOGL = POPHELPJLOG(NDOLD)
+            ELSEIF (ENTOTLOGL < ENTOTOLDLOG(1)) THEN
+              !less dense than old outermost value => take old outer boundary value
+              POPJLOGL = POPHELPJLOG(1)
+            ELSE
+              CALL SPLINPOX(POPJLOGL, ENTOTLOGL,
+     >                     POPHELPJLOG, ENTOTOLDLOG, NDOLD)
+            ENDIF
+            POPOLD(L,J) = 10**(POPJLOGL)
+          ENDDO dploop
+        ENDDO              
+      
       ELSE
 
 C***  INTERPOLATION OF OLD POPNUMBERS TO THE NEW RADIUS GRID
@@ -107,9 +149,14 @@
                SUM = SUM + POPNUM(L,J)
             ENDDO
             SUM = SUM / ABXYZ(NA)
-            IF (SUM .NE. 0.) THEN
+            IF (SUM /= 0.) THEN
                DO J=NFIRNA,NLANA
+                  !POPMIN ensurance test (ansander, 2014)
+                  IF (POPNUM(L,J) > POPMIN) THEN
                   POPNUM(L,J) = POPNUM(L,J) / SUM
+                  ELSE
+                    POPNUM(L,J) = POPMIN
+                  ENDIF                   
                ENDDO
             ENDIF
          ENDDO
Only in ../../powr-refactor/src/: adapter.exe
Only in ../../powr-refactor/src/: adapter.exe.opt
diff -bur ./adapter.f ../../powr-refactor/src/adapter.f
--- ./adapter.f	2024-07-28 13:14:47.000000000 +0200
+++ ../../powr-refactor/src/adapter.f	2023-09-27 10:14:15.093755292 +0200
@@ -14,14 +14,18 @@
       INTEGER, PARAMETER :: NDIM    =        2560 
       INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400
       INTEGER, PARAMETER :: MAXKONT =     NFDIM/2 
-      INTEGER, PARAMETER :: MAXIND  =       45000 
-      INTEGER, PARAMETER :: MAXFEIND  =      1500 
+      INTEGER, PARAMETER :: MAXKODR =        NDIM 
+      INTEGER, PARAMETER :: MAXIND  =       40000 
+      INTEGER, PARAMETER :: MAXFEIND  =      2500 
       INTEGER, PARAMETER :: NDDIM   =          89 
       INTEGER, PARAMETER :: MAXHIST =        4000 
       INTEGER, PARAMETER :: MAXLEVELCARD =   1000       
  
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR (SEE ALSO SUBR. GAUNTFF)
+      INTEGER, PARAMETER :: MAXION = 27 
+      
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      INTEGER, PARAMETER :: MAXAUTO = 2850 
+      INTEGER, PARAMETER :: MAXAUTO = 3200 
       COMMON / COMAUTO / LOWAUTO(MAXAUTO),WAUTO(MAXAUTO)
      $                  ,EAUTO(MAXAUTO),AAUTO(MAXAUTO),IONAUTO(MAXAUTO)
      $                  ,KRUDAUT(MAXAUTO)
@@ -40,7 +44,7 @@
       REAL, DIMENSION(MAXATOM) :: ABXYZ, ATMASS, STAGE
       REAL, DIMENSION(NDDIM) :: RNE, RADIUS, ROLD
       REAL, DIMENSION(NDDIM,NDIM) :: POPNUM, POPOLD, POPHELP
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: EDGEK, SIGMATHK, SEXPOK
+      REAL, DIMENSION(MAXATOM,MAXION) :: EDGEK, SIGMATHK, SEXPOK
 
       CHARACTER(MAXHIST*8) :: MODHIST
 
@@ -50,11 +54,11 @@
       CHARACTER(10), DIMENSION(MAXATOM) :: ELEMENT
       CHARACTER(4) :: KEYCBB(MAXIND)
       CHARACTER(2), DIMENSION(MAXATOM) :: SYMBOL
-      LOGICAL :: OLDSTART, NEWATOM, BDEPART, BTAUR
+      LOGICAL :: OLDSTART, NEWATOM, BDEPART, BTAUR, bUseENTOT
       CHARACTER(80), DIMENSION(MAXLEVELCARD) :: LEVELCARD
       CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
 
-      REAL, DIMENSION(NDDIM) :: TAURCONT, TAURCONTOLD
+      REAL, DIMENSION(NDDIM) :: TAURCONT, TAURCONTOLD, ENTOT, ENTOTOLD
       REAL, DIMENSION(NDDIM,NDIM) :: POPLTE, POPLTE_OLD
 
       REAL :: WAUTO, EAUTO, AAUTO, VDOPFE, DXFE, XLAM0FE, POPMIN
@@ -67,9 +71,9 @@
 
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
 C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl / hydro
 
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
      >                                IFENUP, IFELOW
@@ -109,7 +113,7 @@
       IF (OPSYS == 'CRAY') THEN
         CALL CLOCK(TIM1)
       ELSE
-ccc      CALL TIME(TIM1) ! not available in gfortran, not needed either
+        CALL TIME(TIM1)
       ENDIF
 
 C***  NEW ENERGY LEVELS FROM NEW MODEL ATOM: 
@@ -128,10 +132,10 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
 C***  DECODING INPUT OPTIONS
-      CALL DECADP (OLDSTART, BDEPART, BTAUR, POPMIN, 
+      CALL DECADP (OLDSTART, BDEPART, BTAUR, bUseENTOT, POPMIN, 
      >                LEVELCARD, NLEVELCARD, MAXLEVELCARD)
 
 C***  NO OPTION "OLDSTART" DECODED: ADAPTER IS NOT NECESSARY
@@ -140,8 +144,8 @@
 C***  READ OLD AND NEW MODEL FILES
       CALL RMODADP (NDDIM, OLDHEAD, N, NOLD, NDIM, 
      >              NATOM, MODHEAD, ND, NDOLD, ABXYZ, LAST, MODHIST,
-     >              RADIUS, ROLD, POPHELP, POPNUM, TAURCONT, 
-     >              TAURCONTOLD, POPLTE, POPLTE_OLD, BTAUR)
+     >           RADIUS, ROLD, POPHELP, POPNUM, TAURCONT, TAURCONTOLD, 
+     >           POPLTE, POPLTE_OLD, ENTOT, ENTOTOLD, BTAUR)
 
 C***  Decoding the LEVEL cards
       CALL ADATRANS (NTRANS, ADPWEIGHT, N, NOLD, NEWATOM, POPMIN,
@@ -151,7 +155,8 @@
       CALL ADAPOP (POPNUM, ND, N, POPOLD, NDOLD, NOLD, NCHARG,
      >          NATOM, ABXYZ, NFIRST, NLAST, RNE, NTRANS, POPLTE, 
      >          BDEPART, ADPWEIGHT, RADIUS, ROLD, POPHELP, TAURCONT,
-     >          TAURCONTOLD, POPLTE_OLD, BTAUR, POPMIN)
+     >          TAURCONTOLD, POPLTE_OLD, ENTOT, ENTOTOLD,
+     >          BTAUR, bUseENTOT, POPMIN)
 
 C***  UPDATING THE MODEL HISTORY  **************************************
       WRITE (UNIT=BUFFER64, FMT=60) OLDHEAD(15:32)
diff -bur ./adatrans.f ../../powr-refactor/src/adatrans.f
--- ./adatrans.f	2024-07-28 13:14:48.000000000 +0200
+++ ../../powr-refactor/src/adatrans.f	2023-09-27 10:14:15.093755292 +0200
@@ -18,7 +18,7 @@
       DIMENSION NTRANS(N), ADPWEIGHT(N)
       LOGICAL NEWATOM, CHRINSTR
       CHARACTER KARTE*80, REST*80, ACTPAR1*20, ACTPAR2*20
-      CHARACTER(80), DIMENSION(MAXLEVELCARD) :: LEVELCARD
+      CHARACTER LEVELCARD*80(MAXLEVELCARD)
 
 C***  DEFAULT VALUES: 
       NEWATOM=.FALSE.
diff -bur ./addopa.f ../../powr-refactor/src/addopa.f
--- ./addopa.f	2024-07-28 13:14:48.000000000 +0200
+++ ../../powr-refactor/src/addopa.f	2023-11-21 10:10:55.277269761 +0100
@@ -1,33 +1,64 @@
       SUBROUTINE ADDOPA (ND, NDDIM, MAXLIN, MAXIND, LIND, LINDS, 
-     >             XK, XKMID, XKRED, DELTAX, 
-     >             PARALAS, LASER, 
+     >             XK, XKMID, XKRED, DELTAX, FWEIGHTL,
+     >             PARALAS, LASER, LASERV, ALN, VDOPUNIT, VDOPDD,
      >             WS, ETAL, OPAL, ETA, ETANOTH, OPA, ETAK, ETAKNOTH, 
-     >             OPAK, OPAKNOTH, THOMSON, 
-     >             PWEIGHT, OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW, 
-     >             N, LEVEL)
+     >             OPAK, OPAKNOTH, THOMSON, PWEIGHT, NOM,
+     >             OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW, N, LEVEL, 
+     >             OPAKFE, NATOM, MAXATOM, KODAT, OPACELEM, OPAKELEM,
+     >             ETACELEM, ETAKELEM, MAXION, OPACION, OPAKION, 
+     >             ETACION, ETAKION, NCHARG, OPAFEION, ETAFEION, 
+     >             OPAKNOFENOTH, ETAKNOFENOTH,
+     >             OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT)
 C**********************************************************************
 C***  TREATMENT OF LINE BLENDS:
 C***  ADD OVERLAPPING OPACITIES AND EMISSIVITIES
 C***  - ALSO GENERATES THE LASER WARNING (ONLY LASER-VERSION 1)
 C***  - CALLED FROM: COLI, SETXJFINE ( <- with ND=1 )
+C
+C
+C     The different OPA variables have the following meaning
+C     (all of them are depth-dependent and only for the current fine freq.)
+C       OPA       - sum of bf and ff opacity plus Thomson
+C       OPAL      - bb opacity per line transition
+C       OPAFE     - Fe bb opacity
+C     By the end of the routine these values are filled as follows:
+C       OPAK      - total opacity (bf, bb, ff, and Thomson)
+C       OPAKNOTH  - total opacity w/o Thomson (bf, bb, ff)
+C       THOMSON   - fraction of Thomson opacity relative to OPAK
+C
 C**********************************************************************
 
+      INTEGER, INTENT(IN) :: ND, NDDIM, MAXLIN, MAXIND, NATOM, MAXATOM
+      REAL, INTENT(IN) :: ALN, VDOPUNIT, FWEIGHTL
+
       DIMENSION LIND(MAXLIN),LINDS(MAXLIN),XKMID(MAXIND),XKRED(MAXIND)
       DIMENSION NUP(MAXLIN), LOW(MAXLIN)
       DIMENSION OPAL(NDDIM,MAXLIN), ETAL(NDDIM,MAXLIN)
-      DIMENSION ETA(ND), ETANOTH(ND), OPA(ND), WS(ND)
-      DIMENSION ETAK(NDDIM), ETAKNOTH(NDDIM)
-      DIMENSION OPAK(NDDIM), PWEIGHT(MAXLIN)
-      DIMENSION OPAKNOTH(NDDIM), THOMSON(NDDIM)
-      DIMENSION OPAFE(ND), ETAFE(ND)
+      DIMENSION ETA(ND), ETANOTH(ND), OPA(ND)
+      REAL, DIMENSION(NDDIM,MAXLIN) :: PWEIGHT, WS
+      REAL, DIMENSION(NDDIM) :: OPAK, ETAK, OPAKNOTH, ETAKNOTH, THOMSON
+      INTEGER, DIMENSION(MAXATOM) :: KODAT
+      REAL, DIMENSION(ND) :: OPAFE, ETAFE, OPAKFE, 
+     >                       OPAKNOFENOTH, ETAKNOFENOTH,
+     >                       OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT
+      REAL, DIMENSION(NATOM, ND) :: OPAKELEM, OPACELEM,
+     >                              ETACELEM, ETAKELEM
+      REAL, DIMENSION(ND, NATOM, MAXION) :: OPAKION, OPACION,
+     >                                      ETACION, ETAKION
+      REAL, DIMENSION(ND, MAXION) :: OPAFEION, ETAFEION
+      REAL, DIMENSION(ND, NATOM), INTENT(IN) :: VDOPDD
+      INTEGER, DIMENSION(N) :: NOM, NCHARG
 
       CHARACTER(10), DIMENSION(N) :: LEVEL
       LOGICAL LASER, BFECHECK, BLASERL(MAXIND)
+      INTEGER :: L, NL, NA, NAFE
+
+      REAL, PARAMETER :: WPI      = 1.772454    !WPI = SQRT(PI)
+      REAL, PARAMETER :: CLIGHTKM = 2.9979E5    !CLIGHT = SPEED OF LIGHT IN KILOMETER/SECOND
 
-C***  WPI = SQRT(PI)
-      DATA WPI /1.772454/
 
       LASER = .FALSE.
+      NAFE = KODAT(26)      !Atomic number of iron
 
 C***  REAL LINE OPACITIES FROM ALL INVENTED LINES
       DO L=1,ND
@@ -35,41 +66,76 @@
         ETAKNOTH(L) = 0.0
         OPAK(L)     = 0.0
         OPAKNOTH(L) = 0.0
+        OPAKFE(L)   = 0.0
+        OPAKNOFENOTH(L) = 0.0
+        ETAKNOFENOTH(L) = 0.0
+        DO NA=1, NATOM
+          OPAKELEM(NA,L) = 0.0
+          ETAKELEM(NA,L) = 0.0
+          DO ION=1, MAXION
+            OPAKION(L,NA,ION) = 0.0
+            ETAKION(L,NA,ION) = 0.0
+          ENDDO
+        ENDDO
+        OPAKFEFT(L)   = 0.0
+        ETAKFEFT(L)   = 0.0
       ENDDO
 
       DO NL=1, MAXLIN
         IF (LIND(NL) .EQ. 0) CYCLE
         IF (XK .GT. XKRED(LINDS(NL))) CYCLE
-        DK = (XK - XKMID(LINDS(NL))) * DELTAX
-        PWEIGHT(NL) = EXP(-DK*DK)
-        WS(NL) = WS(NL) + PWEIGHT(NL)
-        PHI = PWEIGHT(NL) / WPI
+        
+        NA = NOM(LOW(NL))
+        ION = NCHARG(LOW(NL)) + 1
 
         DO L=1, ND
+           DK = (XK - XKMID(LINDS(NL))) * DELTAX
+     >                    * VDOPUNIT/VDOPDD(L,NA)           
+           
+           PWEIGHT(L,NL) = VDOPUNIT/VDOPDD(L,NA) * EXP(-DK*DK)
+           WS(L,NL) = WS(L,NL) + PWEIGHT(L,NL) * FWEIGHTL
+           PHI = PWEIGHT(L,NL) / WPI
+
            ETAK(L) = ETAK(L) + ETAL(L,NL)*PHI
            OPAK(L) = OPAK(L) + OPAL(L,NL)*PHI
-           OPAG = (PARALAS-1.0) * OPA(L)
+
+           OPAKELEM(NA,L) = OPAKELEM(NA,L) + OPAL(L,NL)*PHI
+           ETAKELEM(NA,L) = ETAKELEM(NA,L) + ETAL(L,NL)*PHI
+           OPAKION(L,NA,ION) = OPAKION(L,NA,ION) + OPAL(L,NL)*PHI
+           ETAKION(L,NA,ION) = ETAKION(L,NA,ION) + ETAL(L,NL)*PHI
+           OPAG = (PARALAS-1.0) * MAX(OPA(L), 0.)        !Goetz version
            BLASERL(LIND(NL)) = 
      >          BLASERL(LIND(NL)) .OR.  OPAL(L,NL) .LT. OPAG
         ENDDO
       ENDDO
 
 
-C***  IRON: ADD IRON OPACITY AND EMISSIVITY IF NECESSARY
+C***  IRON: ADD IRON LINE OPACITY AND EMISSIVITY IF NECESSARY
       IF (BFECHECK) THEN
          DO L=1, ND
             ETAK(L) = ETAK(L) + ETAFE(L)
             OPAK(L) = OPAK(L) + OPAFE(L)
+            OPAKFE(L) = OPAKFE(L) + OPAFE(L)
+            NA = KODAT(26)
+            OPAKELEM(NA,L) = OPAKELEM(NA,L) + OPAFE(L)
+            ETAKELEM(NA,L) = ETAKELEM(NA,L) + ETAFE(L)
+            DO ION=1, MAXION
+              OPAKION(L,NA,ION) = OPAKION(L,NA,ION) + OPAFEION(L,ION)
+              ETAKION(L,NA,ION) = ETAKION(L,NA,ION) + ETAFEION(L,ION)
+            ENDDO
          ENDDO
       ENDIF
 
 C***  Laser treatment (all versions): 
 C***       restrict Total Opacity to > PARALAS * CONTINUUM
+      IF (LASERV > -1) THEN
         DO L=1, ND
-          OPAG = (PARALAS-1.0) * OPA(L)
+c          OPAG = (PARALAS-1.0) * OPA(L)
+          OPAG = (PARALAS-1.0) * MAX(OPA(L), 0.)
           LASER = LASER .OR. (OPAK(L).LT.OPAG)
           OPAK(L)=AMAX1(OPAG,OPAK(L))
         ENDDO
+      ENDIF
 
 C***  Add the Continuum Values to ETAK, ETAKNOTH and OPAK
       DO L=1, ND
@@ -78,6 +144,28 @@
         OPAG        = PARALAS * OPA(L)
         OPAKNOTH(L) = OPA(L) * (1.-THOMSON(L)) + OPAK(L)
         OPAK(L)     = OPA(L) + OPAK(L)
+C***    Perform element- and ionspecific calulations 
+C***     to enable radiative driving analysis (ACCELEM) plots 
+        DO NA=1, NATOM
+          IF (NA /= NAFE) THEN
+            OPAKNOFENOTH(L) = OPAKNOFENOTH(L) 
+     >                         + OPACELEM(NA,L)             
+     >                         + OPAKELEM(NA,L)
+            ETAKNOFENOTH(L) = ETAKNOFENOTH(L)
+     >                         + ETACELEM(NA,L) + ETAKELEM(NA,L)
+          ELSE
+            OPAKFE(L)   = OPAKFE(L) + OPACELEM(NAFE,L) 
+            OPAKFEFT(L) = OPAFEFT(L) + OPACELEM(NAFE,L)
+            ETAKFEFT(L) = ETAFEFT(L) + ETACELEM(NAFE,L) 
+          ENDIF
+          OPAKELEM(NA,L) =  OPACELEM(NA,L) + OPAKELEM(NA,L)
+          ETAKELEM(NA,L) =  ETACELEM(NA,L) + ETAKELEM(NA,L)
+          DO ION=1, MAXION
+            OPAKION(L,NA,ION) = OPACION(L,NA,ION) + OPAKION(L,NA,ION)
+            ETAKION(L,NA,ION) = ETACION(L,NA,ION) + ETAKION(L,NA,ION)
+          ENDDO
+        ENDDO
+
       ENDDO      
       
 
diff -bur ./adjgamma.f ../../powr-refactor/src/adjgamma.f
--- ./adjgamma.f	2024-07-28 13:14:49.000000000 +0200
+++ ../../powr-refactor/src/adjgamma.f	2023-09-27 10:14:15.097755357 +0200
@@ -1,6 +1,7 @@
-      SUBROUTINE ADJGAMMA(GAHIST, MAXGAHIST, AG, LASTHYDRO, BTALTER,
-     >                    GAMMAC, GAMMAL, GAMMAR, GAMMAD, BGFIN, GF, 
-     >                BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX)
+      SUBROUTINE ADJGAMMA(GAHIST, MAXGAHIST, AG, LASTHYDRO, LASTTAU,
+     >                    BTALTER, GAMMAC, GAMMAL, GAMMAR, GAMMAD, 
+     >                    BGFIN, GF, BGAMMACFIX, BGAMMALFIX, 
+     >                    BGAMMARFIX, BGAMMADFIX, bHDNoAG)
 C*************************************************************
 C***  Automatic Gamma Adjustment
 C***    GAMMA HISTORY has been already shifted!
@@ -9,6 +10,8 @@
       DIMENSION GAHIST(26,MAXGAHIST), AG(7)
       LOGICAL :: BKONVER1, BKONVER2, BGFIN, BTALTER, bPrintZeroInfo
       LOGICAL :: BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX
+      LOGICAL :: bHDNoAG   ! if true, last HD corrections are so large that GAMMAs should be reset to inf (0)
+      INTEGER :: LASTHYDRO, LASTTAU
 
       bPrintZeroInfo = .FALSE.
 
@@ -137,17 +140,27 @@
         GAMMAD = GF
       ENDIF
 
+C***  Prevent very large GAMMA values as they could crash the code
+C***  (and ruin the MODHIST output)
+      IF (GAMMAC > 9999.) THEN
+        GAMMAC = 0.
+        GAMMAL = 0.
+        GAMMAR = 0.
+        GAMMAD = 0.
+      ENDIF      
 
       IF (BGAMMACFIX) GAMMAC = GAMMACFIX 
       IF (BGAMMALFIX) GAMMAL = GAMMALFIX
       IF (BGAMMARFIX) GAMMAR = GAMMARFIX
       IF (BGAMMADFIX) GAMMAD = GAMMADFIX
 
-C***  Reset GAMMAs if temperature corrections were just switched on 
-      IF ((LASTHYDRO == 1) .OR. 
-     >    ((.NOT. BTALTER) .AND. 
+C***  If this is the first iteration with temperature equation/correction, 
+C***  start with GAMMA=0
+      IF ((LASTHYDRO == 1) .OR. (bHDNoAG .AND. LASTHYDRO == 2) .OR.
+     >    ((.NOT. BTALTER .AND. LASTHYDRO /= 2) .AND. 
      >            (GAHIST(26,1) > .0 .AND. GAHIST(26,2) == .0)) .OR. 
-     >    (BTALTER .AND.            !go two STEAL jobs back if TCORR ALTERNATE is used
+C***  Go back two STEAL jobs if TCORR ALTERNATE or HD update happened two jobs ago
+     >    ((BTALTER .OR. LASTHYDRO == 2) .AND.           
      >            (GAHIST(26,1) > .0 .AND. GAHIST(26,3) == .0)) ) THEN
 
 C***      reset to the upper-limit Gamma (first AUTO GAMMA parameter) 
@@ -171,12 +184,15 @@
      >   'New:', GAMMAC, GAMMAL, GAMMAR, GAMMAD
       ENDIF
       IF (bPrintZeroInfo) THEN
-        IF (LASTHYDRO == 1) THEN
+        IF (bHDNoAG) THEN
+          WRITE (0,'(A)') 
+     >      "STEAL: GAMMA reset due to large HD stratification updates"
+        ELSEIF (LASTHYDRO == 1) THEN
           WRITE (0,'(A)') 
-     >       "STEAL: AFTER HYDRO -> All GAMMAs = 0"
+     >      "STEAL: First STEAL after HD update -> all GAMMAs = 0"
         ELSE
           WRITE (0,'(A)') 
-     >       'GAMMAs reset because TEMPERATURE updated first time' 
+     >      'STEAL: GAMMA reset due to onset of temperature corrections' 
         ENDIF
       ENDIF
 
diff -bur ./append_autolevels.f ../../powr-refactor/src/append_autolevels.f
--- ./append_autolevels.f	2024-07-28 13:14:50.000000000 +0200
+++ ../../powr-refactor/src/append_autolevels.f	2023-11-21 10:10:55.277269761 +0100
@@ -38,11 +38,9 @@
 
 C***  Number of levels is increased
       N_WITH_DRLEVELS = N + NLEVEL_AUTO
-C*    ERROR STOP:
       IF (N_WITH_DRLEVELS .GT. NDIM) THEN
-         WRITE (0,'(A, I5,A,I5)') 
+         WRITE (*,'(A, I5,A,I5)') 
      >    '*** NDIM=', NDIM, ' insufficient: needed', N_WITH_DRLEVELS
-         STOP '*** FATAL ERROR detected by subr. APPEND_AUTOLEVELS'
       ENDIF
 
 C***  The new AUTO-Levels are appended to LEVEL list
diff -bur ./brnorm2.f ../../powr-refactor/src/brnorm2.f
--- ./brnorm2.f	2024-07-28 13:12:55.000000000 +0200
+++ ../../powr-refactor/src/brnorm2.f	2024-07-22 09:27:16.096033924 +0200
@@ -3,10 +3,10 @@
 C***  FN := SQR (NORM(F))
 C*****************************************************************
       DIMENSION F(NDIM)
-      FN=0.
+      FN=0.D0
       DO I=1,NDIM
-        IF (ABS(F(I)) .GT. 1.E100) THEN
-          FN = 1.E300
+        IF (ABS(F(I)) .GT. 1.D100) THEN
+          FN = 1.D300
           GOTO 2
         ENDIF
         FN=FN+F(I)*F(I)
diff -bur ./calcmassfromgeff.f ../../powr-refactor/src/calcmassfromgeff.f
--- ./calcmassfromgeff.f	2024-07-28 13:12:57.000000000 +0200
+++ ../../powr-refactor/src/calcmassfromgeff.f	2023-09-27 10:14:15.097755357 +0200
@@ -1,8 +1,8 @@
       SUBROUTINE CALCMASSFROMGEFF(bFixGEFF, bFULLHYDROSTAT,
      >                            XMSTAR, GLOG, GEFFLOG, 
      >                            ARAD, APRESS, AGRAV, RADIUS, ND,
-     >                            RSTAR, RCON, RI, TAUROSS,
-     >                            GAMMARADMEAN, GEDD,
+     >                            RSTAR, RCON, RI, VELO, TAUROSS,
+     >                            VMACH, GAMMARADMEAN, GEDD,
      >                            XLOGL, QIONMEAN, fGAMMACOR)
 C***********************************************************************
 C***  updates GLOG and XMSTAR if GEFF has been fixed in the CARDS file
@@ -20,11 +20,11 @@
       
       LOGICAL, INTENT(IN) :: bFixGEFF, bFULLHYDROSTAT
       
-      REAL, DIMENSION(ND) :: RADIUS, TAUROSS
+      REAL, DIMENSION(ND) :: RADIUS, TAUROSS, VMACH, VELO
       REAL, DIMENSION(ND-1) :: ARAD, AGRAV, APRESS, RI
             
       
-      REAL :: DIFF1, DIFF2, XLSTARS, facMASS, GTRUE
+      REAL :: DIFF1, DIFF2, XLSTARS, facMASS, GTRUE, Rphoto
       INTEGER :: L, LCON, Lfm
 
       !Physical constants:
@@ -46,16 +46,28 @@
                   
       XLSTARS = 10**(XLOGL)
 
+C***  Fallback option: if RCON is not available, use sonic point
+      Rphoto = RCON
+      IF (Rphoto < RADIUS(ND) .OR. Rphoto > RADIUS(1)) THEN        
+        Rphoto = RADIUS(ND)
+        rsloop: DO L=ND-1, 1, -1
+          IF (VELO(L) > VMACH(L)) THEN
+            EXIT rsloop
+          ENDIF
+          Rphoto = RADIUS(L)
+        ENDDO rsloop 
+      ENDIF
+      
       Lfm = ND
       IF (bFixGEFF .AND. bFULLHYDROSTAT) THEN
         LCON = ND
-        DO WHILE (RADIUS(LCON) < RCON) 
+        DO WHILE (RADIUS(LCON) < Rphoto) 
           LCON = LCON - 1
         ENDDO
         
         !Calculate GAMMARADMEAN without limitation here:
         CALL CALCGAMMARADMEAN(ARAD, AGRAV, RADIUS, TAUROSS, 
-     >                        ND, RCON, RI, GAMMARADMEAN)
+     >                        ND, Rphoto, RI, GAMMARADMEAN)
         
         !We need to update the mass, so we need to find a point where
         ! GAMMARADMEAN is realized
@@ -99,5 +111,4 @@
           GEDD = 1. - 10.**( GEFFLOG - GLOG )
       ENDIF        
       
-      
       END
diff -bur ./cbbfe.f ../../powr-refactor/src/cbbfe.f
--- ./cbbfe.f	2024-07-28 13:12:58.000000000 +0200
+++ ../../powr-refactor/src/cbbfe.f	2023-09-27 10:14:15.097755357 +0200
@@ -10,10 +10,15 @@
 C***  Calling tree: STEAL - COMA - COLLI - CBBFE
 C***********************************************************************
  
-      DIMENSION EINST(NDIM,NDIM)
+      INTEGER, INTENT(IN) :: NDIM, NUP, LOW
+      REAL, INTENT(IN) :: TL, TROOT, WAVENUM, WN3
+      REAL, INTENT(OUT) :: OMEGA
+      REAL, DIMENSION(NDIM, NDIM), INTENT(IN) :: EINST
 
       REAL, EXTERNAL :: EXPINT1EXP
       
+      REAL :: C1, U0, GAMMA
+
 C***  C1 = H * C / K    ( CM * KELVIN )
       DATA C1 / 1.4388 /
 
@@ -22,6 +27,11 @@
 C***           GAMMA = MAX(G,.276*EXP(U0)*E1(U0))
 C***            (E1: FIRST EXPONENTIAL INTEGRAL)
 
+
+C**     Keith Butler:
+C**     G = 0.2 for mainqn change, otherwise should be 0.7
+
+
       U0 = C1 * WAVENUM / TL
       GAMMA = AMAX1 (0.2, 0.276*EXPINT1EXP(U0))
       OMEGA = 20.56 * GAMMA * EINST(NUP,LOW) / WN3 / TROOT
diff -bur ./cbbn.f ../../powr-refactor/src/cbbn.f
--- ./cbbn.f	2024-07-28 13:12:59.000000000 +0200
+++ ../../powr-refactor/src/cbbn.f	2023-09-27 10:14:15.097755357 +0200
@@ -202,7 +202,7 @@
           ELSE
 C***  NO/UNKNOWN KEYWORD 'KEYCBB' DECODED
               CALL REMARK (' N IV: WRONG KEYWORD KEYCBB ')
-              STOP 'ERROR'
+              GOTO 999
           ENDIF
  
 C***  N V  *************************************************************
@@ -226,7 +226,7 @@
           ELSE
 C***  NO/UNKNOWN KEYWORD 'KEYCBB' DECODED
               CALL REMARK (' N V: WRONG KEYWORD KEYCBB ')
-              STOP 'ERROR'
+              GOTO 999
           ENDIF
  
 C***  N VI  ************************************************************
diff -bur ./ccore.f ../../powr-refactor/src/ccore.f
--- ./ccore.f	2024-07-28 13:12:59.000000000 +0200
+++ ../../powr-refactor/src/ccore.f	2023-09-27 10:14:15.097755357 +0200
@@ -1,6 +1,6 @@
       SUBROUTINE CCORE (WCHARM,NF,GAMMAC,DELTAC,IPRICC,MODHEAD,JOBNUM,
-     $      SCOLD,RADIUS,XLAMBDA,ND,T,RNE,POP1,ENTOT,RSTAR,
-     $      OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,
+     $      SCOLD,RADIUS,XLAMBDA,ND,T,RNE,POP1,POPMIN,ENTOT,
+     $      RSTAR,OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,
      $      NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,SIGMAKI,
      $      MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,XDATA,
      $      KONTNUP,KONTLOW,LASTKON, FILLFAC, WJC, OPC, WJCMIN,
@@ -19,7 +19,8 @@
 C*******************************************************************************
  
       DIMENSION WCHARM(ND,NF),SCOLD(NF,ND), WJC(ND,NF)
-      DIMENSION RADIUS(ND),OPA(ND),ETA(ND),THOMSON(ND),XLAMBDA(NF)
+      DIMENSION RADIUS(ND),OPA(ND),ETA(ND),THOMSON(ND),FILLFAC(ND)
+      DIMENSION XLAMBDA(NF)
       CHARACTER*8 VERSION, OPC
       LOGICAL BPLOCC
 
@@ -32,12 +33,12 @@
       ELSE IF (OPC(1:4) .EQ. 'DIAG') THEN
         VERSION = 'DIAG'
       ENDIF
-      write (0,*) 'VERSION=', VERSION
+      write (0,*) 'CCORE: VERSION=', VERSION
 
 C***  LOOP OVER ALL CONTINUUM FREQUENCIES  *************************************
       DO 4 K=1,NF
       XLAM=XLAMBDA(K)
-      CALL COOP (XLAM,ND,T,RNE,POP1,ENTOT,RSTAR,
+      CALL COOP (XLAM,ND,T,RNE,POP1,POPMIN,ENTOT,RSTAR,
      $           OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,KODAT,
      $           NDIM,N,MAXATOM,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
      $           DUMMY,DUMMY,DUMMY,
@@ -47,8 +48,8 @@
      $           KONTNUP,KONTLOW,LASTKON,XDATA)                  
  
       DO L=1, ND
-        OPA(L) = OPA(L) * FILLFAC
-        ETA(L) = ETA(L) * FILLFAC
+        OPA(L) = OPA(L) * FILLFAC(L)
+        ETA(L) = ETA(L) * FILLFAC(L)
       ENDDO
 
 C***  BRANCH FOR  GAMMAC .EQ. .0  -----------------
diff -bur ./check_lines.f ../../powr-refactor/src/check_lines.f
--- ./check_lines.f	2024-07-28 13:13:00.000000000 +0200
+++ ../../powr-refactor/src/check_lines.f	2024-02-01 09:02:46.186341689 +0100
@@ -2,33 +2,60 @@
      >             LINECHECK, ILINECHECK, NLINE, MAXLIN, LEVEL,
      >             LIND, LINDS, WS, BPLOT, RADIUS, NLACT, LINE, 
 C***  for PRELINECL
-     >             NUP, LOW, N, XLAM, NDIM, ND, XJLMEAN, ELEVEL, 
-     >             INDNUP, INDLOW, NDDIM, 
+     >             NUP, LOW, N, XLAM, NDIM, ND, XJLMEAN, XLAMAPPMEAN,
+     >             bALOTri, XLAMAPPUMEAN, XLAMAPPLMEAN,
+     >             ELEVEL, INDNUP, INDLOW, NDDIM, 
 C***  and also for LIOP
      >             EINST, WEIGHT, XLAMSOR, ENTOT, POPNUM, RSTAR, 
-     >             OPAL, ETAL, VDOP)
+     >             OPAL, ETAL, VDOPUNIT, hMODEL, hALO)
 C****************************************************************
-C***  Check-out from the list those lines which are finished 
-C***    --> J-bars are writted to the Model File
-C***  Add new Lines to the List of Active Lines
+C***  Adds new Lines to the List of Active Lines
 C***    The Line Opacities are prepared
+C***  Deletes Lines which are finished from the List
+C***    The J-bars are writted to the Model File
+C***
+C***  Active lines are 1 ... NLACT and identified via the 
+C***  LIND array. LIND returns the IND (line index) for an 
+C***  active transition. LIND == 0 means that this entry is
+C***  unused. Note that due to additions and removals LIND is
+C***  not necessarily filled as a block, but instead might have
+C***  a mix or zero and non-zero entries between 1 and MAXLIN.
 C***
 C***    Called by COLI
 C****************************************************************
 
+      INTEGER, INTENT(IN) :: hMODEL, hALO
+      LOGICAL, INTENT(IN) :: bALOTri
+
       DIMENSION XKMIN(NLINE), XKMID(NLINE), XKMAX(NLINE), LINE(NLINE)
-      DIMENSION LIND(MAXLIN), LINDS(MAXLIN), WS(MAXLIN)
+      DIMENSION LIND(MAXLIN), LINDS(MAXLIN), WS(NDDIM, MAXLIN)
       DIMENSION NUP(MAXLIN), LOW(MAXLIN), XLAM(MAXLIN)
       DIMENSION XLAMSOR(NLINE)
       DIMENSION RADIUS(ND)
       DIMENSION EINST(NDIM,NDIM), WEIGHT(NDIM)
-      DIMENSION XJLMEAN(NDDIM,MAXLIN)
+      DIMENSION XJLMEAN(NDDIM,MAXLIN), XLAMAPPMEAN(NDDIM, MAXLIN)
+      DIMENSION XLAMAPPUMEAN(NDDIM,MAXLIN), XLAMAPPLMEAN(NDDIM, MAXLIN)
       DIMENSION OPAL(NDDIM,MAXLIN), ETAL(NDDIM,MAXLIN)
 
       LOGICAL BPLOT
+      REAL :: POPMIN
+
+      CHARACTER(8) :: NAME
+      CHARACTER(10), DIMENSION(NDIM) :: LEVEL
+      
+      REAL, PARAMETER :: ALOMAX = 0.9999999999
+
+C***  At the first call of this routine we have
+C***  LINECHECK = 1  and  ILINECHECK = LINE(LINECHECK)
+C***  This has been prepared in the subroutine PREPK, 
+C***  together with the XKMIN and XKMAX arrays.
+
+C***  In subsequent call, LINECHECK always keeps its current
+C***  value. This is possible since the lines are ordered by
+C***  wavelengths and thus each line has only one wavelength
+C***  regime where it is active. (I.e., once its active region
+C***  has passed, it will never be active again!)
 
-      CHARACTER NAME*8
-      CHARACTER LEVEL(NDDIM)*10
 
 C****************************************************************
 C***  Check the currently active lines if they can be checked out
@@ -38,19 +65,47 @@
          LACTS = LINDS(NL)
          IF (LACT .EQ. 0) CYCLE
 C***     Line has been finished? -> Store XJL and check-out
+C***      (for iron lines, storing is done in WMODCOLI)
          IF (XKMAX(LACTS) .LT. XK) THEN
             DO L=1, ND
-              XJLMEAN(L,NL) = XJLMEAN(L,NL) / WS(NL)
+              XJLMEAN(L,NL) = XJLMEAN(L,NL) / WS(L,NL)
+     >                         /RADIUS(L)/RADIUS(L)
+              XLAMAPPMEAN(L,NL) = XLAMAPPMEAN(L,NL) / WS(L,NL)
+     >                         /RADIUS(L)/RADIUS(L)
+C***          Limit to values between 0 and ALOMAX:
+              XLAMAPPMEAN(L,NL) = MAX(0., XLAMAPPMEAN(L,NL))
+              XLAMAPPMEAN(L,NL) = MIN(XLAMAPPMEAN(L,NL), ALOMAX)
+              IF (bALOTri) THEN
+                XLAMAPPUMEAN(L,NL) = XLAMAPPUMEAN(L,NL) / WS(L,NL)
+     >                         /RADIUS(L)/RADIUS(L)
+                XLAMAPPLMEAN(L,NL) = XLAMAPPLMEAN(L,NL) / WS(L,NL)
      >                         /RADIUS(L)/RADIUS(L)
+              ENDIF
             ENDDO
+
             IF (LACT <= 9999) THEN
               WRITE (NAME,'(A3,I4,A1)') 'XJL',LACT,' '
             ELSE
               WRITE (NAME,'(A3,I5)') 'XJL',LACT
             ENDIF
-            CALL WRITMS 
-     >        (3, XJLMEAN(1,NL), ND, NAME, -1, IDUMMY, IERR)
+C***        Write J_L_bar into MODEL file
+            CALL WRITMS(hMODEL, 
+     >        XJLMEAN(1,NL), ND, NAME, -1, IDUMMY, IERR)
 C***        empty entries are marked by LIND=0
+C***        Write freq.-integrated ALO into ALO file
+            WRITE (NAME,'(A3,I5)') 'ALO', LACT
+            CALL WRITMS(hALO, 
+     >        XLAMAPPMEAN(1,NL), ND, NAME, -1, IDUMMY, IERR)
+C***        Tri-diagonal ALO is only calculated and stored
+C***          if requested via CARDS line (XJLAPP COLI TRI)
+            IF (bALOTri) THEN
+              WRITE (NAME,'(A3,I5)') 'ALU', LACT
+              CALL WRITMS(hALO, 
+     >          XLAMAPPUMEAN(1,NL), ND, NAME, -1, IDUMMY, IERR)
+              WRITE (NAME,'(A3,I5)') 'ALL', LACT
+              CALL WRITMS(hALO, 
+     >          XLAMAPPLMEAN(1,NL), ND, NAME, -1, IDUMMY, IERR)
+            ENDIF
             LIND(NL) = 0
             NLACT = NLACT - 1
 cc         Plotting facility not documented
@@ -61,6 +116,7 @@
          ENDIF
       ENDDO
 
+
 C***  **************************************
 C***  Which lines are newly becoming active?
 C***  **************************************
@@ -74,7 +130,14 @@
 C***          Free table entry found at NLNEW
                 LIND(NLNEW) = ILINECHECK
                 LINDS(NLNEW) = LINECHECK
-                WS(NLNEW) = 0.
+                DO L=1, ND
+                  WS(L, NLNEW) = 0.
+                  XLAMAPPMEAN(L, NLNEW) = 0.
+                  IF (bALOTri) THEN
+                    XLAMAPPUMEAN(L, NLNEW) = 0.
+                    XLAMAPPLMEAN(L, NLNEW) = 0.
+                  ENDIF
+                ENDDO
 C***            Prepare line quantities
                 CALL PRELINE (NUP(NLNEW), LOW(NLNEW), ILINECHECK, N, 
      >                 XLAM(NLNEW), ND, XJLMEAN(1,NLNEW), 
@@ -83,7 +146,7 @@
      >                 WEIGHT(LOW(NLNEW)), 
      >                 WEIGHT(NUP(NLNEW)), LOW(NLNEW), NUP(NLNEW), ND, 
      >                 XLAMSOR(LINECHECK), ENTOT, POPNUM, RSTAR, 
-     >                 OPAL(1,NLNEW), ETAL(1,NLNEW), VDOP)
+     >                 OPAL(1,NLNEW), ETAL(1,NLNEW), VDOPUNIT)
 c                IF (BPLOT) THEN
 c                  WRITE (38,'(A,F9.2,1X,F3.0,1X,A,I4,1X,I4,F11.3)') 
 c     >              'KASDEF LUN ', XK, FLOAT(NLNEW), '0. 0.1 0.2 &E', 
diff -bur ./cldiffus.f ../../powr-refactor/src/cldiffus.f
--- ./cldiffus.f	2024-07-28 13:13:01.000000000 +0200
+++ ../../powr-refactor/src/cldiffus.f	2023-11-21 10:10:55.277269761 +0100
@@ -1,12 +1,14 @@
       SUBROUTINE CLDIFFUS (XLAM,T,RADIUS,ND,BCORE,DBDR,DTDR,TEFF,
      >                     OPAK,XHID)
 C***********************************************************************
-C***  CALLED FROM: WRCONT, ETL
-C***  GIVES THE PLANCK FUNCTION, BCORE, AND ITS RADIUS-DERIVATIVE, DBDR, AT
-C***  THE INNER BOUNDARY FROM ...
-C***               ... "DTDR", THE DERIVATIVE OF THE TEMPERATURE WITH
-C***                    RESPECT TO THE RADIUS, AS CALCULATED IN SUBR. DIFDTDR
+C***  CALLED FROM: COLI
+C***
+C***  GIVES THE PLANCK FUNCTION, BCORE, AND ITS RADIUS-DERIVATIVE, DBDR,
+C***    AT THE INNER BOUNDARY FROM "DTDR", THE DERIVATIVE OF THE 
+C***    TEMPERATURE WITH RESPECT TO THE RADIUS, 
+C***    AS CALCULATED IN SUBR. DIFDTDR
 C***                    TO YIELD THE CORRECT TOTAL FLUX  H = L/(4*PI*RSTAR)**2
+C***
 C***  IN DIFFUSION APPROXIMATION, THEN THE INCIDENT INTENSITY WILL BE
 C***      IPLUS = BCORE + DBDR * Z / X
 C***  Z = MUE, X = OPACITY
@@ -21,6 +23,7 @@
       DBDR=DBDT*DTDR
 
 C***  Calculate the corresponding H at the inner Boundary
+C***  XHID = pure diffusion term H_diff without (J/B)-correction
       XHID = DBDR/OPAK(ND)/3.
 
       RETURN
diff -bur ./clloade.f ../../powr-refactor/src/clloade.f
--- ./clloade.f	2024-07-28 13:13:01.000000000 +0200
+++ ../../powr-refactor/src/clloade.f	2023-11-21 10:10:55.277269761 +0100
@@ -1,8 +1,8 @@
       SUBROUTINE CLLOADE (NCHANE, NZE1, NZE2, NFRO, EDDIA, NDEDDIA, 
-     >                    EDDIF, EDDIG, ND, 
-     >                    EDDIHOUT, EDDIHIN, EDDINOUT, EDDININ, 
+     >                    EDDIF, EDDIG, ND, EDDIHOUT, 
+     >                    EDDIHIN, EDDIHINM, EDDINOUT, EDDININ, 
      >                    BCLEERR, BCOLIP, XHI, XHO, EPSG, 
-     >                    XHOM, XNOM, EDDIHOUTP, EDDINOUTP)
+     >                    XHOM, XNOM, EDDIHOUTP, EDDINOUTP, EDDIHINT)
 C**********************************************************************
 C***  Reads the old EDDIEs from file fort.<NCHANE>
 C***  If this file does not exist or is inappropriate (BCLEERR = .TRUE.)
@@ -16,6 +16,10 @@
       CHARACTER NAME*8
       LOGICAL BCLEERR, BCOLIP
 
+      !File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+      
 C***  In the first call of this routine, the EDDIMIX-Factors are read
 C***    (or set ZERO, if not present on old EDDI file)
       IF (NZE1 .EQ. 0) THEN
@@ -41,8 +45,10 @@
           WRITE (NAME,'(A2,I5,A1)') 'ED', NZE1, ' '
           CALL READMS (NCHANE, EDDIA, NDEDDIA*NFRO, NAME, IERR)
           IF (IERR .NE. 0) THEN
-            WRITE (0,'(A,I2)') 
-     >        'Error when reading from file fort.', NCHANE
+            WRITE (0,'(A,I5,A,I2)') 
+     >        'Error ', IERR,' when reading from file fort.', NCHANE
+            WRITE (hCPR,'(A,A,A,I8)') 
+     >        'Missing Entry: ', NAME, ' of length ', NDEDDIA*NFRO
             STOP 'ERROR in Subr. CLLOADE'
           ENDIF
         ENDIF
@@ -69,6 +75,8 @@
         XNOM     = EDDIA(NDA+8, NZE2)
         EDDIHOUTP= EDDIA(NDA+9, NZE2)
         EDDINOUTP= EDDIA(NDA+10, NZE2)
+        EDDIHINM = EDDIA(NDA+11, NZE2)
+        EDDIHINT = EDDIA(NDA+12, NZE2)
       ENDIF
 
       RETURN
diff -bur ./clsavee.f ../../powr-refactor/src/clsavee.f
--- ./clsavee.f	2024-07-28 13:13:02.000000000 +0200
+++ ../../powr-refactor/src/clsavee.f	2023-11-21 10:10:55.277269761 +0100
@@ -1,8 +1,8 @@
       SUBROUTINE CLSAVEE (NCHANE, NZE1, NZE2, NFRO, EDDIA, NDEDDIA, 
-     >                    EDDIF, EDDIG, ND, 
-     >                    EDDIHOUT, EDDIHIN, EDDINOUT, EDDININ, 
+     >                    EDDIF, EDDIG, ND, EDDIHOUT, 
+     >                    EDDIHIN, EDDIHINM, EDDINOUT, EDDININ, 
      >                    BCLEERR, CMODE, XHI, XHO, EPSG, 
-     >                    XHOM, XNOM, EDDIHOUTP, EDDINOUTP)
+     >                    XHOM, XNOM, EDDIHOUTP, EDDINOUTP, EDDIHINT)
 C**********************************************************************
 C***  Saves the old EDDIEs to file fort.<NCHANE>
 C**********************************************************************
@@ -12,6 +12,8 @@
       DIMENSION EPSG(ND)
       CHARACTER NAME*8, CMODE*1
       LOGICAL BCLEERR
+      INTEGER :: IDUMMY
+      REAL :: DBDTAUND, EDDIHINT
 
 C***  Store the EDDIEs into EDDIA
 C***  At this point the change of the EDDIEs could be calculated
@@ -33,14 +35,16 @@
       EDDIA(NDA+8, NZE2) = XNOM
       EDDIA(NDA+9, NZE2) = EDDIHOUTP
       EDDIA(NDA+10, NZE2) = EDDINOUTP
+      EDDIA(NDA+11, NZE2) = EDDIHINM
+      EDDIA(NDA+12, NZE2) = EDDIHINT
 
 C***  Save array to file
       IF (NZE2 .EQ. NFRO .OR. CMODE .EQ. 'F') THEN
         WRITE (NAME,'(A2,I5,A1)') 'ED', NZE1, ' '
-        CALL WRITMS (NCHANE, EDDIA, NDEDDIA*NFRO, NAME, IERR)
+        CALL WRITMS (NCHANE, EDDIA, NDEDDIA*NFRO, NAME,-1,IDUMMY, IERR)
       ENDIF
       IF (CMODE .EQ. 'F') THEN
-        CALL WRITMS (NCHANE, EPSG, ND-1, 'EPSG    ', IERR)
+        CALL WRITMS (NCHANE, EPSG, ND-1, 'EPSG    ',  -1, IDUMMY, IERR)
       ENDIF      
 
       RETURN
diff -bur ./cmfcoop.f ../../powr-refactor/src/cmfcoop.f
--- ./cmfcoop.f	2024-07-28 13:13:03.000000000 +0200
+++ ../../powr-refactor/src/cmfcoop.f	2023-11-21 10:10:55.277269761 +0100
@@ -1,13 +1,17 @@
-      SUBROUTINE CMFCOOP (XLAM,ND,T,RNE,POPNUM,ENTOT,RSTAR, LEVEL,
-     >       OPA,ETA,THOMSON,NDIM,N,NCHARG,WEIGHT,ELEVEL,EION,
+      SUBROUTINE CMFCOOP (XLAM,ND,T,RNE,POPNUM,ENTOT,RSTAR,
+     >       LEVEL,OPA,ETA,THOMSON,NDIM,N,NCHARG,WEIGHT,ELEVEL,EION,
      >       EINST,ALPHA,SEXPO, ADDCON1, ADDCON2, ADDCON3, 
      >       IGAUNT,SIGMA1I,KONTLOW,KONTNUP,LASTKON,NATOM,KONTHLP, 
      >       DENSCON,BPLOT,BPLOT2,IPLOT,K,KCL,KCU,KCDELTA,
      >       OPACL,OPACU,ETACL,ETACU,XLAM0LN,ALN, MAXXDAT, XDATA, 
-     >       SIGMATHK,SEXPOK,EDGEK, MAXATOM, NOM, KODAT, RADIUS)
+     >       SIGMATHK,SEXPOK,EDGEK, MAXATOM, NOM, KODAT, RADIUS,
+     >       MAINPRO, MAINLEV, IWARN, OPACLEL, OPACUEL, OPACELEM,
+     >       ETACLEL, ETACUEL, ETACELEM, OPACLION, OPACUION,
+     >       OPACION, ETACLION, ETACUION, ETACION, 
+     >       OPALEL, ETALEL, OPALION, ETALION)
 C***********************************************************************
 C***  NON-LTE CONTINUOUS OPACITY AT GIVEN FREQUENCY FOR ALL DEPTH POINTS
-C***  OPTIMIZED VERSION OF SUBR. COOP, CALLED FROM MAIN PROGRAM CMF
+C***  OPTIMIZED VERSION OF SUBR. COOP, CALLED FROM MAIN PROGRAM COLI
 C***  This version (23-Mar-2007) assumes that KODAT positions
 C***  (i.e. KODATIND) give the atomic number (NCORECHARGE)
 C***********************************************************************
@@ -18,8 +22,8 @@
       DIMENSION NCHARG(N),WEIGHT(N),ELEVEL(N),EION(N)
       DIMENSION NOM(N)
       DIMENSION KODAT(MAXATOM)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      INTEGER, DIMENSION(MAXATOM) :: NFIRST, NLAST
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION KONTLOW(LASTKON),KONTNUP(LASTKON),KONTHLP(LASTKON)
       DIMENSION EINST(NDIM,NDIM)
       DIMENSION POPNUM(ND,N)
@@ -30,23 +34,31 @@
       DIMENSION OPACL(ND),OPACU(ND)
       DIMENSION ETACL(ND),ETACU(ND)
       DIMENSION XDATA(MAXXDAT)
+      REAL, DIMENSION(NATOM, ND) :: OPACELEM, OPACLEL, OPACUEL,
+     >                              ETACELEM, ETACLEL, ETACUEL
+      REAL, DIMENSION(ND, NATOM, MAXION) :: OPACION, OPACLION, OPACUION,
+     >                                      ETACION, ETACLION, ETACUION     
+      REAL, DIMENSION(NATOM) :: OPALEL, ETALEL
+      REAL, DIMENSION(NATOM, MAXION) :: OPALION, ETALION
       CHARACTER(10), DIMENSION(N) :: LEVEL
+      CHARACTER(10), DIMENSION(ND) :: MAINPRO, MAINLEV
+      CHARACTER(8), DIMENSION(ND) :: IWARN
       LOGICAL XRAYS, KSHELL
 
       LOGICAL BPLOT,BPLOT2,BFCALC
 
 C***  Output of laser warnings for bound-free transitions
+      INTEGER, SAVE :: NWARN
       DATA NWARN /0/ ! no warning has been issued yet
-      SAVE NWARN
 
 C***  tiefenabh. clumping nach goetz
       DIMENSION DENSCON(ND)
 
 C***  Dimension of the core-charge data locally provided here
-      PARAMETER (MAXATOMDIM = 26)
-      DIMENSION KODATIND(MAXATOMDIM)
+      INTEGER, PARAMETER :: MAXATOMDIM = 30
+      REAL, DIMENSION(MAXATOMDIM) :: KODATIND
       
-      REAL :: XLAM, W, W3
+      REAL :: OPAMAX, XLAM, PARALKONT, W, W3
  
 C***  C1 = H * C / K    ( CM * ANGSTROEM )
       DATA C1 / 1.4388 /
@@ -84,7 +96,7 @@
          NATOMMAX = NOM(N)
          IF (MAXATOM .GT. MAXATOMDIM) THEN
             WRITE (0,*) '*** ERROR: MAXATOMDIM TOO SMALL'
-            STOP 'ERROR IN COOP'
+            STOP 'ERROR IN CMFCOOP'
          ENDIF
 C***     Now find for each NA the corresponding KODAT index
          DO NA=1, NATOMMAX
@@ -94,7 +106,7 @@
             ENDDO
             IF (KODATIND(NA) .EQ. 0) THEN
                WRITE (0,*) '*** ERROR: ELEMENT NOT FOUND'
-               STOP 'ERROR IN COOP'
+               STOP 'ERROR IN CMFCOOP'
             ENDIF
             IF (KODATIND(NA) .GT. MAXATOMDIM) THEN
                WRITE (0,*) '*** ERROR: NCORECHARGE NOT FOUND'
@@ -141,6 +153,14 @@
          DO L=1, ND
             OPACL(L) = OPACU(L)
             ETACL(L) = ETACU(L)
+            DO NA=1, NATOM
+              OPACLEL(NA,L) = OPACUEL(NA,L)
+              ETACLEL(NA,L) = ETACUEL(NA,L)
+              DO ION=1, MAXION
+                OPACLION(L, NA, ION) = OPACUION(L, NA, ION)
+                ETACLION(L, NA, ION) = ETACUION(L, NA, ION)
+              ENDDO
+            ENDDO
          ENDDO
          KCU = KCU+KCDELTA
          IF (BPLOT) WRITE (39,'(I6,1X,F3.0)') KCU, -3.
@@ -178,8 +198,18 @@
       DO 1 L=1,ND
       NBFLASER = 0
    55 CONTINUE
+      OPAMAX=.0
       OPAL=.0
       ETAL=.0
+      DO NA=1, NATOM
+        OPALEL(NA) = .0
+        ETALEL(NA) = .0
+        DO ION=1, MAXION
+          OPALION(NA, ION) = .0
+          ETALION(NA, ION) = .0
+        ENDDO
+      ENDDO
+      IWARN(L)='        '
       TL=T(L)
       ROOTTL=SQRT(TL)
       T32=TL*ROOTTL
@@ -191,6 +221,14 @@
       IF (BFCALC) THEN
          OPACU(L) = 0.
          ETACU(L) = 0.
+         DO NA=1, NATOM
+           OPACUEL(NA,L) = 0.
+           ETACUEL(NA,L) = 0.
+           DO ION=1, MAXION
+             OPACUION(L, NA, ION) = 0.
+             ETACUION(L, NA, ION) = 0.
+           ENDDO
+         ENDDO
          DO 5 KH=1,KHELP
             KONT=KONTHLP(KH)
             J=KONTNUP(KONT)
@@ -223,19 +261,31 @@
 C***          replaced by the more radical version that any lasering b-f 
 C***          transition is immediately disregarded - wrh  4-Apr-2019
         IF (SUM .LT. .0) THEN 
+              IWARN(L) = '*       '
           IF (NWARN .EQ. 0)   WRITE (0, 90) L, LEVEL(I), LEVEL(J)
    90     FORMAT ('*** WARNING FROM Subr. CMFCOOP: ',
-     >    'LASERING BOUND-FREE CONTINUA SUPPRESSED',
-     >    /,'*** THIS OCCURED FOR THE FIRST TIME AT DEPTH INDEX', I7,
-     >    /,'*** BETWEEN LEVELS ', A10, ' AND ', A10 )
+     >          'LASERING BOUND-FREE CONTINUA SUPPRESSED',/,
+     >          '*** THIS OCCURED FOR THE FIRST TIME AT DEPTH INDEX',
+     >          I7,/,'*** BETWEEN LEVELS ', A10, ' AND ', A10 )
          NWARN = NWARN + 1
         ELSE
+              NA = NOM(I)
+              ION = NCHARG(I) + 1
            OPACU(L)=OPACU(L)+SUM
+              OPACUEL(NA,L) = OPACUEL(NA,L) + SUM
+              OPACUION(L, NA, ION) = OPACUION(L, NA, ION) + SUM
            ETACU(L)=ETACU(L)+EMINDU
+              ETACUEL(NA,L) = ETACUEL(NA,L) + EMINDU
+              ETACUION(L, NA, ION) = ETACUION(L, NA, ION) + EMINDU
         ENDIF
 
- 5       CONTINUE
+            IF (SUM > OPAMAX) THEN
+              OPAMAX = SUM
+              MAINPRO(L)='BOUND-FREE'
+              MAINLEV(L)=LEVEL(I)
+            ENDIF
 
+    5    CONTINUE
 
 C***  K-SHELL IONISATION  **********************************************
       IF (KSHELL) THEN      
@@ -254,7 +304,7 @@
 C***        K-SHELL IONIZATION NEEDS IONS WITH AT LEAST 3 ELECTRONS LEFT
             IF (KODATIND(NOMJ) - NCHARG(J) .LT. 3) THEN  
                WRITE (0,*) 'UNEXPECTED INCONSISTENCY WITH K-SHELL DATA'
-               STOP 'ERROR in Subr. COOP'
+               STOP 'ERROR in Subr. CMFCOOP'
             ENDIF
 
             IF (LASTNOMJ .NE. NOMJ .OR. LASTISTATE .NE. ISTATE) THEN
@@ -265,6 +315,14 @@
             ENDIF
             SUM = POPNUM(L,J) * SIGMAK
             OPACU(L) = OPACU(L) + SUM
+            OPACUEL(NOMJ,L) = OPACUEL(NOMJ,L) + SUM
+            OPACUION(L,NOMJ,ISTATE) = OPACUION(L,NOMJ,ISTATE) + SUM
+            IF (SUM > OPAMAX) THEN
+              OPAMAX = SUM
+              MAINPRO(L)='K-SHELL'
+              MAINLEV(L)=LEVEL(J)(:2)
+              WRITE (MAINLEV(L)(4:5), '(I2)') ISTATE
+            ENDIF
     6    CONTINUE
       ENDIF
 
@@ -303,13 +361,25 @@
                ELSE
                   WRITE (0,*) '*** XRAY DIFFERENTIAL EMISSION MEASURE:'
                   WRITE (0,*) '*** INVALID EXPONENT:', DIFFEMEXP
-                  STOP '*** FATAL ERROR IN SUBR. COOP'
+                  STOP '*** FATAL ERROR IN SUBR. CMFCOOP'
                ENDIF
                EMINDU = SUM * FDEM
+               NA = NOM(I)
+               ION = NCHARG(I) + 1
 C*             In the DEM branch, the opacity is set to zero
-               IF (DIFFEMEXP .EQ. .0)
-     >               OPACU(L) = OPACU(L) + (SUM-EMINDU)
+               IF (DIFFEMEXP .EQ. .0) THEN
+                 OPACU(L) = OPACU(L) + (SUM-EMINDU)
+                 OPACUEL(NA,L) = OPACUEL(NA,L) + (SUM-EMINDU)
+                 OPACUION(L,NA,ION) = OPACUION(L,NA,ION) + (SUM-EMINDU)
+               ENDIF
                ETACU(L) = ETACU(L) + EMINDU 
+               ETACUEL(NA,L) = ETACUEL(NA,L) + EMINDU
+               ETACUION(L,NA,ION) = ETACUION(L,NA,ION) + EMINDU
+               IF (SUM > OPAMAX) THEN
+                 OPAMAX = SUM
+                 MAINPRO(L)='XRAYSOURCE'
+                 MAINLEV(L)=LEVEL(I)
+               ENDIF               
             ENDDO
          ENDIF
 C***     X-RAY SOURCE: FREE-FREE BREMSSTRAHLUNG 2
@@ -324,8 +394,19 @@
                SUM = SUM * DENSCON(L)
                EMINDU = SUM * EXPFACXRAY2
                SUM = SUM - EMINDU
+               NA = NOM(I)
+               ION = NCHARG(I) + 1
                OPACU(L) = OPACU(L) + SUM
+               OPACUEL(NA,L) = OPACUEL(NA,L) + SUM
+               OPACUION(L,NA,ION) = OPACUION(L,NA,ION) + SUM
                ETACU(L) = ETACU(L) + EMINDU 
+               ETACUEL(NA,L) = ETACUEL(NA,L) + EMINDU
+               ETACUION(L,NA,ION) = ETACUION(L,NA,ION) + SUM
+               IF (SUM > OPAMAX) THEN
+                 OPAMAX = SUM
+                 MAINPRO(L)='XRAYSOURCE'
+                 MAINLEV(L)=LEVEL(I)
+               ENDIF               
             ENDDO
          ENDIF
       ENDIF
@@ -358,8 +439,19 @@
                   ENDIF
                ENDIF
             ENDIF
+            NA = NOM(I)
+            ION = NCHARG(I) + 1
             OPACU(L)=OPACU(L)+SUM
             ETACU(L)=ETACU(L)+EMINDU
+            OPACUEL(NA,L) = OPACUEL(NA,L) + SUM
+            ETACUEL(NA,L) = ETACUEL(NA,L) + EMINDU
+            OPACUION(L,NA,ION) = OPACUION(L,NA,ION) + SUM
+            ETACUION(L,NA,ION) = ETACUION(L,NA,ION) + EMINDU
+            IF (SUM > OPAMAX) THEN
+              OPAMAX = SUM
+              MAINPRO(L)='FREE-FREE'
+              MAINLEV(L)=LEVEL(I)
+            ENDIF               
  3       CONTINUE
 
       ENDIF
@@ -378,16 +470,42 @@
       IF (K .EQ. KCU) THEN
          OPAL = OPAL+ OPACU(L)
          ETAL = ETAL+ ETACU(L)
+         DO NA=1, NATOM
+           OPALEL(NA) = OPALEL(NA) + OPACUEL(NA,L)
+           ETALEL(NA) = ETALEL(NA) + ETACUEL(NA,L)
+           DO ION=1, MAXION
+             OPALION(NA,ION) = OPALION(NA,ION) + OPACUION(L,NA,ION)
+             ETALION(NA,ION) = ETALION(NA,ION) + ETACUION(L,NA,ION)
+           ENDDO
+         ENDDO
 C***    New Start of Interpolation Procedure if (KCL = KCU)
          IF (KCL .EQ. KCU) THEN
             OPACL(L) = OPACU(L)
             ETACL(L) = ETACU(L)
+            DO NA=1, NATOM
+              OPACLEL(NA,L) = OPACUEL(NA,L)
+              ETACLEL(NA,L) = ETACUEL(NA,L)  
+              DO ION=1, MAXION
+                OPACLION(L,NA,ION) = OPACUION(L,NA,ION)
+                ETACLION(L,NA,ION) = ETACUION(L,NA,ION)
+              ENDDO
+            ENDDO
          ENDIF
       ELSEIF (K .GE. KCL) THEN
          FL = FLOAT(KCU-K)/FLOAT(KCU-KCL)
          FU = 1.-FL         
          OPAL = OPAL + FL*OPACL(L) + FU*OPACU(L)
          ETAL = ETAL + FL*ETACL(L) + FU*ETACU(L)
+         DO NA=1, NATOM
+           OPALEL(NA) = OPALEL(NA) + FL*OPACLEL(NA,L) + FU*OPACUEL(NA,L)
+           ETALEL(NA) = ETALEL(NA) + FL*ETACLEL(NA,L) + FU*ETACUEL(NA,L)
+           DO ION=1, MAXION
+             OPALION(NA,ION) = OPALION(NA,ION) + FL * OPACLION(L,NA,ION)
+     >                                         + FU * OPACUION(L,NA,ION)
+             ETALION(NA,ION) = ETALION(NA,ION) + FL * ETACLION(L,NA,ION)
+     >                                         + FU * ETACUION(L,NA,ION)
+           ENDDO
+         ENDDO
       ELSE
          STOP 'CMFCOOP: FATAL ERROR'
       ENDIF
@@ -400,12 +518,32 @@
       if (l .eq. iplot) then
         sumt = sum
       endif
+C***  New addition to avoid THOMSON == 1 in case of very low OPAL
+      IF (ABS(OPAL/SUM) < 1.E-10) THEN
+        OPAL = (1. + 1.E-10) * SUM
+      ELSE
       OPAL=OPAL+SUM
+      ENDIF
 C***  THOMSON = RELATIVE FRACTION FROM THE TOTAL OPACITY
       THOMSON(L)=SUM/OPAL
+C***  Maximum opacity check only for frequency points
+C***  where the cross sections are not interpolated
+      IF (BFCALC .AND. SUM > OPAMAX) THEN
+        OPAMAX = SUM
+        MAINPRO(L)='THOMSON'
+        MAINLEV(L)='ELECTRON'
+      ENDIF               
  
       OPA(L)=OPAL*ENTOT(L)*RSTAR
       ETA(L)=ETAL*ENTOT(L)*RSTAR
+      DO NA=1, NATOM
+        OPACELEM(NA,L) = OPALEL(NA)*ENTOT(L)*RSTAR
+        ETACELEM(NA,L) = C2*W3*ETALEL(NA)*ENTOT(L)*RSTAR
+        DO ION=1, MAXION
+          OPACION(L,NA,ION) = OPALION(NA,ION)*ENTOT(L)*RSTAR
+          ETACION(L,NA,ION) = C2*W3*ETALION(NA,ION)*ENTOT(L)*RSTAR
+        ENDDO
+      ENDDO
     1 CONTINUE
 C***  ENDLOOP  ---------------------------------------------------------
  
diff -bur ./cmffeop.f ../../powr-refactor/src/cmffeop.f
--- ./cmffeop.f	2024-07-28 13:13:04.000000000 +0200
+++ ../../powr-refactor/src/cmffeop.f	2023-11-21 10:10:55.281269770 +0100
@@ -1,34 +1,54 @@
       SUBROUTINE CMFFEOP (XLAMK, ND, N, INDFEACT, MAXFEACT, LASTFE,
-     >                    SIGMAFE, OPAFE, ETAFE, INDRB,
+     >                    SIGMAFE, OPAFE, ETAFE, INDEXMAX, INDRB,
      >                    IFRBSTA, IFRBEND, IFENUP, IFELOW,
      >                    CLIGHT, VDOPFE, DXFE, XLAM0FE,
      >                    ELEVEL, WEIGHT, RSTAR, POPNUM, ENTOT,
-     >                    SIGMAACT, OPAFEI, ETAFEI, T, IVERS_FE_EXPFAC, 
-     >                    TEFF)
+     >                    SIGMAACT, OPAFEI, ETAFEI,
+     >                    OPAFEION, ETAFEION, T, IVERS_FE_EXPFAC, 
+     >                    TEFF, NCHARG, MAXION, bFELASER, bNoIronLaser)
 
 C***********************************************************************
 C***  NON-LTE IRON OPACITY AT GIVEN FREQUENCY FOR ALL DEPTH POINTS
 C***  CALLED FROM: COLI and FORMAL -> FORMCMF
 C***********************************************************************
+      IMPLICIT NONE
  
-
-      DIMENSION SIGMAFE(1), INDRB(LASTFE)
-      DIMENSION IFRBSTA(LASTFE), IFRBEND(LASTFE)
-      DIMENSION IFENUP(LASTFE), IFELOW(LASTFE)
-      DIMENSION OPAFE(ND), ETAFE(ND)
-      DIMENSION POPNUM(ND,N), WEIGHT(N), ENTOT(ND)
-      DIMENSION INDFEACT(LASTFE), SIGMAACT(LASTFE)
-      DIMENSION OPAFEI(ND,LASTFE), ETAFEI(ND,LASTFE)
-      DIMENSION ELEVEL(N), T(ND)
-
-C***  C1 = H * C / K    ( CM * ANGSTROEM )
-      DATA C1 / 1.4388 /
-C***  C2 = 2 * H * C     ( CGS UNITS )
-      DATA C2 / 3.9724E-16 /
+      INTEGER, INTENT(IN) :: ND, N, MAXION, LASTFE, INDEXMAX,
+     >                       IVERS_FE_EXPFAC, MAXFEACT
+      REAL, INTENT(IN) :: TEFF, RSTAR, CLIGHT, XLAMK, XLAM0FE, DXFE, 
+     >                    VDOPFE
+      LOGICAL, INTENT(IN) :: bNoIronLaser
+
+      REAL, DIMENSION(INDEXMAX) :: SIGMAFE
+      INTEGER, DIMENSION(LASTFE) :: IFRBSTA, IFRBEND, IFENUP, IFELOW,
+     >                              INDFEACT, INDRB
+      INTEGER, DIMENSION(N) :: IFRBSSTA, IFRBSEND, INDFESACT,
+     >                         INDRBS, IFES
+      REAL, DIMENSION(ND) :: OPAFE, ETAFE, ENTOT, T
+      REAL, DIMENSION(ND, MAXION) :: OPAFEION, ETAFEION
+      REAL, DIMENSION(ND,N) :: POPNUM, POPLTE
+      REAL, DIMENSION(LASTFE) :: SIGMAACT
+      REAL, DIMENSION(ND,LASTFE) :: OPAFEI, ETAFEI
+      REAL, DIMENSION(N) :: ELEVEL, WEIGHT
+      LOGICAL, DIMENSION(ND) :: bFELASER
+      INTEGER, DIMENSION(N) :: NCHARG
+
+      REAL :: SIGMA, SIGMAR, PLASER, ENUP, ENLOW, SUM, G, EMINDU,
+     >        DELTA, SIGMA1, SIGMA2, WAVNUM0, WAVNUM03, XINDF,
+     >        WEIGHTLU, WAVNUMK, WAVNUMK3
+      INTEGER :: L, ION, INDF, INDFSTART, NUP, LOW, IND, INDACT
+            
+     
+C***  Numerical parameters     
+      REAL, PARAMETER :: EXPMAX = 500.
+     
+C***  Physical constants
+      REAL, PARAMETER :: C1 = 1.4388        !C1 = H * C / K    ( CM * ANGSTROEM )
+      REAL, PARAMETER :: C2 = 3.9724E-16    !C2 = 2 * H * C     ( CGS UNITS )
 
 C***  CALCULATE FE-FREQUECY-INDEX
-      XINDF = - ALOG10(XLAM0FE/XLAMK) /
-     >          ALOG10(1. + VDOPFE*DXFE/CLIGHT)
+      XINDF = - LOG10(XLAM0FE/XLAMK) /
+     >          LOG10(1. + VDOPFE*DXFE/CLIGHT)
 
 C***  WAVENUMBERS IN KAYSER ( = CM**-1)
       WAVNUMK = 1.E8 / XLAMK
@@ -38,6 +58,10 @@
       DO L=1, ND
          OPAFE(L) = 0.
          ETAFE(L) = 0.
+         DO ION=1, MAXION
+           OPAFEION(L, ION) = 0.
+           ETAFEION(L, ION) = 0.
+         ENDDO
       ENDDO
       
 C***  LOOP OVER ACTIVE FE-LINES
@@ -46,6 +70,7 @@
          IND = INDFEACT(INDACT)
          LOW = IFELOW(IND)
          NUP = IFENUP(IND)
+         ION = NCHARG(LOW) + 1
          WEIGHTLU = WEIGHT(LOW) / WEIGHT(NUP)
          WAVNUM0 = ELEVEL(NUP) - ELEVEL(LOW)
          WAVNUM03 = WAVNUM0 * WAVNUM0 * WAVNUM0 
@@ -73,6 +98,8 @@
 C***    STORE SIGMA FOR LATER USE
          SIGMAACT(INDACT) = SIGMA
 
+         IF (SIGMA <= 0.) CYCLE
+         
 C***    CALCULATE 'OPA' AND 'ETA' OVER DEPTH INDEX 'L' 
          DO 20 L=1, ND
             ENUP  = POPNUM(L,NUP) * ENTOT(L)
@@ -101,10 +128,22 @@
             ENDIF
 ccc         in the preceding stament WAVNUM03 has been used by Goetz
 
-            IF (OPAFEI(L,IND) .GT. 0.) THEN
+            PLASER = ENUP/WEIGHT(NUP) - ENLOW/WEIGHT(LOW)
+            IF (bNoIronLaser .AND. PLASER > 0.) THEN
+              !skip level
+            ELSEIF (OPAFEI(L,IND) .GT. 0.) THEN
                OPAFE(L) = OPAFE(L) + OPAFEI(L,IND)
                ETAFE(L) = ETAFE(L) + ETAFEI(L,IND)
+               OPAFEION(L,ION) = OPAFEION(L,ION) + OPAFEI(L,IND) 
+               ETAFEION(L,ION) = ETAFEION(L,ION) + ETAFEI(L,IND) 
+                              
+              IF (PLASER > 0. .AND. (.NOT. bFELASER(L))) THEN
+c                WRITE (hCPR,*) 'FE POP INVERSION AT L = ', L
+                bFELASER(L) = .TRUE.
             ENDIF
+            
+            ENDIF
+            
  20      CONTINUE
 
  10   CONTINUE
diff -bur ./cmsstore.f ../../powr-refactor/src/cmsstore.f
--- ./cmsstore.f	2024-07-28 13:13:05.000000000 +0200
+++ ../../powr-refactor/src/cmsstore.f	2024-02-01 09:02:46.186341689 +0100
@@ -19,9 +19,11 @@
 C***  Version 3.1 :
 C***                MAXADR increased from 25600 to 256000 (2000 Records)
 C***                wrh 15-Mar-2005 16:33:59
+C***  Version 3.2 :
+C***                MSMAXCH increased from 3 to 5
 C*******************************************************************
 
-      PARAMETER (MSMAXCH = 3)
+      PARAMETER (MSMAXCH = 5)
 C***  NOTE: MAXADR MUST BE A MULTIPLE OF 128
 C***        (I.E. IADRL IN ROUTINE STORAGE)
       PARAMETER (MAXADR = 2000 * 128)
Only in ../../powr-refactor/src/: coli.exe
Only in ../../powr-refactor/src/: coli.exe.opt
diff -bur ./coli.f ../../powr-refactor/src/coli.f
--- ./coli.f	2024-07-28 13:13:05.000000000 +0200
+++ ../../powr-refactor/src/coli.f	2024-07-22 09:27:16.100033925 +0200
@@ -10,11 +10,11 @@
 
 C***  SET ARRAY DIMENSIONS  ********************************************
 C***  IRON: ADD GENERIC ION TO MAXATOM
-      INTEGER, PARAMETER :: MAXATOM   =             26 
+      INTEGER, PARAMETER :: MAXATOM   =             30 
       INTEGER, PARAMETER :: NDIM      =           2560 
       INTEGER, PARAMETER :: NFDIM     =   2*NDIM + 400 
-      INTEGER, PARAMETER :: MAXAUTO   =           2850 
-      INTEGER, PARAMETER :: MAXIND    =          45000 
+      INTEGER, PARAMETER :: MAXAUTO   =           3200 
+      INTEGER, PARAMETER :: MAXIND    =          45000      !in COLI, MAXIND does NOT contain Fe transitions
       INTEGER, PARAMETER :: MAXKONT   =       NFDIM/2 
       INTEGER, PARAMETER :: NDDIM     =            89 
       INTEGER, PARAMETER :: NPDIM     =            94 
@@ -33,18 +33,21 @@
       INTEGER, PARAMETER :: MAXXDAT =              10 
 
 C***  MAX. NUMBER OF IRON SUPERLINES
-      INTEGER, PARAMETER :: MAXFEIND  =           1500 
+      INTEGER, PARAMETER :: MAXFEIND  =           2500 
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR 
+      INTEGER, PARAMETER :: MAXION = 27 
 
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+c      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !vd20
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !custom hydro
 C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
 
 C***  Fine Integration in STEALCL
-      INTEGER, PARAMETER :: IFF_MAX =   80000      !std
-C      INTEGER, PARAMETER :: IFF_MAX =  200000      !vd20
-C      INTEGER, PARAMETER :: IFF_MAX =  300000      !xxl
+C      INTEGER, PARAMETER :: IFF_MAX =   80000      !std
+c      INTEGER, PARAMETER :: IFF_MAX =  200000      !vd20
+      INTEGER, PARAMETER :: IFF_MAX =  300000      !xxl
 
       INTEGER, PARAMETER :: TINYINT = SELECTED_INT_KIND(2)
 
@@ -57,7 +60,7 @@
      >           LSOPA, LSINT, LEVDEBUG, LASERV, NEXTHYDRO, NEWWRC,
      >           L, NL, IPLOT, LPLOT, IVERS, LPLOT_WCHARM,  
      >           KWORDS, KBLOCKS, ISTATS, IDUMMY, IERR, IFRO, NXJO, NXK,
-     >           NCHANE, NDEDDIA, ITMAX, ITSTART, IT, NZE1, NZE2,
+     >           NDEDDIA, ITMAX, ITSTART, IT, NZE1, NZE2,
      >           IW_COLIMO_F, IW_COLIMO_G, IW_COLIMO_G2, IW_COLIMO_J,
      >           IW_COLIRAY_IPLUS, IW_COLIRAY_U, IWARNJ0, NLASER,
      >           NEWBGC, LBMAX, NBLENDS, KSPACE, KOUT, K, KLAST, NK,
@@ -65,17 +68,19 @@
      >           LINECHECK, ILINECHECK, KCL, KCU, KCDMAX, KCDELTA,
      >           KCCHECK, IFF_N, IF1, IF2, IF3, IF4, MAXFEACT, KCONT,
      >           ITACT, JP, IRAY, NA, LRTCMAX, IOPAMAX1_K, IWARNJMNEG,
-     >           IVERS_FE_EXPFAC, INDDR, N_RUDAUTO, LINEINDEX, ILINE
+     >           IVERS_FE_EXPFAC, INDDR, N_RUDAUTO, LINEINDEX, ILINE,
+     >           iHTOTCUT
 
       INTEGER, DIMENSION(MAXAUTO) :: LOWAUTO, IONAUTO, IONGRND, KRUDAUT
       REAL, DIMENSION(MAXAUTO) :: WAUTO, EAUTO, AAUTO
-      CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
+      CHARACTER(10), DIMENSION(MAXAUTO) :: LEVUPAUTO, LEVAUTO
 
       INTEGER, DIMENSION(MAXATOM) :: KODAT, NFIRST, NLAST
       REAL, DIMENSION(MAXATOM) :: STAGE, ATMASS
       INTEGER, DIMENSION(NDIM) :: NCHARG, MAINQN, NOM
       REAL, DIMENSION(NDIM) :: WEIGHT, ELEVEL, EION, EN
       INTEGER, DIMENSION(MAXKONT) :: KONTHLP
+      CHARACTER(8), DIMENSION(MAXKONT) :: IGAUNT, KEYCBF      
       REAL, DIMENSION(MAXKONT) :: ALPHA, SEXPO, SIGMA1I, 
      >                            ADDCON1, ADDCON2, ADDCON3
       REAL, DIMENSION(NDIM, NDIM) :: EINST
@@ -84,18 +89,21 @@
       
       CHARACTER(MAXHIST*8) :: MODHIST
 
-      REAL, DIMENSION(NFDIM) :: FWEIGHT, HEDDI, XLAMBDA, XLAMBDA2
+      REAL, DIMENSION(NFDIM) :: FWEIGHT, HWRCEDDI, XLAMBDA, XLAMBDA2
       REAL, DIMENSION(NDDIM) :: RADIUS, RADIUS2, RADIUSH, RADIUSH2, 
-     >                          OPA, ETA, THOMSON, ETANOTH,
+     >                          OPA, ETA, THOMSON, ETANOTH, VMIC,
      >                          VELO, GRADI, ENTOT, T, RNE, PP, W0,
      >                          TA, TB, TC, UB, GA, H, QQ, S, VA, VB, 
-     >                          OPAK, ETAK, ETAKNOTH, OPAKNOTH
+     >                          OPAK, ETAK, ETAKNOTH, OPAKNOTH, 
+     >                          XHBFSKIP, XLAMLASTOSKIP
       REAL, DIMENSION(NPDIM) :: P
       REAL, DIMENSION(NDDIM, NDIM) :: POPNUM
-      REAL, DIMENSION(NDDIM, MAXLIN) :: OPAL, ETAL, XJLMEAN
+      REAL, DIMENSION(NDDIM, MAXLIN) :: OPAL, ETAL, XJLMEAN, 
+     >                                  XLAMAPPMEAN,
+     >                                  XLAMAPPUMEAN, XLAMAPPLMEAN
       REAL, DIMENSION(NDDIM, NFDIM) :: XJC
       REAL, DIMENSION(NFLDIM, MAXLIN) :: PHI
-      REAL, DIMENSION(MAXLIN) :: PWEIGHT
+      REAL, DIMENSION(NDDIM, MAXLIN) :: PWEIGHT
       REAL, DIMENSION(NDDIM, NPDIM) :: V, U, Z, PPP
       REAL, DIMENSION(NFLDIM) :: XJNUED
       REAL, DIMENSION(NDDIM) :: XJCIND
@@ -103,15 +111,15 @@
       REAL, DIMENSION(3, NDDIM) :: EDDI
       INTEGER, DIMENSION(MAXIND) :: LINE, INDNUP, INDLOW
       INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW
-      CHARACTER*8 IGAUNT(MAXKONT), KEYCBF(MAXKONT)
 
+      LOGICAL, DIMENSION(NDIM, NDDIM) :: ZERO_RATES
+      LOGICAL, DIMENSION(NDDIM) :: bFELASER, bOSKIPLAST
           
       REAL :: OPAMAX1_LAMBDA, OPAMAX1, HTOTOUTMINUS, EDDIHOUTJMEAN,
      >        DBDTOPAINT_M, DBDTINT_M, DBDTOPAINT, DBDTINT, CMFBAND,
      >        DXMAX, VDOPFE, DXFE, XLAM0FE, TEFF, RSTAR, VDOP, OPARND,
      >        RANGE1, RANGE2, EXLAM1, EXLAM2, DUNLU, DUNLUR, XLP1, XLP2,
-     >        EMIXSTART, EMIXMAX, EMIXFIX, XLAM_FINE_START,
-     >        XLAM_FINE_END,
+     >        EMIXSTART, EMIXFIX, XLAM_FINE_START, XLAM_FINE_END,
      >        GAMMACOLI, GAMMAT, BWES, BWESEX, BWEXBLU, BWEXRED, RIPL2,
      >        UNLU_TAUMAX, UNLU_TAUMAX2, DFEINDR, DTDR, XLAM0, XLAM0LN,
      >        ALN, CMFBANDR, XKCMAX, BANDP, BANDM, DKR, XK, XLAMK, XNK,
@@ -120,8 +128,10 @@
      >        FWEIGHTL, DBDR, XHID, XNO, XNI, XHOP, XNOP, SK1, SK2, 
      >        XNL_MID, XHL_MID, XJL_MID, XNENN, EDDIHOUTOLD, EDDIHINOLD,
      >        XNUEK, XNUEKOLD, XNUEKOLDOLD, SL, SLNOTH, ATMEAN, DELTA,
-     >        TOTOUT, RTCMAX, POPMIN, HTOTMINUSND, HTOTND, HTOTNDCOR,
-     >        DTDRIN
+     >        TOTOUT, POPMIN, HTOTMINUSND, HTOTND, HTOTNDCOR,
+     >        EDDIHINM, EDDIHINMOLD, EDDIHINT, EDDIHINTOLD,
+     >        HTOTNDS, DELTAR, ARADTOT, ARADTESTTOT,
+     >        DTDRIN, VDOPUNIT, CUTOPAMEANTHRES
      
 CC***  NO MORE CONTINUATION LINES ALLOWED IN BERLIN
  
@@ -131,25 +141,28 @@
 
       REAL, DIMENSION(NDDIM) :: VMACH, VELORAW
 
-      REAL, DIMENSION(NDDIM) :: WNUE, HTOTL, UCONT, VCONT
+      REAL, DIMENSION(NDDIM) :: WNUE, HTOTL, HTOTLlast, HTOTLTEST, 
+     >                          UCONT, VCONT, HTOTCUT
       REAL, DIMENSION(MAXXDAT) :: XDATA
       REAL, DIMENSION(MAXATOM) :: ABXYZ
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       REAL, DIMENSION(NPDIM) :: WP1, WP1LAST
 
       CHARACTER(255) :: HISTENTRY
+      CHARACTER(120) :: ALPOPT, DRLINES_CARD
       CHARACTER(100) :: MODHEAD
       CHARACTER(10) :: BLENDMSG
+      CHARACTER(10), DIMENSION(NDDIM) :: MAINPRO, MAINLEV
       CHARACTER(10), DIMENSION(NDIM) :: LEVEL
       CHARACTER(10), DIMENSION(MAXATOM) :: ELEMENT
-      CHARACTER(8) :: NAME
+      CHARACTER(8), DIMENSION(NDDIM) :: IWARN
+      CHARACTER(8) :: NAME, CATMOD
       CHARACTER(4), DIMENSION(MAXIND) :: KEYCBB
       CHARACTER(2), DIMENSION(MAXATOM) :: SYMBOL
       CHARACTER(2) :: CPPLABEL
-      LOGICAL :: LASER, NEWV, BLLIST, BFORMAL, BLFERR, bTDIFFUS
-
-C***  CARDS line 
-      CHARACTER*80 DRLINES_CARD
+      LOGICAL :: LASER, NOLAP, NEWV, DRNORUD, bALOTri,
+     >           BLLIST, BFORMAL, BLFERR, bPLOTRTAU1, 
+     >           bNoIronLaser, bDDVDOP
 
 C***  ARRAYS USED FOR THE COMPLETE REDISTRIBUTION OF LINE PHOTONS
       REAL, DIMENSION(NDDIM+2, NFRO) :: XJLO
@@ -157,6 +170,7 @@
       REAL, DIMENSION(NDDIM) :: ETAC
       CHARACTER(1) :: CMODE
       CHARACTER(8) :: LACTION
+      CHARACTER(4) :: REDISMODE, LASTREDISMODE, REDISMODED
       LOGICAL :: XJLERR
 
 C***  ARRAYS USED FOR PLOT FACILITIES
@@ -167,7 +181,8 @@
       INTEGER, DIMENSION(MAXIND) :: LINFO
       
 C***  Arrays for storing the relative blend complex:
-      REAL, DIMENSION(MAXLIN) :: WS, XLAM
+      REAL, DIMENSION(NDDIM, MAXLIN) :: WS
+      REAL, DIMENSION(MAXLIN) :: XLAM
       INTEGER, DIMENSION(MAXLIN) :: NUP, LBLEND, LOW, IND
 
 C***  To Store Feautrier Matrices ST(94*95,89)
@@ -191,7 +206,7 @@
       REAL, DIMENSION(NDIMEDDIA, NFRO) :: EDDIA
 c      dimension exlam1(maxlin), exlam2(maxlin)
       REAL, DIMENSION(0:NREDMAX, NDDIM) :: WREDI
-      INTEGER, DIMENSION(NDDIM) :: NREDI
+      INTEGER, DIMENSION(NDDIM) :: NREDI, iIgnoreK
       REAL, DIMENSION(NDDIM) :: WRED1, WRED2, WREDISUM, FULFIL0, 
      >                          FULFIL1, OPAKNOTHO, ETAKNOTHO, 
      >                          CLMOETA, CLMOOPA
@@ -203,6 +218,15 @@
 
 C***  Interpolation of continuum opacities
       REAL, DIMENSION(NDDIM) :: OPACL, OPACU, ETACL, ETACU
+      REAL, DIMENSION(MAXATOM) :: OPALEL, ETALEL
+      REAL, DIMENSION(NDDIM, MAXATOM) :: OPALION, ETALION
+      REAL, DIMENSION(MAXATOM, NDDIM) :: OPACLEL, OPACUEL, 
+     >                                   ETACLEL, ETACUEL
+      REAL, DIMENSION(NDDIM, MAXATOM, MAXION) :: OPACLION, OPACUION, 
+     >                                           ETACLION, ETACUION
+     
+C***  Depth- and element-dependent VDOP     
+      REAL, DIMENSION(NDDIM, MAXATOM) :: VDOPDD
 
 C***  Unsoeld-Lucy
       REAL, DIMENSION(NDDIM) :: OPASMEAN, SMEAN, QFJMEAN, OPAJMEAN,
@@ -210,26 +234,25 @@
      >                          OPASMEANTC, OPAPMEAN,
      >                          OPAJMEANTC, OPAROSS, OPALAMBDAMEAN,
      >                          QLFOLD, QLHOLD, OPAKHOLD, 
-     >                          TAUROSS
+     >                          TAUROSS, TAULAST
 
 C***  New Dimensions for Short Characteristics
       REAL, DIMENSION(NDDIM,NPDIM) :: XIPLUS, XIMINUS
       REAL, DIMENSION(NDDIM,NPDIM,NIT) :: XIPLUS_OLD, XIMINUS_OLD
-      REAL, DIMENSION(NDDIM,NIT) :: S_OLD, OPAK_OLD, EPSG
+      REAL, DIMENSION(NDDIM,NIT) :: S_OLD, OPAK_OLD, EPSG, EPSGO
       REAL, DIMENSION(NDDIM) :: EPSGMAX, GEPSB, GEPSBO
+      REAL, DIMENSION(NIT) :: EPSGITMAX
       
-      LOGICAL :: BKONCHECK, BKONCHECK2, BPLOT, BPLOT2, BPDONE,
+      LOGICAL :: BKONCHECK, BKONCHECK2, BPLOT, BPLOT2, BPDONE, BPSTART,
      >           BCOLIP, BCLEERR, BSTATIC, BUSEMO, BCOLIRAY, BSMALLJ,
      >           CLHLP, BXJCE, BSHORT, BITCONT, 
-     >           BKUDRITZKI, BCOLIPP,
-     >           BSHORT_CHAR, BEPSGMAXERR, BEMIX, BEMIXFIX
+     >           BKUDRITZKI, BCOLIPP, bDEBUG,
+     >           BSHORT_CHAR, BEPSGMAXERR, BEMIX, BEMIXFIX,
+     >           bWARNK, bMAXEMIX, bNoNEGEDDIG
 
 C***  Array to handle Laser Condition output 
       LOGICAL, DIMENSION(MAXIND) :: BLASERL
 
-C***  Array indicating POPMIN levels (flagged by steal)
-      LOGICAL, DIMENSION(NDIM,NDDIM) :: ZERO_RATES
-
 C***  Variables to handle Fine Integration in Steal
 C***  FF_INFO : Information on the Frequency grid
 C***         (1) : XLAM0
@@ -261,7 +284,11 @@
       REAL, DIMENSION(MAXFEIND, NDDIM) :: FERATLU, FERATUL   !<-- dies ist im Steal anders dimensioniert
 
       REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
-      REAL, DIMENSION(NDDIM) :: OPAFE, ETAFE
+      REAL, DIMENSION(NDDIM) :: OPAFE, ETAFE, OPAROSSCONT,
+     >                          OPAKFE, OPAKFEOLD, 
+     >                          OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT, 
+     >                          OPAKFEFTOLD, ETAKFEFTOLD
+      REAL, DIMENSION(NDDIM, MAXION) :: OPAFEION, ETAFEION      
 C      REAL, DIMENSION(NDDIM, MAXIND) :: WFELOW, WFENUP      <--- ist das vielleicht richtig?
 C!!! Dimensionierungsfehler, entdeckt am 16-Sep-2002 14:07:15 goetz/wrh
 ccc     >              WFELOW(NDDIM,MAXFEIND), WFENUP(NDDIM,MAXFEIND)
@@ -271,22 +298,24 @@
 
       REAL, DIMENSION(INDEXMAX) :: SIGMAFE
 
-      LOGICAL :: BFECHECK, BFEWING, BFEMODEL
+      LOGICAL :: BFECHECK, BFEWING, BFEMODEL, bTDIFFUS
 
 C***  Calculation of Radiative Accelleration
       REAL, DIMENSION(NDDIM,NIT) :: XJLOLD, XHLOLD
-      REAL, DIMENSION(NDDIM) :: OPAKOLD, ETAKOLD
-      REAL, DIMENSION(NDDIM) :: FTCOLI,
+      REAL, DIMENSION(NDDIM) :: OPAKOLD, ETAKOLD, 
+     >                          OPAKNOFENOTH, OPAKNOFENOTHO, 
+     >                          ETAKNOFENOTH, ETAKNOFENOTHO
+      REAL, DIMENSION(NDDIM) :: FTCOLI, FTCOLIB, 
      >                          ARAD, ACONT, ATHOM
 C***  Calculation of corrected Flux
       REAL, DIMENSION(NDDIM,NIT) :: XKLOLD, XNLOLD
-C***  Calculation of XJC's within COLI
-      REAL, DIMENSION(NDDIM,NFDIM) :: XJCINT
+C***  Calculation of XJC's and coarse-grid opacities within COLI
+      REAL, DIMENSION(NDDIM,NFDIM) :: XJCINT, OPAKINT, ETAKINT
       REAL, DIMENSION(NFDIM) :: FWTEST
 C***  Derivatives of J with respect to S and JOLD
-      REAL, DIMENSION(NDDIM) :: DJDSMO, DJDOMO, DJDSMO_OLD, DJDOMO_OLD
+      REAL, DIMENSION(NDDIM) :: DJDSMOD, DJDSMOD_OLD, DJDSMOU, DJDSMOL
 C***  For Test Output
-      REAL, DIMENSION(NDDIM) :: DJDS, DJDS_OLD
+      REAL, DIMENSION(NDDIM) :: DJDS, DJDS_OLD, DJDSraw
 C***  Diagonal Op. for Continua
       REAL, DIMENSION(NDDIM,NFDIM) :: WJC
       REAL, DIMENSION(NDDIM) :: DSDSC
@@ -294,7 +323,9 @@
       REAL, DIMENSION(NDDIM,NFDIM) :: WJC_MIN
       REAL, DIMENSION(NDDIM) :: DJDSC,DJDSCOLD,ETANOTHO,OPAO,THOMSONO
 C***  Temporary storage vectors for FREQUINT
-      REAL, DIMENSION(NDDIM) :: SUMJ,SUMJW,SUMDJDSC,SUMDJDSCW,SC,SCO
+      REAL, DIMENSION(NDDIM) :: SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW,
+     >                          SUMOPA, SUMOPAW, SUMETA, SUMETAW, 
+     >                          SC, SCO
 
 C***  Depth dependent Clumping
       REAL, DIMENSION(NDDIM) :: DENSCON, FILLFAC
@@ -303,11 +334,29 @@
       REAL, DIMENSION(NFDIM) :: EMCOLI
 
 C***  Force Multipliers for STEAL->HYDROSOLVE
-      LOGICAL :: bForceCOLIP, bForceCLEERR, BPLOTALPHA
-      LOGICAL :: bKALPHA, bHYDROSOLVE, bKATEST, bKADONE, bNewLoop
-      REAL, DIMENSION(NDDIM) :: HTOTTEST, ARADTEST, ALPHAF, RHO, XMU
-
-      REAL :: PARALAS, VINF, VELOMODFAK
+      LOGICAL :: bForceCOLIP, bForceCLEERR, BPLOTALPHA, bAdjVINF
+      LOGICAL :: bKALPHA, bHYDROSOLVE, bKATEST, bKADONE, bNewLoop,
+     >           bPrintAlpha
+      REAL, DIMENSION(NDDIM) :: HTOTTEST, ARADTEST, ATHOMTEST,
+     >                          ALPHAF, ALPHAALT, RHO, XMU, 
+     >                          GAMMATHIN, CK, ARMDRESP,
+     >                          ACONTTEST, ALINETEST,
+     >                          ALINEMDRESP, ACONTMDRESP
+      REAL, DIMENSION(MAXATOM, NDDIM) :: OPAKELEM, OPAKOLDELEM, 
+     >                                   OPACELEM, OPACOLDELEM, 
+     >                                   ETAKELEM, ETAKOLDELEM, 
+     >                                   ETACELEM, ETACOLDELEM, 
+     >                                   ARADELEM, ACONTELEM,
+     >                                   OPAROSSELEM, OPATOTELEM
+      REAL, DIMENSION(NDDIM, MAXATOM, MAXION) :: OPAKION, OPAKOLDION,
+     >                                           OPACION, OPACOLDION,
+     >                                           ETAKION, ETAKOLDION,
+     >                                           ETACION, ETACOLDION,
+     >                                           ARADION, ACONTION
+
+      INTEGER :: iTypeAlpha, LPRDH
+      REAL :: PARALAS, VINF, VELOMODFAK, DOTM4P, 
+     >        XMG, XMSTAR, GAMMAPOWR, ACONTTOT, ACONTTESTTOT
 
 C***  Operating system:
       COMMON / COMOS / OPSYS
@@ -336,7 +385,13 @@
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
       INTEGER, PARAMETER :: hPLOT = 2       !write to plot file
-      INTEGER, PARAMETER :: hHIST = 21      !write to MODHIST file
+      INTEGER, PARAMETER :: hMODEL = 3      !integer handle of the MODEL file (fort.3)
+      INTEGER, PARAMETER :: hDMFILE = 16    !integer handle of the DMFILE file
+      INTEGER, PARAMETER :: hEDDI = 17      !integer handle of the EDDI file (fort.17)
+      INTEGER, PARAMETER :: hFEDAT = 21     !integer handle of the FEDAT file (fort.21)
+      INTEGER, PARAMETER :: hHIST = 22      !write to MODHIST file
+      INTEGER, PARAMETER :: hALO = 23       !integer handle of the ALO file -- added July 2023
+      INTEGER, PARAMETER :: hFF = 27        !integer handle for FFASSET
 
       REAL, EXTERNAL :: BNUE
       INTEGER, EXTERNAL :: IDX
@@ -354,12 +409,14 @@
       bKATEST = .TRUE.      !Test run (0.9*v, 0.9*v') first
       bKADONE = .FALSE.     !Test modifications done
       bNewLoop = .FALSE.    !default value for multiple coli runs
+      bWARNK = .FALSE.
 
 C***  If no Generic Element (Fe) is accounted for:
       LASTFE = 0 
       
 C***  Entry Point for multiple COLI
  1    CONTINUE
+      bFELASER = .FALSE.
 
       CALL INSTALL
 
@@ -370,20 +427,26 @@
 c        CALL TIME(TIM1)
 c      ENDIF
 
-      CALL COLI_SETZERO(ND, NDDIM, NIT, NPDIM, NFDIM, MAXFEIND, MAXLIN,
+      CALL COLI_SETZERO(ND, NDDIM, NIT, NPDIM, NFDIM, MAXATOM, MAXFEIND,
+     >                  MAXLIN, MAXIND, MAXION,
      >             DBDTINT, DBDTOPAINT, EDDIHOUTJMEAN, 
-     >             HTOTOUTMINUS, HTOTND, HTOTNDCOR,
-     >             DBDTINT_M, DBDTOPAINT_M,
+     >             HTOTOUTMINUS, DBDTINT_M, DBDTOPAINT_M,
 C***  with ND
      >             OPA, ETA,
      >             XJTOTL, HTOTL, XKTOTL, XNTOTL, ARAD, ACONT, ATHOM,
-     >             FTCOLI, OPAKOLD, ETAKOLD, OPAKNOTHO, ETAKNOTHO, 
-     >             OPAO, THOMSONO, ETANOTHO, DJDSMO_OLD, DJDOMO_OLD,
+     >             FTCOLI, FTCOLIB, OPAKOLD, ETAKOLD, OPAKNOTHO, 
+     >             ETAKNOTHO, OPAO, THOMSONO, ETANOTHO, 
+     >             DJDSMOD_OLD, 
      >             OPASMEAN, QFJMEAN, OPAJMEAN, OPASMEANTC, OPAJMEANTC,
      >             OPAPMEAN, SMEAN, QLFOLD, EPSGMAX, OPAROSS, 
      >             OPALAMBDAMEAN,
+     >             OPAROSSELEM, OPAROSSCONT, 
+     >             OPAKFEOLD, iIgnoreK, OPAKFEFTOLD, ETAKFEFTOLD,
+     >             OPAKNOFENOTHO, ETAKNOFENOTHO, 
+     >             bOSKIPLAST, XLAMLASTOSKIP, XJLMO, XJLMOR2,
 C***  with ND-1
      >             QOPAHMEAN, HMEAN, QLHOLD, OPAKHOLD,
+     >             HTOTLTEST, HTOTCUT,
 C***  with NDDIM,NIT
      >             XJLOLD, XJLMO_OLD, EDDIFO, S_OLD, OPAK_OLD, EPSG,
 C***  with NDDIM,NPDIM
@@ -396,13 +459,27 @@
      >             XHLOLD, XHLMO_OLD, EDDIGO,
 C***  with MAXFEIND, NDDIM
      >             XJFEMEAN, FERATLU, FERATUL, FTFE, WFELOW, WFENUP,
+C***  with MAXATOM,ND
+     >             OPAKELEM, OPAKOLDELEM, OPACELEM, OPACOLDELEM,
+     >             ETAKELEM, ETAKOLDELEM, ETACELEM, ETACOLDELEM,
+     >             OPATOTELEM,
+C***  with MAXATOM,ND-1
+     >             ARADELEM, ACONTELEM,
+C***  with ND, MAXATOM, MAXION
+     >             OPAKION, OPAKOLDION, OPACION, OPACOLDION,
+     >             ETAKION, ETAKOLDION, ETACION, ETACOLDION,
+C***  with ND-1, MAXATOM, MAXION
+     >             ARADION, ACONTION,
 C***  with MAXLIN
-     >             LIND, LINDS, WS, 
+     >             LIND, LINDS, 
+C***  with NDDIM, MAXLIN     
+     >             WS, 
 C***  with MAXIND  
-     >             MAXIND, BLASERL, 
+     >             BLASERL, 
 C***  with NFDIM 
      >             EMCOLI, 
 C***  no Arrays
+     >             HTOTMINUSND, HTOTND, HTOTNDS, HTOTNDCOR,
      >             OPAMAX1, OPAMAX1_LAMBDA, IOPAMAX1_K)
 
 
@@ -445,53 +522,86 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
       LASTINDAUTO = LASTIND + NAUTO
       LASTINDALL  = LASTIND + NAUTO + LASTFE
 
 C***  READ THE MODEL FILE
       CALL       RMODCOLI (RADIUS,ENTOT,RNE,T,VELO,GRADI,XLAMBDA, 
-     >                   FWEIGHT,
-     $                   POPNUM,RSTAR,VDOP,MODHEAD,JOBNUM,XJC,
-     $                   P,ND,NDDIM,NF,NFDIM,N,NP,NPDIM,Z,
-     $                   TEFF,HEDDI,EDDI,MODHIST,MAXHIST, 
+     >                     FWEIGHT, POPNUM, POPMIN,
+     >                     RSTAR, VDOP, MODHEAD, JOBNUM, XJC,
+     >                     P,ND,NDDIM,NF,NFDIM,N,NDIM,NP,NPDIM,Z,
+     >                     TEFF,HWRCEDDI,EDDI,MODHIST,MAXHIST, 
      >                   DENSCON, FILLFAC, ABXYZ, NATOM, 
-     >                   NCOLIP, NF2, XLAMBDA2, 
-     >                   OPARND, EPSGMAX, BEPSGMAXERR, MAXXDAT, XDATA,
-     >                   NEXTHYDRO, ZERO_RATES, NDIM, DTDRIN)
+     >                     LASTREDISMODE, NCOLIP, NF2, XLAMBDA2, 
+     >                     OPARND, EPSGMAX, BEPSGMAXERR, MAXXDAT, 
+     >                     XDATA,XMSTAR, ZERO_RATES, HTOTMINUSND, 
+     >                     HTOTNDCOR, HTOTLlast, TAULAST, 
+     >                     NEXTHYDRO, DTDRIN, VMIC)
       WRITE(hCPR,'(A,I7)') '>>> This is job number ', JOBNUM
+      XMG = GCONST * XMSTAR * XMSUN
+
+C***  ALOs are only used in the next STEAL, so always create new ALO file
+      CALL OPENEXMS (hALO, IDUMMY, IDUMMY, 'ALO', 'REPLACE', IERR)
 
-      CALL POPMIN_NULLING (ZERO_RATES, POPNUM, ND, N)
+C***  Set popnumbers at POPMIN to zero to avoid any effect on the
+C***  radiative transfer calculations:
+      CALL POPMIN_NULLING(ZERO_RATES, POPNUM, POPMIN, ND, N)
 
       !Determine if force multipliers are calculated
       ! this is either done if the next STEAL job 
       ! performs a hydro calculation (NEXTHYDRO = 1) or if
       ! forced by the special CARDS option FORCEMULTIPLIERS
       bKALPHA = .FALSE.
-      VELOMODFAK = 0.9          !default value for velocity field modification factor
+      IF (NEXTHYDRO == -13) THEN
+        bKALPHA = .TRUE.        !alpha calulation for converged model
+      ENDIF
 
 C***  DECODE INPUT CARDS
       CALL DECCOLI (LSOPA, LSINT, MODHIST,
-     >       LPOPAB, LPOPABD, LEVDEBUG, LPJNUE,
+     >       NOLAP, LPOPAB, LPOPABD, LEVDEBUG, LPJNUE,
      >       LPJNUED, LASERV, PARALAS, LPSNUE, LPSNUED,
-     $       MAXPLOT, RANGE1, RANGE2, EXLAM1, EXLAM2, MAXEXT, BLLIST,
-     >       NEWWRC, BCOLIRAY, CLHLP, BITCONT, BPLOT, 
-     >       IPLOT, LPLOT, ND, OPC, IVERS, BEMIX, EMIXSTART,
-     >       EMIXMAX, BEMIXFIX, EMIXFIX, IVERS_FE_EXPFAC, BPLOTALPHA,
-     >       XLAM_FINE_START, XLAM_FINE_END, LPLOT_WCHARM, 
-     >       XLP1, XLP2, GAMMACOLI, GAMMAT, UNLU_TAUMAX,
-     >       UNLU_TAUMAX2, bKALPHA, bHYDROSOLVE, VELOMODFAK,
-     >       bForceCOLIP, bTDIFFUS, DRLINES_CARD)
+     $       MAXPLOT, RANGE1, RANGE2, EXLAM1, EXLAM2, MAXEXT,
+     $       BLLIST,
+     >       REDISMODE, NEWWRC, BCOLIRAY, BKUDRITZKI,
+     >       CLHLP, BITCONT, BPLOT,  
+     >       IPLOT, LPLOT, ND, OPC,
+     >       IVERS, BEMIX, EMIXSTART, BEMIXFIX, EMIXFIX, 
+     >       IVERS_FE_EXPFAC, BPLOTALPHA, ALPOPT, POPMIN,
+     >       XLAM_FINE_START, XLAM_FINE_END, LPLOT_WCHARM, XLP1,
+     >       XLP2, GAMMACOLI, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2, 
+     >       bKALPHA, bHYDROSOLVE, VELOMODFAK, iTypeAlpha, 
+     >       bForceCOLIP, bTDIFFUS, bPLOTRTAU1, bNoIronLaser, 
+     >       iHTOTCUT, bMAXEMIX, bALOTri,
+     >       bNoNEGEDDIG, bDDVDOP, LPRDH,
+     >       bDEBUG, CUTOPAMEANTHRES, DRLINES_CARD)
 
       DO LINEINDEX = 1, LASTIND+NAUTO
          LINE(LINEINDEX) = LINEINDEX
       ENDDO
 
+C***  Setup VDOPDD array (for line profiles) and VDOPUNIT (grid spacing) variable      
+      VDOPUNIT = VDOP
+      CALL VDOPDD_SETUP(bDDVDOP, VDOPDD, VDOPUNIT, DXMAX,
+     >                  T, VMIC, ATMASS, ND, NATOM)    
+     
       IF ((.NOT. bKALPHA) 
      >      .AND. (bHYDROSOLVE) .AND. (NEXTHYDRO == 1)) THEN
         bKALPHA = .TRUE.
       ENDIF
+      bAdjVINF = .FALSE.
+      IF (VELOMODFAK < 0.) THEN
+        VELOMODFAK = -1. * VELOMODFAK
+        bAdjVINF = .TRUE.
+      ENDIF
+      IF (iTypeAlpha == 0) THEN
+        !Switch off alpha/response calculation if not used in HYDRO step 
+        bKALPHA = .FALSE.
+      ELSE
+        WRITE (hCPR,*) ' Requested Alpha-Type', iTypeAlpha
+      ENDIF
+      
 
 C***  Open special Plot file wcharm.dat
       IF (LPLOT_WCHARM .GT. 0) THEN
@@ -506,6 +616,7 @@
       EXLAM1 = XLAMBDA(1)
       EXLAM2 = XLAMBDA(NF)
 
+      REDISMODED = REDISMODE
 
 C***  prepare the rudimental settings for DRTRANSIT lines
       IF (NAUTO > 0) THEN
@@ -550,12 +661,23 @@
       BWEXBLU = 1.5
 
       !Fixed value for VINF (even if velocity field is modified later)
-      VINF = VELO(1)/VDOP
+      VINF = VELO(1)/VDOPUNIT
+
+C***  IRON: WIDTH OF RED LINE WING IN IRON-DELTAX-UNITS
+C      IF (BFEMODEL) THEN
+C         DFEINDR = 2.*VELO(1)/VDOPFE/DXFE
+C      ENDIF
+
+      ATMEAN = 0.
+      DO NA=1, NATOM
+        ATMEAN = ATMEAN + ABXYZ(NA) * ATMASS(NA)
+      ENDDO
 
 C***  INTRODUCING DIMENSIONLESS VELOCITY UNITS : 
       DO L=1,ND
-        VELO(L)=VELO(L)/VDOP
-        GRADI(L)=GRADI(L)/VDOP
+        VELO(L)=VELO(L)/VDOPUNIT
+        GRADI(L)=GRADI(L)/VDOPUNIT
+        RHO(L) = AMU*ATMEAN*ENTOT(L)
       ENDDO
  
 C***  MASS STORAGE ON FILE 7 FOR THE FEAUTRIER MATRICES (WRCONT)
@@ -579,15 +701,13 @@
 C***  INITIALIZE XJLLOAD
       LACTION = 'LOAD'
 
-C***  Channel for the file EDDI
-      NCHANE = 17
-
 C***  Dimension for EDDIA
 C***    Note : XHI and XHO are also stored 
 C***           XHI for the inner boundary in COLIMO
 C***           XHO for Unsoeld-Lucy
 C***           XHOM and EDDIHOUTP for special treatment of the outer boundary
-      NDEDDIA = 2*ND + 3 + 2 + 4
+C***           EDDIHINM for calculation of HTOTMINUSND (needed for innermost temperature correction)
+      NDEDDIA = 2*ND + 3 + 2 + 4 + 2
 
 C***  Counter for Number of EDDI Resets in COLIMO
       IW_COLIMO_F      = 0
@@ -628,8 +748,10 @@
         ! CLOPENE also updates MODEL string in EDDI file, but the MODEL
         ! is always the same in multiple COLI runs, so this should not be a problem
         BCLEERR = .FALSE.
-        CALL CLOPENE (NCHANE, MODHEAD, JOBNUM, 
+        CALL CLOPENE (hEDDI, MODHEAD, JOBNUM, 
      >                NCOLIP, NDEDDIA, BCLEERR)
+        WRITE (hCPR,*) 'Opening EDDI file...'
+C***    Open ALO file
       ENDIF
       
 C***  Determine type of COLI (normal COLI, COLI+, or COLI++)
@@ -666,20 +788,46 @@
 
 C***  VELOCITY SCALING FOR THE CALCULATION OF FORCE MULTIPLIERS
       IF (bKALPHA .AND. bKATEST) THEN
-         WRITE (hCPR,'(A)') ' *************************************'
-         WRITE (hCPR,'(A)') ' * CALCULATION OF FORCE MULTIPLIERS: *'
-         WRITE (hCPR,'(A,2X,F6.3,X,A)') ' * VELOCITY IS MODIFIED BY ',
-     >                           VELOMODFAK, ' *'
-         WRITE (hCPR,'(A)') ' *************************************'
-         IF (VELOMODFAK == 1. .OR. VELOMODFAK <= 0.) THEN
-           WRITE (hCPR,'(2A)') 'FATAL ERROR: Velocity modifier must ',
-     >                         'be greater than zero and may not be 1!'
-           STOP 'Fatal ERROR in Subr. COLI'
+         IF (iTypeAlpha == 3) THEN
+           CATMOD = ' DENSITY'
+         ELSEIF (iTypeAlpha /= 11) THEN
+           CATMOD = 'GRADIENT'
+         ELSE
+           CATMOD = 'VELOCITY'
+         ENDIF
+         WRITE (hCPR,'(A)') 
+     >       ' *********************************************'
+         WRITE (hCPR,'(A)')
+     >       ' * CALCULATION OF FORCE MULTIPLIERS:         *'
+         WRITE (hCPR,'(A,2X,F14.11,X,A)') 
+     >       ' * '// CATMOD //' IS MODIFIED BY ',  VELOMODFAK, ' *'
+         WRITE (hCPR,'(A)')
+     >       ' *********************************************'
+         IF ((iTypeAlpha /= 3) .AND. 
+     >         (VELOMODFAK > 1. .OR. VELOMODFAK <= 0.)) THEN
+c           WRITE (hCPR,'(2A)') 'FATAL ERROR: Velocity modifier must ',
+c     >              'be greater than zero and lower than 1!'
+c           STOP 'Fatal ERROR in Subr. COLI'
+         ELSEIF (VELOMODFAK == 1.) THEN
+           WRITE (hCPR,'(2A)') '**WARNING** GRADIENT is not modified!'
          ENDIF
          DO L=1, ND
+            IF (iTypeAlpha /= 3) THEN
+              IF (iTypeAlpha /= 12) THEN
             VELO(L)  = VELO(L)  * VELOMODFAK
+              ENDIF
+              IF (iTypeAlpha /= 11) THEN
             GRADI(L) = GRADI(L) * VELOMODFAK
+              ENDIF
+            ENDIF
+            IF (iTypeAlpha == 3 .OR. iTypeAlpha == 31) THEN
+              ENTOT(L) = ENTOT(L) / VELOMODFAK
+            ENDIF
+C            GRADI(L) = GRADI(L)
          ENDDO
+         IF (bAdjVINF) THEN
+           VINF = VELO(1)
+         ENDIF
          bKADONE = .TRUE.
       ELSE
          bKATEST = .FALSE.
@@ -688,14 +836,14 @@
 C***  Reorder lines in sequence of increasing wavelengths
       NLINE = LASTIND + NAUTO
       CALL SEQLINECL(NLINE, LINE, EINST, INDLOW, 
-     >       INDNUP, XLAMSOR, ELEVEL,
-     >       NDIM, VDOP, CMFBAND, CLIGHT, XLAMMIN, XLAMMAX,
-     >       VINF*VDOP, EXLAM1, EXLAM2, MAXEXT, 
+     >       INDNUP, XLAMSOR, ELEVEL, NDIM, VDOPUNIT,
+     >       CMFBAND, CLIGHT, XLAMMIN, XLAMMAX,
+     >       VINF*VDOPUNIT, EXLAM1, EXLAM2, MAXEXT, 
      >       LASTIND, NAUTO, KRUDAUT )
 
 C***  IRON: WIDTH OF RED LINE WING IN IRON-DELTAX-UNITS
       IF (BFEMODEL) THEN
-         DFEINDR = 2.*VINF*VDOP/VDOPFE/DXFE
+         DFEINDR = 2.*VINF*VDOPUNIT/VDOPFE/DXFE
       ENDIF
      
       IF (BCOLIRAY) THEN
@@ -739,6 +887,8 @@
 C***     Note: Modification by wrh 17-Aug-2000 12:12:25 
 C***           EMIXFIX is considered as minimum value, but EPSGMAX is applied  
 C***           if neccessary  
+      EPSGITMAX(1) = 0.
+
       DO IT=2, ITMAX
         DO L=1, ND-1     
           IF (.NOT. BEMIX) THEN
@@ -746,7 +896,6 @@
           ELSE
             IF (BEMIXFIX) THEN
               EPSG(L,IT) = AMAX1 (EMIXFIX, EPSGMAX(L)) 
-              IF (EMIXMAX .GT. .0) EPSG(L,IT)=AMIN1(EPSG(L,IT),EMIXMAX)
             ELSE
               IF (BEPSGMAXERR) THEN 
                 EPSG(L,IT) = EMIXSTART
@@ -755,16 +904,23 @@
               ENDIF
             ENDIF
           ENDIF
+          EPSGITMAX(IT) = MAX(EPSGITMAX(IT), EPSG(L,IT))
         ENDDO
+        IF (bMAXEMIX) THEN
+C***      New test option: Apply the maximum required EDDIMIX to ALL depth points        
+          DO L=1, ND-1
+            EPSG(L,IT) = EPSGITMAX(IT)
+          ENDDO
+        ENDIF
       ENDDO
 
       EPSGMAX = 0.  !needed for multiple call of COLI (from Goetz)  
 
 C***  Initialize Counters for reading and writing the EDDIEs to 
-C***    File fort.<NCHANE>
+C***    File fort.<hEDDI>
 C***  EDDIA : Array where all eddis are stored
 C***          NFRO frequencies are stored in one entry in the file
-C***  NZE1 : is part of the Name of the arrays in fort.<NCHANE>
+C***  NZE1 : is part of the Name of the arrays in fort.<hEDDI>
 C***  NZE2 : is the actual Index in the array EDDIA
       NZE1 = 0
       NZE2 = 0
@@ -776,8 +932,8 @@
 C***     and TDIFFUS artistic is not switched on
         DTDR = DTDRIN
       ELSE
-        CALL DIFDTDR (DTDR,TEFF,XJC,HEDDI,T(ND),
-     >                RADIUS(ND),ND,EN,POPNUM,RNE(ND),ENTOT(ND),RSTAR,
+        CALL DIFDTDR (DTDR,TEFF,XJC,HWRCEDDI,T(ND),RADIUS(ND),
+     >                ND,EN,POPNUM,POPMIN,RNE(ND),ENTOT(ND),RSTAR,
      >                NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
      >                ALPHA,SEXPO,
      >                ADDCON1, ADDCON2, ADDCON3, 
@@ -803,6 +959,7 @@
       NBLENDS=0
 
 C**** IWARNJMNEG = Counter for negative XJL values obtained in COLIMO
+C****  (Such values are now [Apr 2015] set to zero! )
       IWARNJMNEG = 0
 
 C******************************************************************
@@ -897,7 +1054,6 @@
       CALL GENWP1 (NP, P, WP1, WP1LAST)
       CALL COLIWM(Z, P, RADIUS, ND, NP, 
      >            CWM0, CWM1, CWM2, CWM3, 
-     >            CWM1O, CWM1I, CWM3O, CWM3I, 
      >            BSHORT_CHAR)
 
 C***  The weights could be checked 
@@ -916,7 +1072,7 @@
 
       CALL PREPK(
 C***  Input
-     >    XLAMBDA, NF, XLAMBDA2, NF2, VDOP, CLIGHT, DXMAX,
+     >    XLAMBDA, NF, XLAMBDA2, NF2, VDOPUNIT, CLIGHT, DXMAX,
      >    VINF, ND, CMFBAND, NLINE, MAXIND, XLAMSOR,
      >    BPLOT, BXJCE, LINE, 
 C***  Output 
@@ -935,13 +1091,13 @@
         CPPLABEL = '  '
       ENDIF
       WRITE (hCPR,*)
-      WRITE (hCPR,'(14A8)')
+      WRITE (hCPR,'(13A8)')
      >  'COLI+', 'BCLEERR', 'EDDIMIX', 
-     >  'OB-VERS', 'KSPACE', 'BXJCE',
+     >  'TDIFFUS', 'OB-VERS', 'KSPACE', 'BXJCE',
      >  'BPLOT', 'BPLOT2', 'BSHORT', 'CLHLP', 'VERS_FE'
-      WRITE (hCPR,'(L6,A2,L6,1L8,2I8,5L8,I7)')
+      WRITE (hCPR,'(L6,A2,L5,3L8,2I8,5L8,I7)')
      >  BCOLIP, CPPLABEL, BCLEERR, BEMIX, 
-     >  IVERS, KSPACE, BXJCE,
+     >  bTDIFFUS, IVERS, KSPACE, BXJCE,
      >  BPLOT, BPLOT2, BSHORT, CLHLP, IVERS_FE_EXPFAC
       WRITE (hCPR,*)
 
@@ -976,6 +1132,7 @@
       BFECHECK    = .FALSE.
       BFEWING     = .FALSE.
 
+      HTOTNDCOR = 0.
 
 C*****************************************************
 C***  Main-loop over all frequency-indices
@@ -1029,11 +1186,18 @@
      >             LINECHECK, ILINECHECK, NLINE, MAXLIN, LEVEL, 
      >             LIND, LINDS, WS, BPLOT, RADIUS, NLACT, LINE, 
 C***  Parameters for PRELINECL
-     >             NUP, LOW, N, XLAM, NDIM, ND, XJLMEAN, ELEVEL,
-     >             INDNUP, INDLOW, NDDIM,
+     >             NUP, LOW, N, XLAM, NDIM, ND, XJLMEAN, XLAMAPPMEAN,
+     >             bALOTri, XLAMAPPUMEAN, XLAMAPPLMEAN,
+     >             ELEVEL, INDNUP, INDLOW, NDDIM,
 C***  Parameters and also for LIOP 
      >             EINST, WEIGHT, XLAMSOR, ENTOT, POPNUM, RSTAR,
-     >             OPAL, ETAL, VDOP)
+     >             OPAL, ETAL, VDOPUNIT, hMODEL, hALO)
+
+CC***  Output of K
+C        IF (K .GT. KOUT) THEN
+C          WRITE (hCPR,'(A,I7,1X,I7,1X,F15.3)') 'K=', K, NK, XLAMK
+C          KOUT = KOUT + 20000
+C       ENDIF
 
 C***  Force the writing of XJ and ED Arrays
       IF (FLOAT(K+1) .GT. XKCMAX) THEN
@@ -1086,21 +1250,25 @@
         IFF_N = IFF_N + 1
         IF (IFF_N .GT. IFF_MAX) THEN
           WRITE (hCPR,*) 'Number of fine frequencies for ',
-     >                'Integration in STEAL exceeded'
+     >                'Integration in COLI exceeded'
           WRITE (hCPR,'(A,I8)') 'Present IFF_MAX = ', IFF_MAX
           STOP 'ERROR in Subr. COLI'
         ENDIF
       ENDIF
 
-C***  Read old EDDIEs from file fort.<NCHANE>
-      CALL CLLOADE (NCHANE, NZE1, NZE2, NFRO, EDDIA, NDEDDIA,
+C***  Read old EDDIEs from file fort.<hEDDI>
+      CALL CLLOADE (hEDDI, NZE1, NZE2, NFRO, EDDIA, NDEDDIA,
      >              EDDIF, EDDIG, ND,
-     >              EDDIHOUT, EDDIHIN, EDDINOUT, EDDININ,
+     >              EDDIHOUT, EDDIHIN, EDDIHINM, EDDINOUT, EDDININ,
      >              BCLEERR, BCOLIP, XHI, XHO, EPSG(1,1), 
-     >              XHOM, XNOM, EDDIHOUTP, EDDINOUTP)
+     >              XHOM, XNOM, EDDIHOUTP, EDDINOUTP, EDDIHINT)
 
 C***  Overview on current EPSG
       IF (K .EQ. 0 .AND. BCOLIP) THEN
+        IF (BEPSGMAXERR .AND. BEMIX) THEN 
+          WRITE (hCPR, '(A,F5.2)') 
+     >        'COLI: EDDIMIX started with EPSG=', EMIXSTART
+        ENDIF
         CALL PRI_EPSG(BEMIX, BEMIXFIX, ITMAX, EPSG, NDDIM, ND, NIT,
      >                JOBNUM)
       ENDIF
@@ -1112,20 +1280,28 @@
      >         SIGMA1I,KONTLOW,KONTNUP,LASTKON,NATOM,KONTHLP,
      >         DENSCON,BPLOT,BPLOT2,IPLOT,K,KCL,KCU,KCDELTA,
      >         OPACL,OPACU,ETACL,ETACU,XLAM0LN,ALN, MAXXDAT, XDATA, 
-     >         SIGMATHK,SEXPOK,EDGEK, MAXATOM, NOM, KODAT, RADIUS)
+     >         SIGMATHK,SEXPOK,EDGEK, MAXATOM, NOM, KODAT, RADIUS,
+     >         MAINPRO, MAINLEV, IWARN, OPACLEL, OPACUEL, OPACELEM,
+     >         ETACLEL, ETACUEL, ETACELEM, OPACLION, OPACUION,
+     >         OPACION, ETACLION, ETACUION, ETACION,
+     >         OPALEL, ETALEL, OPALION, ETALION)
 
 C***  IRON: CALCULATE FE-OPACITY AND EMISSIVITY
         IF (BFECHECK) THEN
            CALL  CMFFEOP (XLAMK, ND, N, INDFEACT, MAXFEACT, LASTFE,
-     >                    SIGMAFE, OPAFE, ETAFE, INDRB,
+     >                    SIGMAFE, OPAFE, ETAFE, INDEXMAX, INDRB,
      >                    IFRBSTA, IFRBEND, IFENUP, IFELOW,
-     >                    CLIGHT, VDOPFE, DXFE, XLAM0FE, ELEVEL,
-     >                    WEIGHT, RSTAR, POPNUM, ENTOT, SIGMAACT,
-     >                    OPAFEI, ETAFEI, T, IVERS_FE_EXPFAC, TEFF)
+     >                    CLIGHT, VDOPFE, DXFE, XLAM0FE, 
+     >                    ELEVEL, WEIGHT, RSTAR, POPNUM, ENTOT, 
+     >                    SIGMAACT, OPAFEI, ETAFEI, 
+     >                    OPAFEION, ETAFEION, T, IVERS_FE_EXPFAC, 
+     >                    TEFF, NCHARG, MAXION, bFELASER, bNoIronLaser)
         ENDIF
 
+C***  ---------------------------------------------------------
 C***  ADD THE THOMSON EMISSIVITY, ACCORDING TO THE ACTIVE MODE:
 C***  Note: CMFCOOP has stored the true emissivity into ETANOTH
+C***  ---------------------------------------------------------
 C***  Using the Continuum Radiation Field
       IF (BCOLIPP) THEN
         DO L=1, ND
@@ -1133,14 +1309,13 @@
         ENDDO
       ENDIF
 
-
         LASER = .FALSE.
 
 C***  Calculate frequency Step in X
 C        DELTAX = FLOAT(K-KLAST) * DXMAX
         NDK = K - KLAST
         IF (NDK .NE. 1) THEN
-           DELTAX = (EXP(FLOAT(NDK)*ALN) - 1.)*CLIGHT/VDOP
+           DELTAX = (EXP(FLOAT(NDK)*ALN) - 1.)*CLIGHT/VDOPUNIT
         ELSE
            DELTAX = DXMAX
         ENDIF
@@ -1154,15 +1329,19 @@
           IFF_DK(IFF_N) = NDK - 100
         ENDIF
 
-        FWEIGHTL = DELTAX * VDOP * 1.E13 / XLAMK
+        FWEIGHTL = DELTAX * VDOPUNIT * 1.E13 / XLAMK
 C***  Sum up Opacities
         CALL ADDOPA (ND, NDDIM, MAXLIN, MAXIND, LIND, LINDS, 
-     >         XK, XKMID, XKRED, DELTAX, 
-     >         PARALAS, LASER,
+     >         XK, XKMID, XKRED, DELTAX, FWEIGHTL,
+     >         PARALAS, LASER, LASERV, ALN, VDOPUNIT, VDOPDD,
      >         WS, ETAL, OPAL, ETA, ETANOTH, OPA, ETAK, ETAKNOTH, 
-     >         OPAK, OPAKNOTH, THOMSON, 
-     >         PWEIGHT, OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW,
-     >         N, LEVEL)
+     >         OPAK, OPAKNOTH, THOMSON, PWEIGHT, NOM,
+     >         OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW, N, LEVEL, 
+     >         OPAKFE, NATOM, MAXATOM, KODAT, OPACELEM, OPAKELEM,     
+     >         ETACELEM, ETAKELEM, MAXION, OPACION, OPAKION,
+     >         ETACION, ETAKION, NCHARG, OPAFEION, ETAFEION, 
+     >         OPAKNOFENOTH, ETAKNOFENOTH, 
+     >         OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT)
 
         IF (LASER) THEN
           NLASER=NLASER+1
@@ -1181,9 +1360,11 @@
               IF (XJLMOR2(L) .GT. 1.E-100) THEN
                  ETAK(L) = ETAKNOTH(L) 
      >                     + (OPAK(L) - OPAKNOTH(L)) * XJLMOR2(L)
+              ELSEIF (XJCIND(L) > 1.E-50) THEN
+                 ETAK(L) = ETAKNOTH(L)
+     >                     + (OPAK(L) - OPAKNOTH(L)) * XJCIND(L)  
               ELSE
                  ETAK(L) = ETAKNOTH(L)
-c     >                     + (OPAK(L) - OPAKNOTH(L)) * XJCIND(L)  
               ENDIF
            ENDDO
         ELSE
@@ -1205,7 +1386,6 @@
 
         ITACT = IT
 
-
 C***   Beginning of COLIRAY-Block
         IF (IT .GT. 1) THEN
           IF ( K .EQ. 0) THEN
@@ -1216,7 +1396,6 @@
      >                         XHO, XHI, XNO, XNI,
      >                         XHOM, XHOP, XNOM, XNOP)
 
-
 C***  Begin of SHORTRAY Block
 C***  Loop over the impact parameters
             DO JP=1, NP
@@ -1232,7 +1411,7 @@
      >          XHO, XHI, XNO, XNI,
      >          Z(IRAY,1), PPP(IRAY,1), 
      >          IPLOT, BPLOT2, IW_COLIRAY_IPLUS, IVERS, 
-     >          XHOM, XHOP, XNOM, XNOP, OPA)
+     >          XHOM, XHOP, XNOM, XNOP, OPA, bWARNK)
             ENDDO
 C***  For special integration in coliray needed
 C!!!          XHI = XHI + BCORE/2. + DBDR/OPAK(ND)/3.
@@ -1265,12 +1444,6 @@
               IF (XJL(L) .GT. 0.) THEN
                 EDDIF(L) = XKL(L) / XJL(L)
 
-C*** testoutput: woher kommen die eddif-resets???
-c              if (eddif(l) .lt. 0.0 .or. eddif(l) .gt.1.) then
-c                 write (hCPR,'(A,2I6,4G14.4)') 'K, L, XLAMK, EDDIF, J, K',  
-c     >           K, L, XLAMK, EDDIF(L), XJL(L), XKL(L)
-c              endif
-
               ELSE
                 EDDIF(L) = 1.
               ENDIF
@@ -1279,10 +1452,20 @@
               XHL_MID = XHL(L) + XHL(L+1)
               XJL_MID = XJL(L) + XJL(L+1)
               XNENN = XHL_MID + EPSG(L,IT)*XJL_MID
-              IF (ABS(XNENN) .GT. 1.E-300) then
+              
+              IF (ABS(XNENN) .GT. EXP(-499.D0)) THEN
                 EDDIG(L) = XNL_MID / XNENN
+                 
+C***            CARDS option: Reset all negative EDDIG to
+C***                          ensure proper momentum equation form
+                IF (bNoNEGEDDIG .AND. EDDIG(L) < 0.) THEN
+                  EDDIG(L) = 1. / (1. + EPSG(L,IT)) 
+                ENDIF
+                
               ELSE
-                EDDIG(L) = 1.
+c***            Changed the fallback to 1 / (1+eps) -- ansander, Aug 2023
+c                EDDIG(L) = 1.
+                EDDIG(L) = 1. / (1. + EPSG(L,IT))              
               ENDIF
             ENDDO
 C***  Calcultate the Eddis (EDDIH and EDDIN)
@@ -1314,61 +1497,81 @@
           IF ( K .EQ. 0) THEN
             WRITE (hCPR,'(A,I2)') 'COLIMO,  IT=', IT
           ENDIF
-          CALL COLIMO(K, ND, RADIUS, OPAK, ETAK, ETAKNOTH, 
+C*** ISU unused variable
+C         CALL COLIMO(K, ND, RADIUS, OPAK, ETAK, ETAKNOTH, 
+          CALL COLIMO(K, ND, RADIUS, OPAK, ETAKNOTH, 
      >              OPAKNOTH, 
-     >              S, XJLMO, XJLMOR2, XHLMO,
+C    >              S, XJLMO, XJLMOR2, XHLMO,
+     >              XJLMO, XJLMOR2, XHLMO,
      >              XJLMO_OLD(1,ITACT), XHLMO_OLD(1,ITACT), 
      >              DLF, DLH, GLF, GLH, VLF, VLH,
      >              GLF2, GLH2, VLF2, VLH2, 
      >              QLF, QLH, OPAKH,
      >              EDDIF, EDDIFO(1,ITACT), EDDIG, EDDIGO(1,ITACT), 
-     >              EDDIHOUT, EDDIHIN, EDDIHOUTO(ITACT), 
-     >              EDDINOUT, EDDININ, EDDINOUTO(ITACT), 
+C    >              EDDIHOUT, EDDIHIN, EDDIHOUTO(ITACT), 
+     >              EDDIHOUT, EDDIHIN,
+C    >              EDDINOUT, EDDININ, EDDINOUTO(ITACT), 
      >              ALH, BLH, CLH,
      >              COLIA, COLIB, COLIC, COLIW, DELTAX, 
-     >              BCORE, DBDR, XIMINUS, BPDONE, XLAMK,
-     >              DJDSMO, DJDOMO,
+C    >              BCORE, DBDR, XIMINUS, BPDONE, XLAMK,
+     >              BCORE, XLAMK,
+     >              DJDSMOD, bALOTri, DJDSMOU, DJDSMOL,
      >              FULFIL0, FULFIL1, BPLOT, BPLOT2, IPLOT, 
      >              IW_COLIMO_F, IW_COLIMO_G, IW_COLIMO_G2, BSTATIC, 
      >              CLMOETA, CLMOOPA, XHID, 
      >              RADIUS2, EPSG(1,ITACT), GEPSB, GEPSBO,  
-     >              XHOM, XHOMO(ITACT), XNOM, XNOMO(ITACT),
-     >              EDDIHOUTP, EDDINOUTP, 
-     >              EDDIHOUTOP(ITACT), EDDINOUTOP(ITACT), IWARNJMNEG)
+C    >              XHOM, XHOMO(ITACT), XNOM, XNOMO(ITACT),
+C    >              EDDIHOUTP, EDDINOUTP, 
+C    >              EDDIHOUTOP(ITACT), EDDINOUTOP(ITACT), IWARNJMNEG)
+     >              IWARNJMNEG)
 
 ***    Calculate Integrals over Frequency
           IF (IT .EQ. ITMAX) THEN
+          
+            IF (bPLOTRTAU1) THEN
+              CALL PLOTRTAU1COLI (hPLOT, K, XLAMK, XLAMKOLD, CMODE, 
+     >                            ND, RADIUS, OPAK, OPA, FILLFAC, 
+     >                            MAINPRO, MAINLEV, MODHEAD)
+            ENDIF
+          
             IF ( K .EQ. 0) THEN
               WRITE (hCPR,'(A,I2)') 
      >          'Frequency Integration always from COLIMO'
             ENDIF
             CALL FREQUINT (K, FWEIGHTL, XLAMK, XLAMKOLD,
-     >               XLAMBDA,
+     >               XLAMBDA, DXMAX, VELO, GRADI,
 C***        Take J and H from COLIMO
      >               XJLMO, XJLMO_OLD(1,ITMAX), 
      >               XHLMO, XHLMO_OLD(1,ITMAX),
-     >               OPAKOLD, NF, ND, NDDIM,
+     >               OPAKOLD, NF, ND, NDDIM, NATOM,
      >               KONTACT, KONTAUP, DFKONT, LIND, PWEIGHT, MAXLIN,
      >               INDFEACT, SIGMAACT, MAXFEACT, LASTFE,
      >               OPAK, ETAK, OPAFEI, ETAFEI, IFENUP, IFELOW,
 C***                Take Diagonal Weights from COLIMO
-     >               DJDSMO, DJDOMO, DJDSMO_OLD, DJDOMO_OLD,
+     >               DJDSMOD, DJDSMOD_OLD, DJDSraw,
+     >               bALOTri, DJDSMOU, DJDSMOL,
      >               WEIGHT, N, POPNUM,
      >               XKLOLD(1,ITMAX), XNLOLD(1,ITMAX),
      >               OPAKNOTH, ETAKNOTH, OPAKNOTHO, ETAKNOTHO,
      >               EDDIFO(1,ITMAX), EDDIGO(1,ITMAX),
-     >               RADIUS, BCOLIRAY,
+     >               EPSGO(1,ITMAX), RADIUS, BCOLIRAY,
      >               ETANOTH, OPA, THOMSON, T, ETAKOLD,
      >               QLFOLD, QLHOLD, OPAKHOLD, 
-     >               EDDIHOUTOLD, EDDIHINOLD, XHID, FWEIGHT,
-     >               OPAO, THOMSONO,
-     >               SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW, SC, SCO,
+     >               EDDIHOUTOLD, EDDIHINOLD, XHID,
+     >               FWEIGHT, OPAO, THOMSONO,
+     >               OPAKOLDELEM, OPACOLDELEM, ETAKOLDELEM, 
+     >               ETACOLDELEM, OPAKOLDION, OPACOLDION,
+     >               ETAKOLDION, ETACOLDION, OPAFE,
+     >               SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW,
+     >               SUMOPA, SUMOPAW, SUMETA, SUMETAW, SC, SCO,
      >               XJCINT, FWTEST, XJLMEAN, XJFEMEAN, 
-     >               HTOTL, HTOTND, HTOTNDCOR,
-     >               ARAD, ACONT, ATHOM,
-     >               XJTOTL, XKTOTL, XNTOTL, WFELOW, WFENUP, FTCOLI,
-     >               DSDFELOW, DSDFENUP, WJC, WJC_MIN, 
-     >               DSDSC, DJDSC, DJDSCOLD,
+     >               XLAMAPPMEAN, HTOTL,
+     >               HTOTMINUSND, HTOTND, HTOTNDCOR,
+     >               HTOTNDS, ARAD, ACONT, ATHOM, ARADELEM, ACONTELEM, 
+     >               ARADION, ACONTION,
+     >               iIgnoreK, XJTOTL, XKTOTL, XNTOTL, WFELOW, WFENUP, 
+     >               FTCOLI, FTCOLIB, DSDFELOW, DSDFENUP, WJC, WJC_MIN, 
+     >               DSDSC, DJDSC, DJDSCOLD, OPAKINT, ETAKINT,
      >               DBDTINT, DBDTOPAINT, DBDTINT_M, DBDTOPAINT_M,
      >               OPASMEAN, OPASMEANTC, SMEAN, QFJMEAN, OPAJMEAN, 
      >               OPAJMEANTC, OPAPMEAN, QOPAHMEAN, HMEAN, 
@@ -1376,11 +1579,17 @@
      >               RADIUS2, OPC, 
      >               FERATUL, FERATLU, ELEVEL, EMCOLI,
      >               FTFE, IVERS_FE_EXPFAC, LPLOT_WCHARM, GAMMACOLI,
-     >               OPAROSS, OPALAMBDAMEAN, 
+     >               OPAROSS, OPAROSSCONT, OPALAMBDAMEAN, 
      >               GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2, TEFF,
 C*** die folgenden SKALAREN Parameter werden ausgereicht, weil sie sonst
 C*** ueberschrieben werden!!!!???
-     >               XNUEK, XNUEKOLD, XNUEKOLDOLD)
+     >               XNUEK, XNUEKOLD, XNUEKOLDOLD, VDOPUNIT,
+     >               IFRBSTA, IFRBEND, VDOPFE, DXFE, XLAM0FE, NCHARG,
+     >               MAXION, POPMIN, TAULAST, 
+     >               XHLOLD(1,ITMAX), HTOTLTEST, iHTOTCUT, HTOTCUT,
+     >               bOSKIPLAST, XLAMLASTOSKIP, XHBFSKIP, LPRDH, bDEBUG,
+     >               CUTOPAMEANTHRES)     
+     
           ENDIF
 
 C***   Save old Quantities (Dimensioned with NIT) for next Frequency
@@ -1393,6 +1602,7 @@
           EDDIFO(1:ND,IT)      = EDDIF(1:ND)
           XJLMO_OLD(1:ND,IT)   = XJLMO(1:ND)
           EDDIGO(1:ND-1,IT)    = EDDIG(1:ND-1)
+          EPSGO(1:ND-1,IT)     = EPSG(1:ND-1,IT)
           XHLMO_OLD(1:ND-1,IT) = XHLMO(1:ND-1)
           EDDIHOUTO(IT)        = EDDIHOUT
           EDDIHINO(IT)         = EDDIHIN
@@ -1411,18 +1621,33 @@
         XLAMKOLD = XLAMK
         EDDIHOUTOLD = EDDIHOUT
         EDDIHINOLD = EDDIHIN
+        EDDIHINMOLD = EDDIHINM
+        EDDIHINTOLD = EDDIHINT
         OPAKOLD(1:ND)    = OPAK(1:ND)
         ETAKOLD(1:ND)    = ETAK(1:ND)
         OPAKNOTHO(1:ND)  = OPAKNOTH(1:ND)
         ETAKNOTHO(1:ND)  = ETAKNOTH(1:ND)
         QLFOLD(1:ND)     = QLF(1:ND)
-        DJDSMO_OLD(1:ND) = DJDSMO(1:ND)
-        DJDOMO_OLD(1:ND) = DJDOMO(1:ND)
+        DJDSMOD_OLD(1:ND) = DJDSMOD(1:ND)
         ETANOTHO(1:ND)   = ETANOTH(1:ND)
         OPAO(1:ND)       = OPA(1:ND)
         THOMSONO(1:ND)   = THOMSON(1:ND)
         QLHOLD(1:ND-1)   = QLH(1:ND-1)
         OPAKHOLD(1:ND-1) = OPAKH(1:ND-1)
+        OPAKFEOLD(1:ND)   = OPAKFE(1:ND)
+        OPAKFEFTOLD(1:ND) = OPAKFEFT(1:ND)
+        ETAKFEFTOLD(1:ND) = ETAKFEFT(1:ND)
+        OPAKNOFENOTHO(1:ND) = OPAKNOFENOTH(1:ND)
+        ETAKNOFENOTHO(1:ND) = ETAKNOFENOTH(1:ND)
+        CALL FREQUBAK(NATOM, ND, OPAKELEM, OPAKOLDELEM)
+        CALL FREQUBAK(NATOM, ND, OPACELEM, OPACOLDELEM)
+        CALL FREQUBAK(NATOM, ND, ETAKELEM, ETAKOLDELEM)
+        CALL FREQUBAK(NATOM, ND, ETACELEM, ETACOLDELEM)
+        CALL FREQUBAKION(ND, NATOM, MAXION, OPAKION, OPAKOLDION)
+        CALL FREQUBAKION(ND, NATOM, MAXION, OPACION, OPACOLDION)
+        CALL FREQUBAKION(ND, NATOM, MAXION, ETAKION, ETAKOLDION)
+        CALL FREQUBAKION(ND, NATOM, MAXION, ETACION, ETACOLDION)
+        
 
 C***  Test-output at given depth for all wavelengths between XLP1 and XLP2
         IF (BPLOT) THEN
@@ -1441,9 +1666,14 @@
      >        EDDIF(IPLOT), EDDIG(IPLOT), 
      >        XJLMO(IPLOT), XJLMOR2(IPLOT), 
      >        XHLMO(IPLOT), 
-     >        FULFIL0(IPLOT), FULFIL1(IPLOT), DJDSMO(IPLOT),
+     >        FULFIL0(IPLOT), FULFIL1(IPLOT), DJDSMOD(IPLOT),
      >        DJDS(IPLOT), SLNOTH
 C            XHI, XHID
+c            CALL PLOT3D (XLAMK, ND, INDFEACT, MAXFEACT, BPSTART, 
+c     >                   LEVEL, IFELOW, IFENUP, OPAFEI, OPAKH, 
+c     >                   RSTAR, RHO, ENTOT, XHLMO, XJLMO, XNUEK, 
+c     >                   OPAKNOTH, ETAKNOTH, RADIUS2)
+            IF (BPSTART) BPSTART = .FALSE.
           ENDIF
 C***  Test-output at given wavelentgh over depth
           IF (.NOT. BPDONE) THEN
@@ -1459,15 +1689,15 @@
      >            XJCIND(L), XJLO(L, IFRO), 
      >            XJL(L), XHL(L), XKL(L), XNL(L), 
      >            EDDIF(L), EDDIG(L), XJLMO(L), XJLMOR2(L), XHLMO(L), 
-     >            FULFIL0(L), FULFIL1(L), DJDSMO(L), RADIUS(L)
+     >            FULFIL0(L), FULFIL1(L), DJDSMOD(L), RADIUS(L)
               ENDDO
             ENDIF
           ENDIF                
         ENDIF
 
-C***  Store Wcharm-factors here (Variable = DJDSMO) in array IFF_WCHARM
+C***  Store Wcharm-factors here (Variable = DJDSMOD) in array IFF_WCHARM
         IF (BFF_ACT .AND. (.NOT. bKATEST)) THEN
-          CALL CLSAVEWC (IFF_WCHARM, IFF_MAX, IFF_N, ND, DJDSMO, 
+          CALL CLSAVEWC (IFF_WCHARM, IFF_MAX, IFF_N, ND, DJDSMOD, 
      >                    K, XLAMK)
         ENDIF
 
@@ -1492,18 +1722,18 @@
 C***  The next line is to skip the first frequency points for test reasons
 C!!!        if (k .eq. 1) k = 100000
 
-C***  Save old EDDIEs to file fort.<NCHANE>
+C***  Save old EDDIEs to file fort.<hEDDI>
         IF (BCOLIP .AND. (.NOT. bKATEST)) THEN 
-          CALL CLSAVEE (NCHANE, NZE1, NZE2, NFRO, EDDIA, NDEDDIA,
+          CALL CLSAVEE (hEDDI, NZE1, NZE2, NFRO, EDDIA, NDEDDIA,
      >                EDDIF, EDDIG, ND,
-     >                EDDIHOUT, EDDIHIN, EDDINOUT, EDDININ,
+     >                EDDIHOUT, EDDIHIN, EDDIHINM, EDDINOUT, EDDININ,
      >                BCLEERR, CMODE, XHI, XHO, EPSG(1,ITMAX), 
      >                XHOM, XNOM, 
-     >                EDDIHOUTP, EDDINOUTP)
+     >                EDDIHOUTP, EDDINOUTP, EDDIHINT)
         ENDIF
 
 C***  Store XJLMOR2 in XJLO and write XJLO to file (if necessary)
-c        CALL CLSAVEJ (NCHANE, ND, NFRO, XK, IFRO, NXJO, NXK,
+c        CALL CLSAVEJ (hEDDI, ND, NFRO, XK, IFRO, NXJO, NXK,
 c     >                      XJLO, XJLMOR2, CMODE)
 
 C***  Last frequency has been finished : EXIT Main Loop
@@ -1526,26 +1756,28 @@
         ENDDO
       ENDIF
 
-      CALL FREQUNORM (ND, OPASMEAN, OPASMEANTC, SMEAN, QFJMEAN, 
-     >                XJTOTL, OPAJMEAN, OPAJMEANTC, OPAPMEAN, 
+      CALL FREQUNORM (ND, MAXION, OPASMEAN, OPASMEANTC, SMEAN, 
+     >                QFJMEAN, XJTOTL, OPAJMEAN, OPAJMEANTC, OPAPMEAN, 
      >                QOPAHMEAN, HMEAN, EDDIHOUTJMEAN,
      >                RADIUS, RSTAR, DENSCON, 
-     >                  FTCOLI, WJC, WJC_MIN, 
+     >                  FTCOLI, FTCOLIB, WJC, WJC_MIN, 
      >                  FWTEST, NF, OPC, FTFE, LASTFE, 
      >                  LPLOT_WCHARM, XLAMBDA, OPAROSS, OPALAMBDAMEAN, 
      >                  ARAD, ACONT, ATHOM, ENTOT, ABXYZ, ATMASS, NATOM,
-     >                  T, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2,TAUROSS)
+     >                  T, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2,TAUROSS,
+     >                  ARADELEM, ACONTELEM, ARADION, ACONTION,
+     >                  OPAROSSCONT, OPAROSSELEM, OPATOTELEM)
 
 C***  Output of Maximum Opacity
       WRITE (hCPR,*)
-      WRITE (hCPR,'(A, A,I6, A,1P,E12.3, A,E10.3, A,F10.3)')
+      WRITE (hCPR,'(A, A,I6, A,F10.3, A,E10.3, A,F10.3)')
      >  'Maximum Opacity at Depth 1: ', 
      >  'K=', IOPAMAX1_K, 
      >  ';  Lambda=', OPAMAX1_LAMBDA, 
      >  ';  Opacity=', OPAMAX1, 
      >  ';  Delta-Tau (Opa*Delta_R)=', OPAMAX1 * (RADIUS(1)-RADIUS(2))
       WRITE (hCPR,*)
-      WRITE (*,'(A, A,I6, A,1P,E12.3, A,E12.5, A,F12.5)')
+      WRITE (*,'(A, A,I6, A,F12.3, A,E12.5, A,F12.5)')
      >  'COLI> Maximum Opacity at Depth 1: ', 
      >  'K=', IOPAMAX1_K, 
      >  ';  Lambda=', OPAMAX1_LAMBDA, 
@@ -1578,6 +1810,18 @@
         WRITE (hCPR,'(A,I6,A)') 
      >    'U not accounted for at ', IW_COLIRAY_U, ' Rays and Depths'
       ENDIF
+      IF (IW_COLIRAY_IPLUS .GT. 0) THEN
+        WRITE (hCPR,'(A,I6,A)') 
+     >    'XIPLUS set to zero for', IW_COLIRAY_IPLUS, ' Rays'
+      ENDIF
+
+C**** Debug option: print out the number of frequency points with J < 0 
+      IF (bDEBUG) THEN 
+        DO L=1, ND
+          WRITE (hCPR, '(A,I3,A,I8)') 'Frequencies ignored'
+     >        // ' in FREQUINT at L = ', L,': ', iIgnoreK(L)
+        ENDDO
+      ENDIF 
 
       bNewLoop = .FALSE.
 
@@ -1591,7 +1835,14 @@
             bForceCOLIP = BCOLIP
             bForceCLEERR= BCLEERR
             bKATEST     = .FALSE.
+            IF (iTypeAlpha == 3 .OR. iTypeAlpha == 31) THEN
+              ARADTEST    = ARAD
+            ELSE
             ARADTEST    = ARAD - ACONT
+            ENDIF
+            ALINETEST   = ARAD - ACONT
+            ACONTTEST   = ACONT
+            ATHOMTEST   = ATHOM
             HTOTTEST    = HTOTL
          ENDIF
          bNewLoop = .TRUE. 
@@ -1607,40 +1858,116 @@
       ! from the relation 0.9^(ALPHAF) = DELTA
       ! Instead of taking a simple ratio, ALINES is first divided by
       ! HTOT for flux normalization (GH2005)
-      ! Note: all accelerations ARAD, ACONT, ... do NOT contain
-      !       the factor 1/rho * 4*Pi/c
+C***  ALPHA TYPES: (can be set on the HYDRO cards)
+C      0    - no calculation of ALPHAF or Response Factor (switches off double-COLI)
+C      1,10 - calculation of ALPHAF via lamda (modifies v and dv/dr)
+C       11  -   dito but only v is modified
+C       12  -   dito but only dv/dr is modified
+C      2    - calculation of ALPHAF via lamb**2 (modified v and dv/dr)
+C      3    - calculation of Response Factor (ARMDRESP)
+C      31   - calculation of Response Factor (ARMDRESP) incl. velo modificiation
       ELSE IF (bKALPHA .AND. bKADONE) THEN
+         bPrintAlpha = .TRUE.
+      
          !Debug output:
 C         WRITE (hCPR,*)
 C         WRITE (hCPR,*) "Debug output - Force multipliers"
          WRITE (hCPR,*) 
-         DO L=1, ND-1
-            DELTA =
-     >           (HTOTL(L)/HTOTTEST(L))*(ARADTEST(L)/(ARAD(L)-ACONT(L)))
-            IF (DELTA .GT. 0.) THEN
-               ALPHAF(L) = ALOG10(DELTA)/ALOG10(VELOMODFAK)
-            ENDIF
-C            WRITE (hCPR,'(A,I2,A,E16.4,A,E16.4)') 
-C     >        ' L=', L, ' Delta=', DELTA, ' alpha=', ALPHAF(L)
-C            IF ((ARADTEST(L)/(ARAD(L)-ACONT(L))) > 0.) THEN
-C              WRITE (hCPR,'(A,E20.8,A,E20.8)') ' ohne Norm: delta=',
-C     >          (ARADTEST(L)/(ARAD(L)-ACONT(L))), ' alpha=',
-C     >          LOG10(ARADTEST(L)/(ARAD(L)-ACONT(L)))/LOG10(0.9)
-C            ENDIF
-         ENDDO
-         ATMEAN = 0.
-         DO NA=1, NATOM
-            ATMEAN = ATMEAN + ABXYZ(NA) * ATMASS(NA)
-         ENDDO
+         WRITE (hCPR,*) ' Alpha-Type:', iTypeAlpha
+         WRITE (hCPR,*) ' XMG = ', XMG
          DO L=1, ND
             RHO(L) = AMU*ATMEAN*ENTOT(L)
             XMU(L) = ATMEAN/(1.+RNE(L))
+            VELORAW(L) = VELO(L) * VDOPUNIT
+            VMACH(L) = SQRT( RGAS * T(L) / XMU(L) ) / 1.E5      !v_mach in km/s
          ENDDO
+         DOTM4P = RHO(1)*VELO(1)*VDOPUNIT*1.E5*(RADIUS(1)*RSTAR)**2
+         ARADTOT = 0.
+         ACONTTOT = 0.
+         ARADTESTTOT = 0.
+         ACONTTESTTOT = 0.
          DO L=1, ND-1
+           DELTAR = 0.5 * ( RADIUS(L) + RADIUS(L+1) )
+           ARADTOT = ARADTOT + ARAD(L) * DELTAR
+           ACONTTOT = ACONTTOT + ACONT(L) * DELTAR
+           ARADTESTTOT = ARADTESTTOT + ARADTEST(L) * DELTAR
+           ACONTTESTTOT = ACONTTESTTOT + ACONTTEST(L) * DELTAR
+           DELTA = 
+     >           (HTOTL(L)/HTOTTEST(L))*(ARADTEST(L)/(ARAD(L)-ACONT(L)))
+            !Additional multiplication with VELOMODFAK from inferred density variation
+C            DELTA = VELOMODFAK *
+C     >           (HTOTL(L)/HTOTTEST(L))*(ARADTEST(L)/(ARAD(L)-ACONT(L)))
+           ARMDRESP(L) = 1.
+           
+           IF (iTypeAlpha == 3) THEN
+               ALPHAF(L) = 0.
+               ACONTMDRESP(L) = ACONT(L)*VELOMODFAK/ACONTTEST(L)
+               ALINEMDRESP(L) = (ARAD(L)-ACONT(L))
+     >                                 * VELOMODFAK/ALINETEST(L)
+               ARMDRESP(L) = ARAD(L)*VELOMODFAK/ARADTEST(L)
+C               ARMDRESP(L) = ARAD(L)*VELOMODFAK/ARADTEST(L)
+     >                           * HTOTTEST(L)/HTOTL(L)         
+CC          scale to a 10 percent change
+               ARMDRESP(L) = 1. - (1. - ARMDRESP(L)) 
+     >                                    * 0.1 / (1./VELOMODFAK - 1.)
+               WRITE (hCPR,'(A,I4,6(2X,G15.8))') ' Mdmod ', L, 
+     >            ARAD(L)/XMG * (RADIUS(L)*RSTAR)**(2.),
+     >            ARADTEST(L)/XMG * (RADIUS(L)*RSTAR)**(2.),
+     >            ARADTEST(L)/ARAD(L), 
+     >            ARMDRESP(L),      !Response of a_rad on Mdot change
+     >            VELOMODFAK/ACONTMDRESP(L), VELOMODFAK/ALINEMDRESP(L)
+           ELSEIF (DELTA > 0.) THEN               
+             IF (iTypeAlpha == 2) THEN          
+               ALPHAF(L) = ALOG10(DELTA*ATHOM(L)/ATHOMTEST(L))
+     >                               /ALOG10(VELOMODFAK)/2.
+               CK(L) = (ARAD(L)-ACONT(L) -ARADTEST(L))
+     >            *(RADIUS(L)*RSTAR)**2 * RHO(L)/(1.-VELOMODFAK**2)
+     >             / (GRADI(L)*VDOPUNIT*1.E5/RSTAR)
+               ALPHAALT(L) = 
+     >             LOG10(ARADTEST(L)/(ARAD(L)-ACONT(L))) 
+     >                            / LOG10(VELOMODFAK)
+             ELSE
+               ALPHAF(L) = ALOG10(DELTA)/ALOG10(VELOMODFAK)
+               CK(L) = (ARAD(L)-ACONT(L) -ARADTEST(L))
+     >            *(RADIUS(L)*RSTAR)**2 * RHO(L) / (1 - VELOMODFAK)
+     >             / (GRADI(L)*VDOPUNIT*1.E5/RSTAR)
+             ENDIF
+             GAMMATHIN(L) = 1./XMG*((RADIUS(L)*RSTAR)**(2.)*
+     >                                             (ARAD(L)-ACONT(L))
+     >          - CK(L)/RHO(L) * GRADI(L)*VDOPUNIT*1.E5/RSTAR)
+             GAMMAPOWR = (RADIUS(L)*RSTAR)**(2.) /XMG * ACONT(L) 
+     >                       + GAMMATHIN(L)
+             IF (iTypeAlpha <= 2 .AND. bPrintAlpha) THEN
+               ALPHAALT(L) = 
+     >             LOG10(ARADTEST(L)/(ARAD(L)-ACONT(L))) 
+     >                            / LOG10(VELOMODFAK)
+               WRITE (hCPR,'(A,I4,10(2X,G15.8))') ' Thomson-corr: ',
+     >           L , ATHOMTEST(L)/ATHOM(L), ALPHAF(L),  
+     >           (CK(L)/(RADIUS(L)*RSTAR)**2 
+     >                      /RHO(L)*GRADI(L)*VDOPUNIT*1.E5/RSTAR)/
+     >           ( ARAD(L) - ACONT(L) ),
+C     >           ( XMG / (RADIUS(L)*RSTAR)**2 *GAMMATHIN(L) ),
+     >           CK(L), GAMMATHIN(L), GAMMAPOWR, 
+     >            (RADIUS(L)*RSTAR)**2 /XMG * (ARAD(L) * (1.-ALPHAF(L))
+     >             + ALPHAF(L) * ACONT(L)),
+     >            CK(L)/DOTM4P, ALPHAF(L)*(ARAD(L)-ACONT(L))/
+     >               (VELO(L)*GRADI(L)/RSTAR*(VDOPUNIT*1.E5)**2),
+     >           1. - GAMMAPOWR
+             ENDIF
+           ENDIF
+
          ENDDO
+         WRITE (hCPR,'(A,8(2X,G15.8))') 'TOT: ', ARADTESTTOT/ARADTOT, 
+     >        ARADTOT/ARADTESTTOT, VELOMODFAK, 1./VELOMODFAK,
+     >       ARADTESTTOT/ARADTOT/VELOMODFAK, 
+     >       ARADTESTTOT/ARADTOT*VELOMODFAK,
+     >       ACONTTESTTOT/ACONTTOT, 
+     >       (ARADTESTTOT-ACONTTESTTOT)/(ARADTOT-ACONTTOT)
          WRITE (hCPR,*) 
          IF (BPLOTALPHA) THEN
-           CALL PLOTALPHA(ND, RADIUS, ALPHAF, MODHEAD, JOBNUM, .TRUE.)
+           CALL PLOTALPHA(ALPOPT, ND, RADIUS, ALPHAF,
+     >                    VMACH, VELORAW, TAUROSS, ENTOT, ATMEAN, 
+     >                    MODHEAD, JOBNUM, .TRUE.)
          ENDIF
       ENDIF
 
@@ -1662,20 +1989,37 @@
       ENDDO
 
       IF (.NOT. bNewLoop) THEN
+        DO K=1, NF
+          IF (LSOPA > 0) THEN
+            IF (K == 1) THEN
+              WRITE (hCPR,*) 'COLI> Opacities exported to OUT file'
+            ENDIF
+            CALL PRIOPACOLI (XLAMBDA(K), K, ND, LSOPA, RADIUS, 
+     >                       OPAKINT, ETAKINT, THOMSON, FILLFAC, 
+     >                       IWARN, MAINPRO, MAINLEV, JOBNUM, MODHEAD)
+          ENDIF      
+        ENDDO
+            
                 CALL WMODCOLI(XJCINT, FWTEST, ARAD, ACONT, ATHOM, ND, NF,
      >              RADIUS, ENTOT, RSTAR,
-     >              XJFEMEAN, SIGMAINT, LASTFE, 
-     >              HTOTL, HTOTND, HTOTNDCOR, 
-     >              WFELOW, WFENUP, FTCOLI, NCOLIP, 
+     >              XJFEMEAN, SIGMAINT, LASTFE, HTOTL, WFELOW,
+     >              WFENUP, FTCOLI, FTCOLIB, REDISMODE, NCOLIP, 
      >              XJTOTL, XKTOTL, XNTOTL, WJC,
      >              DBDTINT, DBDTOPAINT, DBDTINT_M, DBDTOPAINT_M,
-     >              OPASMEAN, OPASMEANTC, OPAPMEAN, QFJMEAN,
-     >              SMEAN, OPAJMEAN, OPAJMEANTC,
-     >              QOPAHMEAN, EDDIHOUTJMEAN, HTOTOUTMINUS,LASTINDAUTO,
-     >              FERATUL, FERATLU, BCOLIP, EPSGMAX,
+     >              OPASMEAN, OPASMEANTC, OPAPMEAN, 
+     >              QFJMEAN, SMEAN,
+     >              OPAJMEAN, OPAJMEANTC, QOPAHMEAN,
+     >              EDDIHOUTJMEAN, HMEAN,
+     >              HTOTOUTMINUS, HTOTMINUSND, HTOTND, 
+     >              HTOTNDCOR, HTOTCUT,
+     >              LASTIND, FERATUL, FERATLU, BCOLIP, EPSGMAX,
      >              FTFE, EMCOLI, FF_INFO, IFF_DK, IFF_MAX,
      >              IFF_WCHARM, OPALAMBDAMEAN, TOTOUT, bKALPHA,
-     >              ALPHAF, RHO, XMU, TAUROSS, OPAROSS)
+     >              ALPHAF, ARMDRESP, GAMMATHIN, CK,
+     >              RHO, XMU, TAUROSS, OPAROSS, OPAROSSELEM, 
+     >              OPAROSSCONT, OPATOTELEM, NATOM, 
+     >              ARADELEM, ACONTELEM, MAXION, ARADION, ACONTION,
+     >              hMODEL, hALO)
         CALL STORE_FF(MODHEAD, JOBNUM, ND, NDDIM, 
      >                FF_INFO, IFF_DK, IFF_MAX, IFF_WCHARM)
       ENDIF
@@ -1724,9 +2068,11 @@
       IF (BELIFI) THEN
         CALL CLOSMS (7, IERR)
       ENDIF
-      CALL CLOSMS (3, IERR)
+      CALL CLOSMS (hMODEL, IERR)
+      CALL CLOSMS (hALO, IERR)
       IF ((.NOT. BSHORT) .AND. (.NOT. bNewLoop)) THEN
-        CALL CLOSMS (NCHANE, IERR)
+        CALL CLOSMS (hEDDI, IERR)
+        WRITE (hCPR,*) 'Closing EDDI file...'
       ENDIF
 
       IF (BPLOT) THEN
@@ -1739,6 +2085,16 @@
         CLOSE (90)
         CLOSE (91)
         CLOSE (92)
+        CLOSE (121)
+        CLOSE (122)
+        CLOSE (123)
+        CLOSE (131)
+        CLOSE (132)
+        CLOSE (133)
+      ENDIF
+
+      IF (LPRDH > 0) THEN
+        CLOSE (140)
       ENDIF
 
 C***  Close WCHARM Plot File
diff -bur ./colimo.f ../../powr-refactor/src/colimo.f
--- ./colimo.f	2024-07-28 13:13:06.000000000 +0200
+++ ../../powr-refactor/src/colimo.f	2024-08-19 21:09:51.826114106 +0200
@@ -1,23 +1,28 @@
-      SUBROUTINE COLIMO(K, ND, RADIUS, OPAK, ETAK, ETAKNOTH, 
+C*** ISU unused variable
+C    >             OPAKNOTH, 
+      SUBROUTINE COLIMO(K, ND, RADIUS, OPAK, ETAKNOTH, 
      >             OPAKNOTH, 
-     >             S, XJLMO, XJLMOR2, XHLMO, 
+C    >             S, XJLMO, XJLMOR2, XHLMO, 
+     >             XJLMO, XJLMOR2, XHLMO, 
      >             XJLMO_OLD, XHLMO_OLD, 
      >             DLF, DLH, GLF, GLH, VLF, VLH, 
      >             GLF2, GLH2, VLF2, VLH2, 
      >             QLF, QLH, OPAKH, 
      >             EDDIF, EDDIFO, EDDIG, EDDIGO,
-     >             EDDIHOUT, EDDIHIN, EDDIHOUTO,
-     >             EDDINOUT, EDDININ, EDDINOUTO,
+C    >             EDDIHOUT, EDDIHIN, EDDIHOUTO,
+     >             EDDIHOUT, EDDIHIN,
+C    >             EDDINOUT, EDDININ, EDDINOUTO,
      >             ALH, BLH, CLH, 
      >             A, B, C, W, DX, 
-     >             BCORE, DBDR, XIMINUS, BPDONE, XLAMK,
-     >             DJDSMO, DJDOMO, 
+C    >             BCORE, DBDR, XIMINUS, BPDONE, XLAMK,
+     >             BCORE, XLAMK,
+     >             DJDSMOD, bALOTri, DJDSMOU, DJDSMOL,
      >             FULFIL0, FULFIL1, BPLOT, BPLOT2, IPLOT, 
      >             IW_COLIMO_F, IW_COLIMO_G, IW_COLIMO_G2, BSTATIC, 
      >             CLMOETA, CLMOOPA, XHI, 
      >             RADIUS2, EPSG, GEPSB, GEPSBO, 
-     >             XHOM, XHOMO, XNOM, XNOMO, 
-     >             EDDIHOUTP, EDDINOUTP, EDDIHOUTOP, EDDINOUTOP,
+C    >             XHOM, XHOMO, XNOM, XNOMO, 
+C    >             EDDIHOUTP, EDDINOUTP, EDDIHOUTOP, EDDINOUTOP,
      >             IWARNJMNEG)
 
 
@@ -26,7 +31,9 @@
 C***  -A, B, -C and W are calculated
 C********************************************************
 
-      DIMENSION RADIUS(ND), OPAK(ND), ETAK(ND), ETAKNOTH(ND), S(ND)
+C*** ISU unused variable
+C     DIMENSION RADIUS(ND), OPAK(ND), ETAK(ND), ETAKNOTH(ND), S(ND)
+      DIMENSION RADIUS(ND), OPAK(ND), ETAKNOTH(ND)
       DIMENSION OPAKNOTH(ND)
       DIMENSION XJLMO(ND), XJLMOR2(ND), XHLMO(ND)
       DIMENSION XJLMO_OLD(ND), XHLMO_OLD(ND)
@@ -38,17 +45,81 @@
       DIMENSION EDDIF(ND), EDDIFO(ND)
       DIMENSION EDDIG(ND-1), EDDIGO(ND-1)
       DIMENSION ALH(ND-1), BLH(ND-1), CLH(ND-1)
+C*** ISU unused variable
+C     DIMENSION A(ND), B(ND), C(ND), D(ND), E(ND), W(ND)
       DIMENSION A(ND), B(ND), C(ND), W(ND)
-      DIMENSION D(ND), E(ND), DINV(ND), DJDSMO(ND), DJDOMO(ND)
+C     DIMENSION DINV(ND), DJDSMOD(ND), DJDSMOU(ND), DJDSMOL(ND)
+      DIMENSION DJDSMOD(ND), DJDSMOU(ND), DJDSMOL(ND)
       DIMENSION FULFIL0(ND), FULFIL1(ND)
-      DIMENSION ETAT(ND), OPAT(ND), CLMOETA(ND), CLMOOPA(ND)
+      DIMENSION CLMOETA(ND), CLMOOPA(ND)
       DIMENSION RADIUS2(ND)
       DIMENSION EPSG(ND), GEPSB(ND), GEPSBO(ND)
-      LOGICAL BPDONE, BPLOT, BPLOT2, BSTATIC, BOPAFULL
-      CHARACTER*4 REDISMODE
+C     LOGICAL BPDONE, BPLOT, BPLOT2, BSTATIC, bALOTri
+      LOGICAL BPLOT, BPLOT2, BSTATIC, bALOTri
 
       INTEGER :: IWARNJMNEG
       
+
+      ! write(*,*) "RADIUS" , RADIUS
+      ! write(*,*) "OPAK" , OPAK
+      ! write(*,*) "ETAKNOTH" , ETAKNOTH
+      ! write(*,*) "OPAKNOTH", OPAKNOTH
+      ! write(*,*) "XJLMO", XJLMO
+      ! write(*,*) "XJLMOR2", XJLMOR2
+      ! write(*,*) "XHLMO", XHLMO
+      ! write(*,*) "XJLMO_OLD", XJLMO_OLD
+      ! write(*,*) "XHLMO_OLD", XHLMO_OLD
+      ! write(*,*) "DLF", DLF
+      ! write(*,*) "DLH",DLH
+      ! write(*,*) "GLF", GLF
+      ! write(*,*) "GLH", GLH
+      ! write(*,*) "VLF", VLF
+      ! write(*,*) "VLH", VLH
+      ! write(*,*) "GLF2", GLF2
+      ! write(*,*) "GLH2", GLH2
+      ! write(*,*) "VLF2", VLF2
+      ! write(*,*) "VLH2", VLH2
+      ! write(*,*) "QLF", QLF
+      ! write(*,*) "QLH", QLH
+      ! write(*,*) "OPAKH", OPAKH
+      ! write(*,*) "EDDIF", EDDIF
+      ! write(*,*) "EDDIFO", EDDIFO
+      ! write(*,*) "EDDIG", EDDIG
+      ! write(*,*) "EDDIGO",EDDIGO
+      ! write(*,*) "EDDIHOUT", EDDIHOUT
+      ! write(*,*) "EDDIHIN", EDDIHIN
+      ! write(*,*) "ALH", ALH
+      ! write(*,*) "BLH", BLH
+      ! write(*,*) "CLH", CLH
+      ! write(*,*) "A", A
+      ! write(*,*) "B", B
+      ! write(*,*) "C", C
+      ! write(*,*) "W", W
+      ! write(*,*) "DX", DX
+      ! write(*,*) "BCORE", BCORE
+      ! write(*,*) "XLAMK",XLAMK
+      ! write(*,*) "DJDSMOD", DJDSMOD
+      ! write(*,*) "bALOTri", bALOTri
+      ! write(*,*) "DJDSMOU", DJDSMOU
+      ! write(*,*) "DJDSMOL",DJDSMOL
+      ! write(*,*) "FULFIL0", FULFIL0
+      ! write(*,*) "FULFIL1", FULFIL1
+      ! write(*,*) "BPLOT", BPLOT
+      ! write(*,*) "BPLOT2", BPLOT2
+      ! write(*,*) "IPLOT", IPLOT
+      ! write(*,*) "IW_COLIMO_F", IW_COLIMO_F
+      ! write(*,*) "IW_COLIMO_G", IW_COLIMO_G
+      ! write(*,*) "IW_COLIMO_G2", IW_COLIMO_G2
+      ! write(*,*) "BSTATIC", BSTATIC
+      ! write(*,*) "CLMOETA", CLMOETA
+      ! write(*,*) "CLMOOPA", CLMOOPA
+      ! write(*,*) "XHI", XHI
+      ! write(*,*) "RADIUS2", RADIUS2
+      ! write(*,*) "EPSG", EPSG
+      ! write(*,*) "GEPSB", GEPSB
+      ! write(*,*) "GEPSBO", GEPSBO
+      ! write(*,*) "IWARNJMNEG", IWARNJMNEG
+
 C***  DNUEINV is frequency step in Hertz * Doppler velocity in cm/s
       IF (K .EQ. 0 .OR. BSTATIC) THEN
         DNUEINV = 0.
@@ -83,10 +154,17 @@
         GLH(L) = DNUEINV * GLH2(L)
         VLH(L) = DNUEINV * VLH2(L)
 cc eddig-reset testweise stillgelegt zugunsten von EDDIMIX
-        IF (EDDIG(L)*GLH(L)+VLH(L) .LT. -1.E-15) THEN
+c        IF (EDDIG(L)*GLH(L)+VLH(L) .LT. -1.E-15 .OR. EDDIG(L) < 0.) THEN
+c         IF (EDDIG(L) < 0. .OR. EDDIG(L) > 1.) THEN
 c          write (0,'(a,i7,1x,f8.3,i3,2(1x,f7.3))') 
 c     >      'k, xlamk, l', k, xlamk, l, 
 c     >      EDDIG(L), EDDIG(L)*GLH(L)+VLH(L)
+c         ENDIF
+
+        IF (EDDIG(L)*GLH(L)+VLH(L) .LT. -1.E-15) THEN
+c          write (0,'(a,i7,1x,f8.3,i3,3(1x,f10.6))') 
+c     >      'k, xlamk, l', k, xlamk, l, 
+c     >      EDDIG(L), EDDIG(L)*GLH(L)+VLH(L), -VLH(L)/GLH(L)
           EDDIG(L) = -VLH(L)/GLH(L)
 ccc No reset of EDDIG at last K
 ccc          EDDIGO(L) = EDDIG(L)
@@ -166,13 +244,15 @@
         C(1)  = 2./DLF(1)* 
      >             (QLF(2)*EDDIF(2)*ALH(1)/QLH(1) - GEPSB(1))
         B(1)  = 2./DLF(1) * 
-     >             (QLF(1)*EDDIF(1)*ALH(1)/QLH(1) + EDDIHOUTP
+c     >             (QLF(1)*EDDIF(1)*ALH(1)/QLH(1) + EDDIHOUTP
+     >             (QLF(1)*EDDIF(1)*ALH(1)/QLH(1) + EDDIHOUT   !test with full EDDIHOUT
      >              + GEPSB(1) ) 
      >          + GLF(1)*EDDIF(1) + VLF(1) + CLMOOPA(1)
         W(1)  = 2./DLF(1)*
      >              ((BLH(1)*EDDIGO(1)+CLH(1))*XHLMO_OLD(1) 
      >               + GEPSBO(1) * (XJLMO_OLD(1) + XJLMO_OLD(2)) 
-     >               - XHOM )
+c     >               - XHOM )
+     >               - 0. )     !test without prescribed XHOM (i.e. full EDDIHOUT)
      >           + (GLF(1)*EDDIFO(1)+VLF(1))*XJLMO_OLD(1) 
      >           + CLMOETA(1)*RADIUS2(1) 
 
@@ -256,54 +336,27 @@
      >      GLF(IPLOT), VLF(IPLOT), GLH(IPLOT), VLH(IPLOT)
         ENDIF
 
-      CALL INVTRI (A, B, C, W, ND)
-
-C**********************************************************************
-C***  Calculate Diagonal Elements(^-1) of the Inverse of the T-Matrix
-C**********************************************************************
       DO L=1, ND
          A(L) = A(L)/CLMOOPA(L)
          B(L) = B(L)/CLMOOPA(L)
          C(L) = C(L)/CLMOOPA(L)
+        W(L) = W(L)/CLMOOPA(L)
       ENDDO
 
-C***  B is set negativ due to the form of the matrix -A, B, -C
-C***    and Matrix is divided by -OPA
-      D(1) = C(1) / (-B(1))
-      DO L=2, ND
-         D(L) = C(L) / (-B(L) - A(L)*D(L-1))
-      ENDDO
-
-      E(ND) = A(ND) / (-B(ND))
-      DO L=ND-1, 1, -1
-         E(L) = A(L) / (-B(L) - C(L)*E(L+1))
-      ENDDO
-
-      DINV(1) = (1. - D(1)*E(2)) * (-B(1))
-      DO L=2, ND-1
-ccc         DINV(L) = (1. - D(L)*E(L+1)) * (-B(L) - A(L)*D(L-1))
-         DINV(L) = (1. - D(L)*E(L+1)) * (B(L) - A(L)*D(L-1))
-      ENDDO
-ccc      DINV(ND) = -B(ND) - A(ND)*D(ND-1)
-      DINV(ND) = B(ND) - A(ND)*D(ND-1)
-
-      DO L=1, ND
-         DJDSMO(L) = 1.  / DINV(L)
-         DJDOMO(L) = (GLF(L)*EDDIFO(L)+VLF(L)) / (DINV(L)*CLMOOPA(L))
-      ENDDO
-      DJDSMO(1)    = 0.
-      DJDOMO(1)    = 0.
-      DJDSMO(ND)   = 0.
-      DJDOMO(ND)   = 0.
 C**********************************************************************
+C***  Solve system with tridiagonal matrix to obtain solution vector
+C***   solution for XJL is rewritten in W vector
+C**********************************************************************
+      CALL LINTRIDIAGSOL (A, B, C, W, DJDSMOD, ND, 
+     >                    bALOTri, DJDSMOU, DJDSMOL)
 
       DO L=1, ND
-C***    WARNING counter increase if negative J encountered    
+C***    Protocol for warnings for negative results in XJL (=W now)      
         IF (W(L) < 0.) IWARNJMNEG = IWARNJMNEG + 1
 
 C***    Set J to zero, if small or neg. values
 C***    as recommended by Andreas - wrh  5-Mar-2019
-        IF (W(L) < EXP(-499.)) THEN
+        IF (W(L) < EXP(-499.D0)) THEN
           XJLMO(L) = 0.
           XJLMOR2(L) = 0.
         ELSE
@@ -312,12 +365,15 @@
         ENDIF
       ENDDO
 
+C***  We set the boundary terms to zero (why?)      
+      DJDSMOD(1)    = 0.
+      DJDSMOD(ND)   = 0.
 
 C***  Calculation of the flux from the moment equation (XHLMO)
 C***  again suppressing neg. values as recommended by Andreas 
 C***  - wrh 5-Mar-2019
       DO L=1, ND-1
-        IF (W(L) < EXP(-499.)) THEN
+        IF (W(L) < EXP(-499.D0)) THEN
           XHLMO(L) = 0.
         ELSE
           XHLMO(L) = ALH(L)/QLH(L)*
diff -bur ./coli_setzero.f ../../powr-refactor/src/coli_setzero.f
--- ./coli_setzero.f	2024-07-28 13:13:05.000000000 +0200
+++ ../../powr-refactor/src/coli_setzero.f	2024-07-22 09:27:16.100033925 +0200
@@ -1,16 +1,23 @@
-      SUBROUTINE COLI_SETZERO(ND, NDDIM, NIT, NPDIM, NFDIM, MAXFEIND, 
-     >             MAXLIN, DBDTINT, DBDTOPAINT, EDDIHOUTJMEAN, 
-     >             HTOTOUTMINUS, HTOTND, HTOTNDCOR,
-     >             DBDTINT_M, DBDTOPAINT_M,
-C***  with ND
+      SUBROUTINE COLI_SETZERO(ND, NDDIM, NIT, NPDIM, NFDIM, MAXATOM,
+     >             MAXFEIND, MAXLIN, MAXIND, MAXION,
+     >             DBDTINT, DBDTOPAINT, EDDIHOUTJMEAN, 
+     >             HTOTOUTMINUS, DBDTINT_M, DBDTOPAINT_M,
+C***  with ND (NDDIM)
      >             OPA, ETA,
      >             XJTOTL, HTOTL, XKTOTL, XNTOTL, ARAD, ACONT, ATHOM, 
-     >             FTCOLI, OPAKOLD, ETAKOLD, OPAKNOTHO, ETAKNOTHO, 
-     >             OPAO, THOMSONO, ETANOTHO, DJDSMO_OLD, DJDOMO_OLD, 
+     >             FTCOLI, FTCOLIB, OPAKOLD, ETAKOLD, OPAKNOTHO, 
+     >             ETAKNOTHO, OPAO, THOMSONO, ETANOTHO,
+     >             DJDSMOD_OLD, 
      >             OPASMEAN, QFJMEAN, OPAJMEAN, OPASMEANTC, OPAJMEANTC, 
-     >             OPAPMEAN, SMEAN, QLFOLD, EPSGMAX, OPAROSS, OPALAMBDAMEAN,
-C***  with ND-1
+     >             OPAPMEAN, SMEAN, QLFOLD, EPSGMAX, OPAROSS, 
+     >             OPALAMBDAMEAN,
+     >             OPAROSSELEM, OPAROSSCONT,
+     >             OPAKFEOLD, iIgnoreK, OPAKFEFTOLD, ETAKFEFTOLD, 
+     >             OPAKNOFENOTHO, ETAKNOFENOTHO,
+     >             bOSKIPLAST, XLAMLASTOSKIP, XJLMO, XJLMOR2,
+C***  with ND-1 (NDDIM-1)
      >             QOPAHMEAN, HMEAN, QLHOLD, OPAKHOLD, 
+     >             HTOTLTEST, HTOTCUT,
 C***  with NDDIM,NIT
      >             XJLOLD, XJLMO_OLD, EDDIFO, S_OLD, OPAK_OLD, EPSG,
 C***  with NDDIM,NPDIM
@@ -20,46 +27,77 @@
 C***  with NDDIM,NPDIM,NIT
      >             XIPLUS_OLD, XIMINUS_OLD,
 C***  with NDDIM-1, NIT; In COLI it is also NDDIM,NIT
+C*** ISU what does "In COLI it is also NDDIM,NIT" mean?
+C EDDIGO is here set to NDDIM,NIT, but in coli to NDDIM-1, NIT
+C memory access overflow 
      >             XHLOLD, XHLMO_OLD, EDDIGO, 
 C***  with MAXFEIND, NDDIM
      >             XJFEMEAN, FERATLU, FERATUL, FTFE, WFELOW, WFENUP,
+C***  with MAXATOM,ND
+     >             OPAKELEM, OPAKOLDELEM, OPACELEM, OPACOLDELEM,
+     >             ETAKELEM, ETAKOLDELEM, ETACELEM, ETACOLDELEM,
+     >             OPATOTELEM,
+C***  with MAXATOM,ND-1
+     >             ARADELEM, ACONTELEM,
+C***  with ND, MAXATOM, MAXION
+     >             OPAKION, OPAKOLDION, OPACION, OPACOLDION,
+     >             ETAKION, ETAKOLDION, ETACION, ETACOLDION,
+C***  with ND-1, MAXATOM, MAXION
+     >             ARADION, ACONTION,
 C***  with MAXLIN
-     >             LIND, LINDS, WS,
+     >             LIND, LINDS,
+C***  with NDDIM, MAXLIN
+     >             WS,
 C***  with MAXIND
-     >             MAXIND, BLASERL,
+     >             BLASERL,
 C***  with NFDIM
      >             EMCOLI,
 C***  no Arrays
+     >             HTOTMINUSND, HTOTND, HTOTNDS, HTOTNDCOR,
      >             OPAMAX1, OPAMAX1_LAMBDA, IOPAMAX1_K)
 
 C****************************************************************
 C***  Presets all given variables to zero
 C***    Called by COLI
+C***
+C***  Note: For the line opacities only the "old"-variables are
+C***        nulled here, the variables for the current K index
+C***        are nulled in ADDOPA
 C****************************************************************
 
       IMPLICIT NONE
 
-      INTEGER, INTENT(IN) :: ND, NDDIM, NIT, NPDIM, NFDIM,
-     >                       MAXFEIND, MAXLIN, MAXIND
-      REAL, DIMENSION(ND) :: XJTOTL, HTOTL, XKTOTL, XNTOTL, 
-     >                       ARAD, ACONT, ATHOM, FTCOLI, 
+      INTEGER, INTENT(IN) :: ND, NDDIM, NIT, NPDIM, NFDIM, MAXATOM,
+     >                       MAXFEIND, MAXLIN, MAXIND, MAXION
+      REAL, DIMENSION(NDDIM) :: XJTOTL, HTOTL, XKTOTL, XNTOTL, 
+     >                       ARAD, ACONT, ATHOM, FTCOLI, FTCOLIB,
      >                       OPAKOLD, ETAKOLD, OPAKNOTHO, ETAKNOTHO, 
      >                       OPAO, THOMSONO, ETANOTHO, 
-     >                       DJDSMO_OLD, DJDOMO_OLD, OPASMEAN, 
+     >                       DJDSMOD_OLD, OPASMEAN, 
      >                       QFJMEAN, OPAJMEAN, OPASMEANTC, 
-     >                       OPAJMEANTC, OPAPMEAN, SMEAN, QLFOLD,
-     >                       EPSGMAX, OPAROSS, OPALAMBDAMEAN
-      REAL, DIMENSION(NDDIM) :: OPA, ETA
+     >                       OPAJMEANTC, OPAPMEAN, SMEAN,
+     >                       QLFOLD, 
+     >                       EPSGMAX, OPAROSS,
+     >                       OPAKNOFENOTHO, ETAKNOFENOTHO,
+     >                       OPAKFEFTOLD, ETAKFEFTOLD, HTOTLTEST, 
+     >                       HTOTCUT, XLAMLASTOSKIP, XJLMO, XJLMOR2
+      LOGICAL, DIMENSION(NDDIM) :: bOSKIPLAST
+      INTEGER, DIMENSION(NDDIM) :: iIgnoreK
+      REAL, DIMENSION(NDDIM) :: OPA, ETA, 
+     >                          OPAKFEOLD, OPAROSSCONT, 
+     >                          OPALAMBDAMEAN
       REAL, DIMENSION(NDDIM,NIT) :: S_OLD, OPAK_OLD, EPSG
       REAL, DIMENSION(NDDIM,NPDIM) :: CWM0, CWM2, CWM1, CWM3
       REAL, DIMENSION(NDDIM, MAXFEIND) :: WFELOW, WFENUP, FTFE, 
      >                                    XJFEMEAN
       REAL, DIMENSION(NDDIM,NFDIM) :: WJC
       
-      REAL, DIMENSION(ND-1) :: QOPAHMEAN, HMEAN, QLHOLD, OPAKHOLD
+      REAL, DIMENSION(NDDIM-1) :: QOPAHMEAN, HMEAN, QLHOLD, OPAKHOLD
 
       REAL, DIMENSION(NDDIM,NIT) :: XJLOLD, XJLMO_OLD, EDDIFO, 
-     >                              XHLOLD, XHLMO_OLD, EDDIGO
+     >                              XHLOLD, XHLMO_OLD
+      REAL, DIMENSION(NDDIM-1,NIT) :: EDDIGO
+
 
       REAL, DIMENSION(NDDIM,NPDIM,NIT) :: XIPLUS_OLD, XIMINUS_OLD
 
@@ -67,15 +105,28 @@
       
       REAL, DIMENSION(MAXFEIND,NDDIM) :: FERATLU, FERATUL
 
+      REAL, DIMENSION(MAXATOM, NDDIM) :: OPAKELEM, OPAKOLDELEM, 
+     >                                   OPACELEM, OPACOLDELEM,
+     >                                   ETAKELEM, ETAKOLDELEM, 
+     >                                   ETACELEM, ETACOLDELEM, 
+     >                                   OPAROSSELEM, OPATOTELEM
+      REAL, DIMENSION(MAXATOM, NDDIM-1) :: ARADELEM, ACONTELEM
+
+      REAL, DIMENSION(NDDIM, MAXATOM, MAXION) :: OPAKION, OPAKOLDION, 
+     >                                           OPACION, OPACOLDION,
+     >                                           ETAKION, ETAKOLDION, 
+     >                                           ETACION, ETACOLDION
+      REAL, DIMENSION(NDDIM, MAXATOM, MAXION) :: ARADION, ACONTION
+      
       INTEGER, DIMENSION(MAXLIN) :: LIND, LINDS
-      REAL, DIMENSION(MAXLIN) :: WS
+      REAL, DIMENSION(NDDIM, MAXLIN) :: WS
       
       LOGICAL, DIMENSION(MAXIND) :: BLASERL
       
-      INTEGER :: IOPAMAX1_K
+      INTEGER :: IOPAMAX1_K, IND, L
       REAL :: OPAMAX1_LAMBDA, OPAMAX1, HTOTOUTMINUS, EDDIHOUTJMEAN,
      >        DBDTOPAINT_M, DBDTINT_M, DBDTOPAINT, DBDTINT,
-     >        HTOTND, HTOTNDCOR
+     >        HTOTMINUSND, HTOTND, HTOTNDCOR, HTOTNDS
 
 C***  Set Zero
       DBDTINT        = 0.
@@ -84,8 +135,12 @@
       DBDTOPAINT_M   = 0.
       EDDIHOUTJMEAN  = 0.
       HTOTOUTMINUS   = 0.
+      HTOTMINUSND    = 0.
       HTOTND         = 0.
+      HTOTNDS        = 0.
       HTOTNDCOR      = 0.
+      HTOTLTEST      = 0.
+      HTOTCUT        = 0.
  
       OPA            = 0.
       ETA            = 0.
@@ -102,6 +157,7 @@
       ACONT          = 0.
       ATHOM          = 0.
       FTCOLI         = 0.
+      FTCOLIB        = 0.
       OPAKOLD        = 0.
       ETAKOLD        = 0.
       OPAKNOTHO      = 0.
@@ -109,8 +165,7 @@
       OPAO           = 0.
       THOMSONO       = 0.
       ETANOTHO       = 0.
-      DJDSMO_OLD     = 0.
-      DJDOMO_OLD     = 0.
+      DJDSMOD_OLD    = 0.
       OPASMEAN       = 0.
       QFJMEAN        = 0.
       OPAJMEAN       = 0.
@@ -122,12 +177,23 @@
       SMEAN          = 0.
       QLFOLD         = 0.
       EPSGMAX        = 0.
+      iIgnoreK       = 0
+      OPAKNOFENOTHO  = 0.
+      OPAKNOFENOTHO  = 0.
  
       QOPAHMEAN      = 0.
       HMEAN          = 0.
       QLHOLD         = 0.
       OPAKHOLD       = 0.
  
+      XJLMO          = 0.
+      XJLMOR2        = 0. 
+      
+      XLAMLASTOSKIP  = 0.
+      DO L=1, NDDIM
+        bOSKIPLAST(L) = .FALSE.
+      ENDDO
+ 
       XJLOLD         = 0.
       XJLMO_OLD      = 0.
       EDDIFO         = 0.
@@ -149,17 +215,49 @@
       WFELOW         = 0.
       WFENUP         = 0.
 
-      LIND           = 0.
-      LINDS          = 0.
+      LIND           = 0
+      LINDS          = 0
       WS             = 0.
-      BLASERL        = .FALSE.
+      DO IND=1, MAXIND
+        BLASERL(IND) = .FALSE.
+      ENDDO
 
       OPAMAX1        = 0.
       OPAMAX1_LAMBDA = 0.
       IOPAMAX1_K     = 0
 
       EMCOLI         = 0.
+      OPAROSSELEM      = 0.
+      OPAROSSCONT    = 0.
+      OPAKFEOLD      = 0.
+      OPAKFEFTOLD    = 0.
+      ETAKFEFTOLD    = 0.
+
+      OPACELEM       = 0.
+      OPACOLDELEM    = 0.
+      OPAKELEM       = 0.
+      OPAKOLDELEM    = 0.
+      ETACELEM       = 0.
+      ETACOLDELEM    = 0.
+      ETAKELEM       = 0.
+      ETAKOLDELEM    = 0.
+      
+      OPATOTELEM     = 0.
+      
+      ARADELEM       = 0.
+      ACONTELEM      = 0.
+
+      OPACION       = 0.
+      OPACOLDION    = 0.
+      OPAKION       = 0.
+      OPAKOLDION    = 0.
+      ETACION       = 0.
+      ETACOLDION    = 0.
+      ETAKION       = 0.
+      ETAKOLDION    = 0.
       
+      ARADION       = 0.
+      ACONTION      = 0.
 
       RETURN
       END
diff -bur ./coliwm.f ../../powr-refactor/src/coliwm.f
--- ./coliwm.f	2024-07-28 13:13:07.000000000 +0200
+++ ../../powr-refactor/src/coliwm.f	2023-11-21 10:10:55.281269770 +0100
@@ -1,21 +1,15 @@
       SUBROUTINE COLIWM(Z, P, R, ND, NP, 
      >                  CWM0, CWM1, CWM2, CWM3, 
-     >                  CWM1O, CWM1I, CWM3O, CWM3I, 
      >                  BSHORT_CHAR)
 
       DIMENSION Z(ND,NP), P(NP), R(ND)
       DIMENSION CWM0(ND,NP), CWM2(ND,NP)
       DIMENSION CWM1(ND,NP), CWM3(ND,NP)
-      DIMENSION CWM1O(NP), CWM1I(NP), CWM3O(NP), CWM3I(NP)
       LOGICAL BNONCORE, BSHORT_CHAR
 
 C***  Initialisation
       DO JP=1, NP
          LMAX=MIN0(NP+1-JP,ND+1)
-         CWM1O(JP) = 0.
-         CWM3O(JP) = 0.
-         CWM1I(JP) = 0.
-         CWM3I(JP) = 0.
          DO L=1, LMAX-1
             CWM0(L,JP) = 0.
             CWM2(L,JP) = 0.
@@ -108,63 +102,6 @@
          ENDDO
       ENDDO
 
-C***  1. und 3. moment at the outer boundary
-      DO JP=1, NP-1
-        A  = Z(1,JP)
-        B  = Z(1,JP+1)
-        AA = A*A
-        BB = B*B
-        AAA= A*AA
-        BBB= B*BB
-C***   Factors for Radius L=1
-        WF1 = 1.
-        WF3 = 1./R(1)/R(1)
-C***   Weights for Interval [JP, JP+1]
-        W1A = WF1/6.*(A-B)*(2.*A + B)
-        W1B = WF1/6.*(A-B)*(A + 2.*B)
-        W3A = WF3/20.*(A-B)*(4.*AAA + 3.*AA*B + 2.*A*BB + BBB)
-        W3B = WF3/20.*(A-B)*(AAA + 2.*AA*B + 3.*A*BB + 4.*BBB)
-C***   Second Order at the inner Boundary
-        IF (JP .EQ. NP-1) THEN
-           W1A = WF1/3.*AA
-           W1B = 0.
-           W3A = WF3/5.*A*AAA
-           W3B = 0.
-        ENDIF
-C***   Add up Weights
-        CWM1O(JP)  = CWM1O(JP)  + W1A
-        CWM1O(JP+1)= CWM1O(JP+1)+ W1B
-        CWM3O(JP)  = CWM3O(JP)  + W3A
-        CWM3O(JP+1)= CWM3O(JP+1)+ W3B
-      ENDDO
-
-C***  1. und 3. moment at the inner boundary
-      DO JP=1, NP-ND
-        A  = Z(ND,JP)
-        B  = Z(ND,JP+1)
-        AA = A*A
-        BB = B*B
-        AAA= A*AA
-        BBB= B*BB
-C***   Factors for Radius L=1 are 1.
-C***   Weights for Interval [JP, JP+1]
-        W1A = 1./6.*(A-B)*(2.*A + B)
-        W1B = 1./6.*(A-B)*(A + 2.*B)
-        W3A = 1./20.*(A-B)*(4.*AAA + 3.*AA*B + 2.*A*BB + BBB)
-        W3B = 1./20.*(A-B)*(AAA + 2.*AA*B + 3.*A*BB + 4.*BBB)
-C***   Second Order at the inner Boundary
-        IF (JP .EQ. NP-ND) THEN
-           W1A = 1./3.*AA
-           W1B = 1./6.*AA
-           W3A = 1./5.*A*AAA
-           W3B = 1./20.*A*AAA
-        ENDIF
-C***   Add up Weights
-        CWM1I(JP)  = CWM1I(JP)  + W1A
-        CWM1I(JP+1)= CWM1I(JP+1)+ W1B
-        CWM3I(JP)  = CWM3I(JP)  + W3A
-        CWM3I(JP+1)= CWM3I(JP+1)+ W3B
-      ENDDO
       ENDIF
 C***  End of COLIRAY-Version
 
@@ -190,9 +127,17 @@
 C***   Second Order at the inner Boundary
           IF (JP .EQ. NP-L) THEN
              W1A = WF1/3.*AA
-             W1B = WF1/6.*AA          
+             IF (L == ND) THEN
+               W1B = WF1/6.*AA          !suggested change! => extreme influence on fHNDCOR
+             ELSE
+               W1B = 0.
+             ENDIF
              W3A = WF3/5.*A*AAA
-             W3B = WF3/20.*A*AAA      
+             IF (L == ND) THEN
+               W3B = WF3/20.*A*AAA      !suggested change!
+             ELSE
+               W3B = 0.                  
+             ENDIF
           ENDIF
 C***   Add up Weights
           CWM1(L,JP)  = CWM1(L,JP)  + W1A
diff -bur ./colli.f ../../powr-refactor/src/colli.f
--- ./colli.f	2024-07-28 13:13:07.000000000 +0200
+++ ../../powr-refactor/src/colli.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,7 +1,7 @@
       SUBROUTINE COLLI(NDIM,N,ENLTE,TL,ENE,NCHARG,ELEVEL,EINST,CRATE,
      $                 EION,COCO,KEYCBB,WEIGHT,ALTESUM,NATOM,NOM,KODAT,
      $                 INDNUP,INDLOW,LASTIND, LASTINDAUTO, LASTINDALL,
-     $                 KONTNUP,KONTLOW,LASTKON,KEYCBF,IONGRND)
+     $                 KONTNUP,KONTLOW,LASTKON,KEYCBF,IONGRND,MAXATOM)
 C*******************************************************************************
 C***  COLLISIONAL TRANSITION RATES STORED IN MATRIX CRATE **********************
 C***  BOUND-BOUND: DEPENDING ON THE ELEMENT (HE, H, N, C, O)
@@ -13,18 +13,19 @@
 C***  3) STEAL - LINPOP - LTEPOP - COMA      (for rate equations)
 C*******************************************************************************
  
-      DIMENSION EINST(NDIM,NDIM),CRATE(NDIM,NDIM)
-      DIMENSION ENLTE(NDIM),NCHARG(NDIM),ELEVEL(NDIM),WEIGHT(NDIM)
-      DIMENSION EION(NDIM),ALTESUM(4,NDIM)
-      DIMENSION IONGRND(NDIM)
-      DIMENSION INDNUP(LASTIND),INDLOW(LASTIND)
-      DIMENSION KONTNUP(LASTKON),KONTLOW(LASTKON)
+      INTEGER, INTENT(IN) :: NDIM, LASTIND, LASTKON, MAXATOM
+      REAL, DIMENSION(NDIM, NDIM) :: EINST, CRATE
+      REAL, DIMENSION(NDIM) :: ENLTE, ELEVEL, WEIGHT, EION
+      INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND
+      REAL, DIMENSION(4, NDIM) :: ALTESUM
+      INTEGER, DIMENSION(LASTIND) :: INDNUP, INDLOW
+      INTEGER, DIMENSION(LASTKON) :: KONTNUP, KONTLOW
 C***  ARRAY "KEYCBF" IS PROVIDED FOR FUTURE TESTS OF DIFFERENT COLLISIONAL
 C***  IONIZATION FORMULAES:
       DIMENSION KEYCBF(LASTKON)
-      DIMENSION NOM(N)
-      DIMENSION KODAT(NATOM)
-      CHARACTER*4 KEYCBB(LASTIND)
+      INTEGER, DIMENSION(N) :: NOM
+      INTEGER, DIMENSION(MAXATOM) :: KODAT
+      CHARACTER(4), DIMENSION(LASTIND) :: KEYCBB
 
 C***  SUPPRESS REPETITIVE WARNING OF NEGATIVE CROSS SECTIONS
       DATA CBBWARN / 0. /
@@ -36,10 +37,11 @@
       T32=TL*TROOT
  
 C***  INITIALIZE ALL ELEMENTS OF MATRIX "CRATE":
-      DO 1 J=1,N
-      DO 1 I=1,N
+      DO J=1,N
+        DO I=1,N
       CRATE(I,J)=.0
-    1 CONTINUE
+        ENDDO
+      ENDDO
  
 C***  LINE TRANSITIONS  *******************************************************
       DO 11 IND=1,LASTINDALL
@@ -116,7 +118,7 @@
    11 CONTINUE
 
 C***  This is a modification added 24-Aug-2010 by helge + wrh
-C***  - see WR-Memo 100825.txt
+C***  - see WR-Memo 20100826.txt
 C***  Here we assign a collisonal rate coefficient for those superlines 
 C***  which have ZERO radiative cross-section and were therefore
 C***  skipped in the index numbering (i.e. no call of CBBFE occured)
@@ -173,6 +175,7 @@
          NUP=IONGRND(LOW)
          EDGE=ELEVEL(NUP)+EION(LOW)-ELEVEL(LOW)
          X=1000./TL
+         EXPFAC=EXP(-C1*EDGE/TL)
          FOFT=(ALTESUM(3,LOW)*X+ALTESUM(2,LOW))*X
          FOFT=10.**FOFT
          AOFT=ALTESUM(1,LOW)*FOFT
diff -bur ./coma.f ../../powr-refactor/src/coma.f
--- ./coma.f	2024-07-28 13:13:08.000000000 +0200
+++ ../../powr-refactor/src/coma.f	2023-09-27 10:14:15.101755421 +0200
@@ -4,9 +4,9 @@
      $      INDNUP,NOM,NATOM,KODAT,NFIRST,NLAST,PHI,PWEIGHT,DELTAX,XMAX,
      $      NFL,OPAC,SCNEW,DOPA,DETA,OPAL,SLNEW,DOPAL,DETAL,SIGMAKI,
      $      ETAC,NFEDGE,EXPFAC,SCOLIND,SCNEIND,OPACIND,SIGMAFF,MAXION,
-     $      NOTEMP,TLOLD,KONTLOW,KONTNUP,LASTKON,RUDLINE,IONGRND,
-     $      XRED,XBLUE,WCHARM,EN,RSTAR,SCOLD,XJCAPP,VDOP,COCO,
-     $      KEYCBB, NRB_CONT, ZERO_RATES, POPMIN, 
+     $      NOTEMP,TLxj,TLOLD,KONTLOW,KONTNUP,LASTKON,RUDLINE,IONGRND,
+     $      XRED,XBLUE,WCHARM,EN,RSTAR,SCOLD,XJCAPP,VDOPDD,VDOPUNIT,
+     >      COCO,KEYCBB, NRB_CONT, ZERO_RATES, POPMIN, 
      $      IONAUTO,NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,DRRATEN,
      $      RDIEL,RAUTO,DRJLW,DRJLWE,DRLJW,IBLENDS,MAXLAP,XLAMZERO,
      $      KODRNUP,KODRLOW,LASTKDR,KEYCBF, OPALOLD,
@@ -15,6 +15,7 @@
      $      XJCLP1, OPAC1, RADIUS, ITNEL, TEFF, OPATHOM, 
      $      LASTINDAUTO, LASTIND, KRUDAUT, LEVEL, 
      >   WFELOW, WFENUP, EN1, BDIAG,  
+     >      XLAMAPPMEAN, bLAMAPPCOLI, bUSEALO,
      >   FERATLU, FERATUL, LASTFE, FERATLU0, FERATUL0, 
 C*** Quantities for fine-frequency grid 
      >   SFINE_OLD, SFINE_NEW, MAXFINE, KONTHLP, MAXIND, XKC, XKC2,
@@ -36,13 +37,13 @@
      >   BPLOTAPP, PWEIGHTCL, WS, FWTEST, 
      >   IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP, 
      >   XJCAPPNEW, XJLAPPNEW, 
-     >   GAMMAC, GAMMAL, GAMMAR, 
-     >   XLAM_FINE_START, XLAM_FINE_END, IMAXPOP, bBLOCKINVERSION,
+     >   GAMMAC, GAMMAL, GAMMAR, GAMMAD,
+     >   XLAM_FINE_START, XLAM_FINE_END, IMAXPOP, iBLOCKINVERSION,
 C***  New Fine-spaced WCHARM handling
      >   IFF_MAX, IFF_MAX_MS, FF_INFO, IFF_DK, IFF_WCHARM, WCHARM_FINE, 
      >   IFF_N_MS, bFFASSET,
 C***  FERAT correction     
-     >   CORRS, DEXFAC, bFeTCORR)
+     >   bFRACINV, CORRS, DEXFAC, bFeTCORR, iZRType)
 C*******************************************************************************
 C***  THIS ROUTINE SETS UP THE RATE COEFFICIENT MATRIX RATCO
 C***  AND ITS VECTOR DERIVATIVE DM (LINEARIZED MATRIX)
@@ -51,10 +52,11 @@
 C*******************************************************************************
 
       INTEGER, INTENT(IN) :: NDIM, NRANK, LASTKDR, LASTFE, LASTIND, 
-     >                       LASTINDALL, ND, NF, N, NATOM, MAXATOM
+     >                       LASTINDAUTO, LASTINDALL, ND, NF, N, 
+     >                       NATOM, MAXATOM
 
       REAL, DIMENSION(NDIM,NDIM) :: CRATE, RRATE
-      REAL, DIMENSION(NDIM) :: RDIEL, RAUTO, ELEVEL
+      REAL, DIMENSION(NDIM) :: ENLTE, ELEVEL, WEIGHT, RDIEL, RAUTO
       INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND
       REAL, DIMENSION(NRANK,NRANK) :: RATCO, DM
       REAL, DIMENSION(NRANK) :: EN, V1
@@ -64,22 +66,29 @@
       INTEGER, DIMENSION(MAXATOM) :: KODAT
       REAL, DIMENSION(ND,NF) :: XJC 
       REAL, DIMENSION(NF) :: XJCAPP
+      REAL, DIMENSION(ND,LASTINDAUTO) :: XLAMAPPMEAN
       INTEGER, DIMENSION(MAXIND) :: INDLOW, INDNUP
       REAL, DIMENSION(MAXIND) :: DEXFAC
-      REAL, DIMENSION(LASTFE) :: FERATLU, FERATUL, FERATLU0, FERATUL0
-      LOGICAL :: NOTEMP, BROYDEN, BFIRSTITER, BFERATE, bBLOCKINVERSION, 
+      DIMENSION FERATLU(LASTFE), FERATUL(LASTFE)
+      DIMENSION FERATLU0(LASTFE), FERATUL0(LASTFE)
+      REAL, DIMENSION(ND, LASTIND) :: WFELOW, WFENUP
+      REAL, DIMENSION(ND, NATOM), INTENT(IN) :: VDOPDD
+
+      
+      LOGICAL :: NOTEMP, BROYDEN, BFIRSTITER, BFERATE, bFRACINV,
      >           bFFASSET, BXJLAPPNEW, BXJCAPPNEW, BNEWOPER, BPLOTAPP, 
-     >           bFeTCORR
+     >           bFeTCORR, bLAMAPPCOLI
       CHARACTER(8) :: NAME
       LOGICAL, DIMENSION(LASTKON) :: NRB_CONT 
       LOGICAL, DIMENSION(N, ND) :: ZERO_RATES
       LOGICAL, DIMENSION(MAXIND) :: BDIAG
+      LOGICAL, DIMENSION(LASTINDAUTO) :: bUSEALO
       REAL, DIMENSION(ND) :: CORRS
 
 C*** for test output
       CHARACTER(10), DIMENSION(NDIM) :: LEVEL
-      
-      REAL :: CORRT, WAV0
+      REAL :: GAMMAD, CORRT, VDOPUNIT, WAV0
+      INTEGER :: iBLOCKINVERSION, iZRType
       
       REAL, PARAMETER :: C1 = 1.4388  !C1 = H * C / K    (CM * KELVIN)
 
@@ -104,16 +113,33 @@
 
 C***  CALCULATE NEW CONT. SOURCE FUNCTION AND SCHARMER'S RADIATION FIELD
       CALL SETXJC (XJCAPP,XJC,OPAC,ETAC,SCNEW,SCOLD,WCHARM,
-     $             XLAMBDA,L,NF,ND,TL,TLOLD,NOTEMP)
+     $             XLAMBDA,L,NF,ND,TL,TLxj,NOTEMP)
+c     $             XLAMBDA,L,NF,ND,TL,TLOLD,NOTEMP)
 
 C***  CALCULATE LINE RADIATION FIELD WITH APPROXIMATE LAMBDA OPERATOR TERMS
-      CALL SETXJL (LASTIND,INDLOW,INDNUP,XRED,XBLUE,OPACIND,
+      IF (bLAMAPPCOLI) THEN
+C***    Use XLAMAPPMEAN from COLI->FREQUINT
+        CALL SETXJL (ITNEL, LASTIND, INDLOW, INDNUP, bUSEALO,
+     >               SLNEW, SLOLD, OPAL, OPALOLD, XJLAPP, BDIAG,
+     >               NBLENDS, IBLENDS, MAXLAP, LASTINDAUTO, NDIM, ND,
+     >               EINST, RUDLINE, ELEVEL, EN, EN1, WEIGHT,
+     >               NATOM, XJL, XLAMAPPMEAN, XLAMZERO, RSTAR,
+     >               XJC, XJCAPP, XLAMBDA, NF, L, TL, TLxj, 
+c     >               XJC, XJCAPP, XLAMBDA, NF, L, TL, TLOLD, 
+     >               NOTEMP, ENTOTL, VDOPUNIT, KRUDAUT, MAXAUTO, 
+     >               WFELOW, WFENUP, SCNEW, SCOLIND, SCNEIND, POPMIN)
+     
+      ELSE 
+C***    Use "core fraction" method  (standard until Mar-2017)    
+        CALL SETXJLCF (LASTIND,INDLOW,INDNUP,XRED,XBLUE,OPACIND,
      $             SCNEIND,SCOLIND,SLNEW,SLOLD,OPAL,XJLAPP,
      $             NF,XLAMBDA,SCNEW,OPAC,OPALOLD,ITNEL,LASTINDAUTO,
      $             NFL,PHI,PWEIGHT,NDIM,EINST,ELEVEL,EN,WEIGHT,ND,XJL,
-     $             ENTOTL,RSTAR,VDOP,DELTAX,XMAX,L,TL,TLOLD,NOTEMP,
-     $             IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,ATEST,NBLENDS,
-     $             KRUDAUT,MAXAUTO,WFELOW,WFENUP,EN1,BDIAG)
+     $             ENTOTL,RSTAR,VDOPUNIT,DELTAX,XMAX,L,TL,TLxj,
+c     $             ENTOTL,RSTAR,VDOPUNIT,DELTAX,XMAX,L,TL,TLOLD,
+     >             NOTEMP,IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,
+     >             NBLENDS,KRUDAUT,MAXAUTO,WFELOW,WFENUP,EN1,BDIAG)
+      ENDIF
 
       IF (BPLOTAPP .AND. ITNEL .EQ. NITER_PLOT_JAPP) THEN
         CALL PREPLOTAPP(ND, NF, L,
@@ -130,7 +156,7 @@
      >    ((BXJLAPPNEW .AND. (GAMMAL .GT. 0. .OR. GAMMAR .GT. 0.)) .OR.
      >     (BXJCAPPNEW .AND. GAMMAC .GT. 0.)) ) THEN
         CALL SETXJFINE (SFINE_OLD, SFINE_NEW, MAXFINE, ITNEL, L, 
-     >                 ND, NDDIM, NDIM, N, VDOP, VELO1, 
+     >                 ND, NDDIM, NDIM, N, VDOPUNIT, VELO1, 
      >                 ENTOTL, EN, RSTAR, TL, RNEL, NCHARG, 
      >                 WEIGHT, ELEVEL, EION, EINST, NATOM, 
      >                 KONTHLP, MAXIND, BXJLAPPCORE,
@@ -184,8 +210,8 @@
 C***  SETUP THE COLLISIONAL AND RADIATIVE RATE COEFFICIENTS
       CALL COLLI (NDIM,N,ENLTE,TL,ENE,NCHARG,ELEVEL,EINST,CRATE,
      $            EION,COCO,KEYCBB,WEIGHT,ALTESUM,NATOM,NOM,KODAT,
-     $            INDNUP, INDLOW, LASTIND, LASTINDAUTO, LASTINDALL, 
-     $            KONTNUP, KONTLOW, LASTKON, KEYCBF, IONGRND)
+     $            INDNUP,INDLOW,LASTIND, LASTINDAUTO, LASTINDALL,
+     >            KONTNUP,KONTLOW,LASTKON,KEYCBF,IONGRND, MAXATOM)
 C***  RADIATIVE RATES ARE CALCULATED WITH THE MODIFIED RADIATION FIELD
 C***  NOTE THAT THE ARRAYS XJCAPP AND XJLAPP ARE ONE-DIMENSIONAL :
       CALL RADNET(NDIM,N,ENLTE,TL,WEIGHT,NCHARG,EION,ELEVEL,EINST,
@@ -195,8 +221,8 @@
      $            DRRATEN,RDIEL,RAUTO,DRJLW,DRJLWE,DRLJW,
      $            INDNUP,INDLOW,LASTIND,KONTNUP,KONTLOW,LASTKON,
      $            NFEDGE,NATOM,MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-     $            NFIRST,NLAST,KRUDAUT, L, ND, NRB_CONT, 
-     >            EXPFAC, WCHARM)
+     $            NFIRST,NLAST, KRUDAUT, L, ND, NRB_CONT, 
+     >            EXPFAC, WCHARM, MAXION)
  
 C***  THE RADIATIVE RATES FOR THE IRON SUPERLINES ARE PRE-CALCULATED
 C***      IN PROGRAM COLI AND NOW READ FROM THE MODEL FILE.
@@ -303,55 +329,22 @@
       DO 9 J=1,NRANK
     9 V1(J)=.0
  
+
+C***  Handling of small popnumbers: change RATCO and V1
+      CALL POPSMALL(L, ND, N, POPMIN, BFIRSTITER, ZERO_RATES, IMAXPOP,
+     >              NATOM, NFIRST, NLAST, EN, NRANK,
+     >              NCHARG, RATCO, V1, ITNEL, TL, KODAT, LEVEL,
+     >              MAXATOM, ABXYZ, iZRType)
+
 C***  COLUMN IMAXPOP (I.E. INDEX OF MAX. POPNUMBER PER ELEMENT):
 C***         NUMBER CONSERVATION FOR EACH ELEMENT (NA)
 C***  REMARK: TOTAL NUMBER CONSERVATION IS IMPLICITLY ENSURED
-
-      DO 23 NA=1,NATOM
-         NFIRNA=NFIRST(NA)
-         NLANA=NLAST(NA)
-
-C***     Check if all Rate Coefficients in one column are non-zero
-C***     (otherwise: the matrix is singular!)
-C***     and store logical flag ZERO_RATES for later use 
-         IF (ITNEL .EQ. 1) THEN  
-            CALL FLAG_ZERORATES(NFIRNA, NLANA, RATCO, NRANK,
-     >                       IMAXPOP(NA), EN, POPMIN, ZERO_RATES(1,L))
-C***        new, wrh 25-Feb-2015:
-C***        in case of iron, levels MUST be popmin if they are also flagged
-C***        at the next-inner depth point 
-cc            IF (NA .EQ. KODAT(26) .AND. L .LT. ND) THEN
-            IF (L .LT. ND) THEN
-               DO J=NFIRNA, NLANA
-                  IF (ZERO_RATES(J,L+1)) THEN
-                     DO LL=L, 1, -1
-                        ZERO_RATES(J,LL)=.TRUE.
-                     ENDDO
-                  ENDIF
-               ENDDO
-            ENDIF
-         ENDIF
-
-         DO 22 I=NFIRNA,NLANA
-   22    RATCO(I,IMAXPOP(NA))=1.
-
-         V1(IMAXPOP(NA))=ABXYZ(NA)
-
-
-C***     If ZERO_RATES: Replace diagonal element by 1.0
-C***     and the rest of this column by 0.0
-         DO J = NFIRNA, NLANA
-            IF (.NOT. ZERO_RATES(J,L)) CYCLE
-            DO I = NFIRNA, NLANA
-               RATCO(I,J) = .0
-               RATCO(J,I) = .0
-            ENDDO
-            RATCO(J,J) = 1.
-            V1(J) = POPMIN
-            EN(J) = POPMIN
-         ENDDO
-   23 CONTINUE
-C***  End-of-loop over all elements
+c      DO NA=1, NATOM
+c         DO I=NFIRST(NA), NLAST(NA)
+c           RATCO(I,IMAXPOP(NA))=1.
+c         ENDDO
+c         V1(IMAXPOP(NA))=ABXYZ(NA)
+c      ENDDO
 
 C***  COLUMN N+1 : CHARGE CONSERVATION
       DO 4 I=1,N
@@ -384,24 +377,33 @@
      $                  WCHARM,ND,L,NFEDGE,EXPFAC,NDIM,N,NCHARG,WEIGHT,
      $                  ELEVEL,EION,EINST,SIGMAKI, KONTLOW,
      $                  KONTNUP,LASTKON,SIGMAFF,MAXION,NOM,KODAT,
-     $                  SIGMATHK,SEXPOK,EDGEK,MAXATOM,bBLOCKINVERSION)
+     $                  SIGMATHK,SEXPOK,EDGEK,MAXATOM,iBLOCKINVERSION)
 C***  CONSTRUCT DERIVATIVE VECTORS DOPAL, DETAL (LINES) WITH RESPECT TO EN(I)
-      CALL       DLIOP (I,ENTOTL,DOPAL,DETAL,XRED,XBLUE,VDOP,RSTAR,N,
-     $            NDIM,EINST,WEIGHT,ELEVEL,LASTIND,INDLOW,INDNUP,EN)
+      CALL       DLIOP (I,ENTOTL,DOPAL,DETAL,XRED,XBLUE,VDOPUNIT,RSTAR,
+     >                  N,NDIM,EINST,WEIGHT,ELEVEL,LASTIND,
+     >                  INDLOW,INDNUP,EN,
+     >                  LASTINDAUTO,bLAMAPPCOLI,bUSEALO,iBLOCKINVERSION)
  
 C***  COMPUTE DERIVATIVE MATRIX DM 
       CALL DERIV (DM,NRANK,I,NPLUS1,EN,CRATE,RRATE,EXPFAC,NFEDGE,
      $      WCHARM,ND,L,ENLTE,PHI,PWEIGHT,NFL,DELTAX,XMAX,
-     $      XRED,XBLUE,DETAL,DOPAL,SLNEW,OPAL,XJLAPP,XJCAPP,
-     $      FWEIGHT,DOPA,DETA,OPAC,SCNEW,XLAMBDA,NF,SCNEIND,OPACIND,
-     $      NDIM,N,EINST,SIGMAKI,RUDLINE,
-     $      LASTIND,INDLOW,INDNUP,KONTLOW,KONTNUP,LASTKON,
-     $      IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,VDOP,ATEST,BTEST,
+     $      XRED,XBLUE,DETAL,DOPAL,SLNEW,OPAL,XJLAPP,XJCAPP,FWEIGHT,
+     $      DOPA,DETA,OPAC,SCNEW,XLAMBDA,NF,SCNEIND,OPACIND, NDIM,N,
+     $      EINST,SIGMAKI,RUDLINE, bLAMAPPCOLI, XLAMAPPMEAN, bUSEALO,
+     >      LASTIND,LASTINDAUTO,INDLOW,INDNUP,KONTLOW,KONTNUP,LASTKON,
+     $      IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,VDOPUNIT,
+     >      ATEST,BTEST,
      $      RDIEL,IONGRND,KODRLOW,LASTKDR,WFELOW,WFENUP,BDIAG,WEIGHT, 
-     >      ELEVEL, NRB_CONT, TL, ENE, NOM, bBLOCKINVERSION)
+     >      ELEVEL, NRB_CONT, TL, ENE, NOM, NCHARG, DEXFAC,
+     >      iBLOCKINVERSION)
 
    10 CONTINUE
  
+C***      Optional: Invert DM for fractional corrections 
+      IF (bFRACINV) THEN
+        CALL SCALEDM(DM, EN, NRANK, .FALSE.)
+      ENDIF
+
 C***  COLUMNS IMAXPOP (I.E. COLUMNS CONTAINING THE EQUATIONS OF NUMBER
 C***  CONSERVATION FOR ELEMENT NA)  ARE NOT CHANGED
       DO 99 NA=1,NATOM
@@ -412,6 +414,7 @@
 C***  COLUMNS WITH (almost) ZERO RATES ARE REPLACED BY THE EQUATION 
 C***      n(j) * 1 = .0
  
+      IF (iZRType /= 2) THEN
       DO J=1, N
          IF (.NOT. ZERO_RATES(J,L)) CYCLE
          DO I=1,NRANK
@@ -422,6 +425,7 @@
 cc     >    'ZERO_RATES at IT=', itnel, '  LEVEL=', LEVEL(J), 
 cc     >     ' POPNUM=', EN(J)
       ENDDO
+      ENDIF
 
 ccc   test output
 cc      if (itnel .eq. 1 .and. l .eq. 17) then
Only in ../../powr-refactor/src/: como.exe
Only in ../../powr-refactor/src/: como.exe.opt
diff -bur ./como.f ../../powr-refactor/src/como.f
--- ./como.f	2024-07-28 13:13:08.000000000 +0200
+++ ../../powr-refactor/src/como.f	2023-09-27 10:14:15.101755421 +0200
@@ -15,15 +15,18 @@
       INTEGER, PARAMETER :: NDIM     =        2560 
       INTEGER, PARAMETER :: NFDIM    = 2*NDIM + 400 
       INTEGER, PARAMETER :: MAXIND   =       45000 
-      INTEGER, PARAMETER :: MAXFEIND =        1500 
+      INTEGER, PARAMETER :: MAXFEIND =        2500 
       INTEGER, PARAMETER :: MAXKONT  =     NFDIM/2 
+      INTEGER, PARAMETER :: MAXKODR  =        NDIM 
       INTEGER, PARAMETER :: NDDIM    =          89 
       INTEGER, PARAMETER :: MAXHIST  =        4000 
       INTEGER, PARAMETER :: MAXXDAT  =          10 
        
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR
+      INTEGER, PARAMETER :: MAXION = 27 
  
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      INTEGER, PARAMETER :: MAXAUTO  = 2850 
+      INTEGER, PARAMETER :: MAXAUTO  = 3200 
 
       REAL, DIMENSION(NFDIM) :: XLAMBDA
       INTEGER :: NF, ND, N, LASTKON, LASTIND, LAST, LASTFE
@@ -60,9 +63,9 @@
 
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
 C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl / hydro
 
       REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
@@ -74,7 +77,7 @@
       LOGICAL BFEMODEL, BPLOTRTAU1
 
       REAL, DIMENSION(MAXXDAT) :: XDATA
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
 
       CHARACTER(255) :: HISTENTRY
       CHARACTER(100) :: MODHEAD
@@ -91,13 +94,13 @@
       CHARACTER(80), DIMENSION(NPLOTOPADIM) :: OPTIONPLOTOPA
 
       REAL :: RSTAR, RMAX, TAUBMAX, DTDR, OPARND, TEFF, KV, TAUB,
-     >        XLAM0FE, DXFE, VDOPFE, OPAMAX, RMAXGOOD, DUMMY
+     >        XLAM0FE, DXFE, VDOPFE, OPAMAX, RMAXGOOD, DUMMY, POPMIN
       INTEGER L, K, KBWARN1, KBWARN2, KBWARN3, IWARNJN, 
      >        NPLOTOPA, LPLOHTOT, LSHTOT, LSINT, LSOPA,
      >        JOBNUM, NATOM, NAUTO, KBMAX, IDUMMY, IERR, 
      >        N_WITH_DRLEVELS
       
-      LOGICAL :: NOTEMP, BUNLU, BKUDRITZKI 
+      LOGICAL :: NOTEMP, BUNLU, BKUDRITZKI, bNoARAD, bCLXJC
 
 C***  Depth dependent Clumping
 c***  nach goetz
@@ -133,11 +136,11 @@
 
       CALL INSTALL
 
-c      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
-c        CALL CLOCK(TIM1)
-c      ELSE
-c        CALL TIME(TIM1)
-c      ENDIF
+      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+        CALL CLOCK(TIM1)
+      ELSE
+        CALL TIME(TIM1)
+      ENDIF
 
 C***  READING THE ATOMIC DATA FROM FILE DATOM
       CALL DATOM (NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,MAINQN,
@@ -155,23 +158,31 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
 C***  READING OF THE MODEL FILE ****************************************
       CALL       REMOCO (ND, NDDIM, RADIUS, ENTOT, T, RNE, NF, NFDIM,
-     $                  XLAMBDA, FWEIGHT, KEY, XJC, 
+     $                  XLAMBDA, FWEIGHT, KEY, XJC, bNoARAD,
      $                  N, POPNUM, RSTAR,
      $                  MODHEAD, LAST, MAXHIST, MODHIST, JOBNUM,
      $                  NOTEMP, TEFF, HEDDI, EDDI, MAXXDAT, XDATA, 
-     >                  DENSCON, FILLFAC, OPARND, ABXYZ, NATOM, 
-     >                  ZERO_RATES, NDIM)
+     >                  DENSCON, FILLFAC, OPARND,
+     >                  ABXYZ, NATOM, POPMIN, ZERO_RATES, NDIM)
       WRITE(hCPR,'(A,I7)') '>>> This is job number ', JOBNUM
 
-      CALL POPMIN_NULLING (ZERO_RATES, POPNUM, ND, N)
+      CALL POPMIN_NULLING (ZERO_RATES, POPNUM, POPMIN, ND, N)
 
 C***  DECODING INPUT OPTIONS *******************************************
+      BKUDRITZKI = .FALSE.
       CALL DECOMO (LSOPA, LSINT, NOTEMP, LSHTOT, LPLOHTOT, MODHIST, 
-     >       BUNLU, BPLOTRTAU1, NPLOTOPA, OPTIONPLOTOPA, NPLOTOPADIM)
+     >             BUNLU, BPLOTRTAU1, BKUDRITZKI, NPLOTOPA, 
+     >             OPTIONPLOTOPA, NPLOTOPADIM, bCLXJC, POPMIN)
+
+      IF (JOBNUM .EQ. 3 .AND. BKUDRITZKI) THEN
+        NOTEMP =.TRUE.
+      ELSE
+        NOTEMP = .FALSE.
+      ENDIF
 
 C***  logical NOTEMP is obsolete, as it is always .FALSE.
       NOTEMP = .FALSE.
@@ -185,8 +196,8 @@
  
 C***  CALCULATE TEMPERATURE GRADIENT "DTDR" AT INNER BOUNDARY
       CALL DIFDTDR(DTDR,TEFF,XJC,HEDDI,T(ND),RADIUS(ND),ND,EN,POPNUM,
-     $             RNE(ND),ENTOT(ND),RSTAR,NDIM,N,LEVEL,NCHARG,WEIGHT,
-     $             ELEVEL,EION,EINST,ALPHA,SEXPO,
+     $             POPMIN,RNE(ND),ENTOT(ND),RSTAR,NDIM,N,LEVEL,
+     >             NCHARG,WEIGHT,ELEVEL,EION,EINST,ALPHA,SEXPO,
      $             ADDCON1, ADDCON2, ADDCON3, 
      $             IGAUNT,NOM,NF,
      $             XLAMBDA,FWEIGHT,
@@ -216,7 +227,7 @@
 
         KV=1+ND*(K-1)
  
-        CALL COOP (XLAMBDA(K),ND,T,RNE,POPNUM,ENTOT,RSTAR,
+        CALL COOP (XLAMBDA(K),ND,T,RNE,POPNUM,POPMIN,ENTOT,RSTAR,
      >             OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,
      >             NOM,KODAT,NDIM,N,MAXATOM,
      >             LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
@@ -246,7 +257,8 @@
           IF (IERR == -10) THEN
             !If no EDDI values are there MOMO will crash => STOP here
             WRITE (hCPR,*) '*** MODEL DOES NOT CONTAIN EDDI[K] VALUES'
-            WRITE (hCPR,*) '*** Try starting with COLI or new WRSTART'
+            WRITE (hCPR,*) '*** Try starting with WRCONT, COLI, ' //
+     >          'or new WRSTART'
             STOP 'FATAL ERROR in COMO'
           ENDIF
         ENDIF
@@ -296,8 +308,10 @@
         ENDIF
 
 C***    UPDATING THE CONTINUOUS RADIATION FIELD ON THE MODEL FILE
+        IF (bNoARAD .OR. (.NOT. bCLXJC)) THEN
         WRITE (UNIT=NAME, FMT='(A3,I4)') 'XJC',K
         CALL WRITMS(hMODEL,XJC(KV,1),ND,NAME,-1, IDUMMY, IERR)
+        ENDIF
 
       ENDDO
 C***  ENDLOOP  ---------------------------------------------------------
@@ -360,7 +374,7 @@
      $           LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
      $           SIGMATHK,SEXPOK,EDGEK,
      $           K,NF,SIGMAKI,RADIUS,
-     $           KONTNUP,KONTLOW,LASTKON,XDATA)
+     $           KONTNUP,KONTLOW,LASTKON,XDATA,POPMIN)
 
       !write model history entry into explicit history file
       CALL GETHISTENTRY(HISTENTRY,JOBNUM,MODHIST,MAXHIST)
diff -bur ./coop.f ../../powr-refactor/src/coop.f
--- ./coop.f	2024-07-28 13:13:10.000000000 +0200
+++ ../../powr-refactor/src/coop.f	2023-11-21 10:10:55.285269778 +0100
@@ -1,10 +1,10 @@
-      SUBROUTINE COOP (XLAM,ND,T,RNE,POPNUM,ENTOT,RSTAR,
+      SUBROUTINE COOP (XLAM,ND,T,RNE,POPNUM,POPMIN,ENTOT,RSTAR,
      $                 OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,KODAT,
      $                 NDIM,N,MAXATOM,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,
      $                 EINST,ALPHA,SEXPO,
      $                 ADDCON1, ADDCON2, ADDCON3, 
-     $                 IGAUNT,SIGMATHK,SEXPOK,EDGEK,K,NF,SIGMAKI,RADIUS,
-     $                 KONTNUP,KONTLOW,LASTKON,XDATA)
+     $                 IGAUNT,SIGMATHK,SEXPOK,EDGEK,K,NF,SIGMAKI, 
+     $                 RADIUS,KONTNUP,KONTLOW,LASTKON,XDATA)
 C***********************************************************************
 C***  NON-LTE CONTINUOUS OPACITY AT GIVEN FREQUENCY FOR ALL DEPTH POINTS
 C***  CALLED FROM VARIOUS PLACES: 
@@ -29,14 +29,13 @@
 C***  MAXIMUM X-RAY DATA
       PARAMETER ( MAXXDAT = 10)
 C***  Dimension of the core-charge data locally provided here
-      PARAMETER (MAXATOMDIM = 26)
+      PARAMETER (MAXATOMDIM = 30)
 
       DIMENSION XDATA(MAXXDAT)
       DIMENSION NCHARG(N),WEIGHT(N),ELEVEL(N),EION(N)
       DIMENSION NOM(N)
       DIMENSION KODAT(MAXATOM)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION EINST(NDIM,NDIM)
       DIMENSION POPNUM(ND,N)
       DIMENSION OPA(ND),ETA(ND),THOMSON(ND)
@@ -50,9 +49,11 @@
       CHARACTER*10 LEVEL(N),MAINPRO(ND),MAINLEV(ND)
       LOGICAL XRAYS, KSHELL
 
+      REAL, PARAMETER :: EXPMIN = -300.
+
 C***  Output of laser warnings for bound-free transitions
+      INTEGER, SAVE :: NWARN
       DATA NWARN /0/ ! no warning has been issued yet
-      SAVE NWARN
 
 C***  C1 = H * C / K    ( CM * KELVIN )
       DATA C1 / 1.4388 /
@@ -60,7 +61,7 @@
       DATA C2 / 3.9724E-16 /
 C***  SIGMAE = ELCTRON SCATTERING CROSS SECTION  ( CM**2 )
       DATA SIGMAE / 0.6652E-24 /
-C***  C3 = RECIPROCAL STATISTICAL WEIGHT OF FREE ELECTRON
+C***  C3 = RECIPROCAL STATISTICAL WEIGHT OF FREE ELECTRON  ( CM**3 * KELVIN**(3/2) )
       DATA C3 / 2.07E-16 /
 C***  CFF = COEFFICIENT FOR FREE-FREE CROSS SECTION ( ALLEN PAGE 100, CM**5 )
       DATA CFF / 1.370E-23 /
@@ -116,13 +117,23 @@
          XRAYT = XDATA(2)
          XMINR = XDATA(3)
          DIFFEMEXP = XDATA(4)
-         EXPFACXRAY = EXP(-C1*W/XRAYT)
+         EXPVAL = -C1*W/XRAYT
+         IF (EXPVAL >= EXPMIN) THEN           
+           EXPFACXRAY = EXP(EXPVAL)
+         ELSE 
+           EXPFACXRAY = 0.
+         ENDIF
          PRESIGXRAY = CFF / W3 / SQRT(XRAYT)
          IF (XDATA(5) .NE. 0.) THEN
             XFILL2 = XDATA(5)
             XRAYT2 = XDATA(6)
             XMINR2 = XDATA(7)
-            EXPFACXRAY2 = EXP(-C1*W/XRAYT2)
+            EXPVAL = -C1*W/XRAYT2
+            IF (EXPVAL >= EXPMIN) THEN           
+              EXPFACXRAY2 = EXP(EXPVAL)
+            ELSE 
+              EXPFACXRAY2 = 0.
+            ENDIF
             PRESIGXRAY2 = CFF / W3 / SQRT(XRAYT2)
          ENDIF
 C***    Calculate number of free electrons, assuming full ionization
@@ -164,10 +175,19 @@
      >                    ADDCON1, ADDCON2, ADDCON3, 
      >                    IGAUNT,KON)
             ENDIF
+            IF (SIGMA < 0.) THEN
+              WRITE (0,*) 'BIGWARN: negative BF cross section!!!'
+            ENDIF
+            
  
 C***  RECIPROCAL STATISTICAL WEIGHT OF FREE ELECTRON
       WE=C3*RNE(L)*ENTOT(L)/T32
-      G=WEIGHT(I)/WEIGHT(J)*WE*EXP(C1*(EDGE-W)/TL)
+      EXPVAL = C1*(EDGE-W)/TL
+      IF (EXPVAL >= EXPMIN) THEN
+        G=WEIGHT(I)/WEIGHT(J)*WE*EXP(EXPVAL)
+      ELSE 
+        G=0.
+      ENDIF
       EMINDU=G*POPNUM(L,J)*SIGMA
 
 C***  Set emissivities zero if both levels are equal (=POPMIN)
@@ -175,7 +195,8 @@
 
       SUM=POPNUM(L,I)*SIGMA-EMINDU
 C***  LASER WARNING IF STIMULATED EMISSION EXCEEDS ABSORPTION IN THIS TRANSITION
-C***  IF THIS BF opacity is negative, it is not added to the sum
+C***  IF TOTAL CONT. OPA WAS < 0 AT FIRST TRIAL. THIS BF TRANSITION IS SKIPPED
+cc      IF (SUM.LT. .0 .AND. NBFLASER .EQ. 1) THEN
       IF (SUM.LT. .0) THEN
          IWARN(L)='*       '
          IF (NWARN .EQ. 0)  THEN
@@ -223,6 +244,7 @@
                LASTISTATE = ISTATE
             ENDIF
 
+c            IF (POPNUM(L,J) < 1.1 * POPMIN) CYCLE
             SUM = POPNUM(L,J) * SIGMAK
             OPAL = OPAL + SUM
             IF (SUM .GT. OPAMAX) THEN
@@ -305,7 +327,12 @@
 
 C***  PRECALCULATE SIGMAFF, LEAVING OUT THE FACTOR NCHARGE*NCHARGE
       PRESIG=CFF/W3/ROOTTL
-      EXPFAC=EXP(-C1*W/TL)
+      EXPVAL = -C1*W/TL
+      IF (EXPVAL >= EXPMIN) THEN
+        EXPFAC=EXP(EXPVAL)
+      ELSE 
+        EXPFAC = 0.
+      ENDIF
       DO 3 I=1,N
       NCHARI=NCHARG(I)
       IF (NCHARI .GT. MAXION) THEN
@@ -313,6 +340,7 @@
          STOP '*** ERROR IN COOP'
       ENDIF
       SIGMAFF=PRESIG*GFF(NCHARI)
+c      IF (POPNUM(L,I) < 1.1*POPMIN) GOTO 3
       SUM=RNE(L)*ENTOT(L)*POPNUM(L,I)*SIGMAFF
       EMINDU=SUM*EXPFAC
       SUM=SUM-EMINDU
diff -bur ./coopfrq.f ../../powr-refactor/src/coopfrq.f
--- ./coopfrq.f	2024-07-28 13:13:10.000000000 +0200
+++ ../../powr-refactor/src/coopfrq.f	2023-09-27 10:14:15.101755421 +0200
@@ -14,8 +14,7 @@
 C***********************************************************************
  
       DIMENSION NOM(N)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM, MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION XDATA(10)
       DIMENSION KODAT(MAXATOM)
       DIMENSION NCHARG(N),WEIGHT(N),ELEVEL(N),EION(N),EN(N)
@@ -24,7 +23,7 @@
       DIMENSION SIGMAKI(NF,LASTKON),SIGMAFF(NF,0:MAXION)
       LOGICAL XRAYS, KSHELL
 C***  Dimension of the core-charge data locally provided here
-      PARAMETER ( MAXATOMDIM = 26)
+      PARAMETER ( MAXATOMDIM = 30)
       DIMENSION KODATIND(MAXATOMDIM)
 
 C***  Output of laser warnings for bound-free transitions
@@ -72,7 +71,7 @@
       T32=TL*SQRT(TL)
  
 ccC***  Safety against negative opacities from lasering bound-free trans.
-ccC***  Note: In contrast to the other opacity routines, in COOPFRQ
+ccC***  Note: In contrast to the oher opacity routines, in COOPFRQ
 ccC***   all lasering b-f continue are suppressed *at all frequencies* 
 ccC**    if a negative "true" opacity is encountered at any frequency 
 cc      NBFLASER = 0
@@ -112,6 +111,11 @@
 
 C***  LASER bf continua are skipped!  3-Feb-2016
 cc      IF (SUM .LT. .0 .AND. NBFLASER .EQ. 1) THEN
+C***    Note: the above version, which makes use of NBLASER. has been
+C***          replaced by the more radical version that any lasering b-f
+C***          transition is immediately disregarded - wrh  4-Apr-2019
+
+cc      IF (SUM .LT. .0) THEN
 cc         IF (NWARN .EQ. 0)   WRITE (0, 90) 
 cc   90    FORMAT ('*** WARNING FROM Subr. COOPFRQ: ',
 cc     >   'LASERING BOUND-FREE CONTINUA SUPPRESSED')
@@ -266,6 +270,9 @@
 cc      DO K=2, NF
 cc         IF (OPAC(K) .LT. OPACMIN) OPACMIN = OPAC(K) 
 cc      ENDDO
+C***  Note: in the version with strict suppression (wrh  4-Apr-2019)
+C***        this condition should never be met, and is therefore
+C***        commented
 cc      IF (OPACMIN .LE. .0 .AND. NBFLASER .EQ. 0) THEN
 cc         NBFLASER = 1
 cc         GOTO 55
diff -bur ./datom.f ../../powr-refactor/src/datom.f
--- ./datom.f	2024-07-28 13:13:11.000000000 +0200
+++ ../../powr-refactor/src/datom.f	2024-07-22 09:27:16.100033925 +0200
@@ -12,7 +12,7 @@
      >                  LASTFE, SIGMAFE, INDRB, INDRF,
      >                  IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY, 
      >                  VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
 c!!!!!! Folgende parameter wurden entfernt:
 C!!!    CBFC, BOUND, EINSTINT, COCOFE, NCOMAX, NCO
@@ -33,20 +33,19 @@
 C***    in the DATOM file; unused elements have KODAT(NZ)=0 
 C*******************************************************************************
  
-      DIMENSION NCHARG (NDIM), WEIGHT(NDIM),ELEVEL(NDIM)
-      DIMENSION IONGRND(NDIM)
-      DIMENSION EION(NDIM),MAINQN(NDIM),EINST(NDIM,NDIM)
-      DIMENSION ALPHA(MAXKONT),SEXPO(MAXKONT)
-      DIMENSION ADDCON1(MAXKONT), ADDCON2(MAXKONT), ADDCON3(MAXKONT)
-      DIMENSION NOM(NDIM)
-      DIMENSION COCO(4,MAXIND)
-      DIMENSION ALTESUM(4,NDIM)
-      DIMENSION KODAT(MAXATOM),ATMASS(MAXATOM),STAGE(MAXATOM)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
-      DIMENSION NFIRST(MAXATOM),NLAST(MAXATOM)
-      DIMENSION INDNUP(MAXIND), INDLOW(MAXIND)
-      DIMENSION KONTNUP(MAXKONT), KONTLOW(MAXKONT)
+      INTEGER, INTENT(IN) :: NDIM, MAXIND, MAXION, MAXKONT, MAXAUTO
+
+      INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND, MAINQN, NOM
+      REAL, DIMENSION(NDIM) :: WEIGHT, ELEVEL, EION
+      REAL, DIMENSION(NDIM,NDIM) :: EINST
+      REAL, DIMENSION(MAXKONT) :: ALPHA, SEXPO,ADDCON1,ADDCON2,ADDCON3
+      REAL, DIMENSION(4, MAXIND) :: COCO
+      REAL, DIMENSION(4, NDIM) :: ALTESUM
+      REAL, DIMENSION(MAXATOM) :: ATMASS, STAGE
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
+      INTEGER, DIMENSION(MAXATOM) :: KODAT, NFIRST, NLAST
+      INTEGER, DIMENSION(MAXIND) :: INDNUP, INDLOW
+      INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW
       DIMENSION LOWAUTO(MAXAUTO),WAUTO(MAXAUTO),EAUTO(MAXAUTO)
      $         ,AAUTO(MAXAUTO),IONAUTO(MAXAUTO),KRUDAUT(MAXAUTO)
       CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
@@ -57,12 +56,12 @@
       CHARACTER*4 CEY,KEYCBB(MAXIND)
       CHARACTER*3 KRUDI,DRRUDI
       CHARACTER*2 SYMBOL(MAXATOM), KSHELLSYM
-      CHARACTER(LEN=*)  ROUTINE
+      CHARACTER(LEN=*), INTENT(IN) :: ROUTINE
 
-      LOGICAL BFEMODEL
+      LOGICAL :: BFEMODEL
  
       DO 15 NA=1,MAXATOM
-         DO ISTAGE=1, MAXATOM
+         DO ISTAGE=1, MAXION
            SIGMATHK(NA,ISTAGE)=.0
            SEXPOK  (NA,ISTAGE)=.0
            EDGEK   (NA,ISTAGE)=.0
@@ -135,7 +134,7 @@
 C****   the 'ELEMENT GENERIC' card is ignored. 
 C***    This feature was introduced to facilitate 
 C***    Sonja's NEWFORMAL_CARDS program
-      IF (ROUTINE .EQ. 'NOIRON' .AND. NEWELE .EQ. 'GENERIC') GOTO 1
+      IF (ROUTINE(1:6) == 'NOIRON' .AND. NEWELE == 'GENERIC') GOTO 1
 
 C***  NEW ELEMENT DECODED:
       LEVSEQ=0
@@ -169,8 +168,8 @@
          LASTINDAUTO = LASTIND + NAUTO
 
          CALL FEDAT (ROUTINE, INDEXMAX, NFEREADMAX, IONLOW, IONTOP,
-     &               MAXATOM, NDIM, MAXIND, MAXKONT,
-     &               NATOM, N, LASTFE, LASTKON, LASTINDAUTO, MAXFEIND,
+     &               MAXATOM, NDIM, MAXIND, MAXKONT, NATOM,
+     &               N, LASTFE, LASTKON, LASTINDAUTO, MAXFEIND,
      &               EINST, SIGMAFE, INDRB, INDRF, IFENUP, 
      &               IFELOW, INDNUP, INDLOW, KONTNUP, KONTLOW,
      &               LEVEL, ELEMENT, SYMBOL, ATMASS, STAGE,
@@ -196,7 +195,8 @@
       ENDIF
       IF (NATOM .NE. 0) NOM(N)=NATOM
 
-      READ (KARTE,11,ERR=985) LEVEL(N),NCHARG(N),NW,ELEVEL(N),E,MAINQN(N)
+      READ (KARTE,11,ERR=985) LEVEL(N),NCHARG(N),NW,ELEVEL(N),E,
+     &        MAINQN(N)
    11 FORMAT(12X,A10,1X,I2,1X,I4,2F10.0,1X,I2)
 
       WEIGHT(N)=FLOAT(NW)
@@ -284,6 +284,10 @@
          CALL REMARK ('LINE TRANSITION INDICES WRONG')
          GOTO 990
       ENDIF
+      IF (ELEVEL(NUP) < ELEVEL(LOW)) THEN
+         CALL REMARK ('LINE ERROR: UPPER LEVEL NOT IN FRONT')
+         GOTO 990
+      ENDIF
 C***  CORRECT LINE TRANSITION DETECTED:
       IND=IND+1
 
@@ -672,17 +676,7 @@
 C***        INTO THE GROUND STATE OF THE PARENT ION
       DO 97 I=1, NAUTO
          IF (IONAUTO(I) .EQ. 0) IONAUTO(I)=IONGRND(LOWAUTO(I))
-
-C***     Check if auto-ionization leads into an excited level
-         IF (IONAUTO(I) .NE. IONGRND(LOWAUTO(I))) THEN
-            WRITE (0,*)  '*** PROBLEM WITH DRTRANSIT DATA (DATOM):'
-            WRITE (0,*)  '*** Auto-ionization specified to lead into'
-            WRITE (0,*)  '*** an excited level (not ground level)'
-            WRITE (0,*)  '*** In the present form, the code is not ' //
-     >                    'able to handle this'
-            GOTO 986
-         ENDIF
-
+         IF (IONAUTO(I) .NE. IONGRND(LOWAUTO(I))) STOP 'IONAUTO'
 C***     Check that the stabilizing transitions have positive wavelength
          LOW=LOWAUTO(I)
 C***     WAVENUMBER OF STABILIZING TRANSITION
diff -bur ./dcoop.f ../../powr-refactor/src/dcoop.f
--- ./dcoop.f	2024-07-28 13:13:12.000000000 +0200
+++ ../../powr-refactor/src/dcoop.f	2023-09-27 10:14:15.101755421 +0200
@@ -2,7 +2,7 @@
      $                  WCHARM,ND,L,NFEDGE,EXPFAC,NDIM,N,NCHARG,WEIGHT,
      $                  ELEVEL,EION,EINST,SIGMAKI, KONTLOW,
      $                  KONTNUP,LASTKON,SIGMAFF,MAXION,NOM,KODAT,
-     $                  SIGMATHK,SEXPOK,EDGEK,MAXATOM,bBLOCKINVERSION)
+     $                  SIGMATHK,SEXPOK,EDGEK,MAXATOM,iBLOCKINVERSION)
 C***********************************************************************
 C***  CALLED FROM: SUBROUTINE COMA
 C***  DERIVATIVE OF NON-LTE OPACITY AND EMISSIVITY WITH RESPECT TO EN(I)
@@ -16,8 +16,7 @@
 C***  (i.e. KODATIND) give the atomic number (NCORECHARGE)
 C***********************************************************************
 
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM, MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION NOM(N),KODAT(MAXATOM)
       DIMENSION NCHARG(N),WEIGHT(N),ELEVEL(N),EION(N)
       DIMENSION KONTLOW(LASTKON),KONTNUP(LASTKON),NFEDGE(LASTKON)
@@ -27,10 +26,10 @@
       DIMENSION SIGMAKI(NF,LASTKON),SIGMAFF(NF,0:MAXION)
 
 C***  Dimension of the core-charge data locally provided here
-      INTEGER, PARAMETER :: MAXATOMDIM = 26
+      INTEGER, PARAMETER :: MAXATOMDIM = 30
       DIMENSION KODATIND(MAXATOMDIM)
  
-      LOGICAL :: bBLOCKINVERSION
+      INTEGER :: iBLOCKINVERSION
 
       REAL, PARAMETER :: C1 = 1.4388        !C1 = H * C / K    ( CM * ANGSTROEM )
       REAL, PARAMETER :: C2 = 3.9724E-16    !C2 = 2 * H * C    ( G * CM**3 / S**2 )
@@ -53,11 +52,12 @@
 C***  BOUND-FREE TRANSITIONS INVOLVING LEVEL I  ********************************
       DO 2 KON=1, LASTKON
       NUP=KONTNUP(KON)
-      IF (bBLOCKINVERSION .AND. (NOM(I) /= NOM(NUP))) GOTO 2
+      IF ((iBLOCKINVERSION > 0) .AND. (NOM(I) /= NOM(NUP))) GOTO 2
+C      IF ((iBLOCKINVERSION > 1) .AND. (NCHARG(I) /= NCHARG(NUP))) GOTO 2
       LOW=KONTLOW(KON)
 
 C***  I IS LOWER LEVEL
-      IF (I .EQ. LOW) THEN
+      IF (I == LOW) THEN
          DO 11 K=1,NFEDGE(KON)
          DOPA(K)=DOPA(K)+SIGMAKI(K,KON)
    11    CONTINUE
diff -bur ./decadp.f ../../powr-refactor/src/decadp.f
--- ./decadp.f	2024-07-28 13:13:12.000000000 +0200
+++ ../../powr-refactor/src/decadp.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,17 +1,18 @@
-      SUBROUTINE DECADP (OLDSTART, BDEPART, BTAUR, POPMIN, 
+      SUBROUTINE DECADP (OLDSTART, BDEPART, BTAUR, bUseENTOT, POPMIN, 
      >                LEVELCARD, NLEVELCARD, MAXLEVELCARD)
-C*****************************************************************
+C**********************************************************************
 C***  DEECODE INPUT OPTIONS FOR PROGRAM 'ADAPTER'
-C*****************************************************************
+C**********************************************************************
 
-      LOGICAL OLDSTART, BDEPART, BTAUR
+      LOGICAL OLDSTART, BDEPART, BTAUR, bUseENTOT
       CHARACTER KARTE*80, ACTPAR1*20
-      CHARACTER(80), DIMENSION(MAXLEVELCARD) :: LEVELCARD
+      CHARACTER LEVELCARD(MAXLEVELCARD)*80
 
 C***  DEFAULT VALUES: 
       OLDSTART=.FALSE.
       BDEPART = .FALSE. 
       BTAUR   = .FALSE.
+      bUseENTOT = .TRUE.
 C***  POPMIN: NULL popnums are set to this value
       POPMIN = 1.E-25
       NLEVELCARD = 0
@@ -47,6 +48,9 @@
             ELSE IF (ACTPAR1(:3) .EQ. 'TAU') THEN
 C                                      ===
                BTAUR   = .TRUE.
+            ELSE IF (ACTPAR1(:6) == 'RADIUS') THEN
+C                                    ======
+               bUseENTOT = .FALSE.
             ENDIF
          ENDDO
       ENDIF
diff -bur ./deccoli.f ../../powr-refactor/src/deccoli.f
--- ./deccoli.f	2024-07-28 13:13:12.000000000 +0200
+++ ../../powr-refactor/src/deccoli.f	2024-07-22 09:27:16.100033925 +0200
@@ -1,37 +1,48 @@
       SUBROUTINE DECCOLI (LSOPA,LSINT,MODHIST,
-     >             LPOPAB,LPOPABD,LEVDEBUG,LPJNUE,
-     >             LPJNUED,LASERV,PARALAS, LPSNUE,LPSNUED,
+     >             NOLAP,LPOPAB,LPOPABD,LEVDEBUG,LPJNUE,
+     >             LPJNUED,LASERV,PARALAS,LPSNUE,LPSNUED,
      $             MAXPLOT, RANGE1, RANGE2, EXLAM1, EXLAM2,MAXEXT,
-     $             BLLIST, NEWWRC, BCOLIRAY, 
-     >             CLHLP, BITCONT, BPLOT, IPLOT, LPLOT, ND, OPC, 
-     >             IVERS, BEMIX, EMIXSTART, EMIXMAX,
-     >             BEMIXFIX, EMIXFIX, IVERS_FE_EXPFAC, BPLOTALPHA,
-     >             XLAM_FINE_START, XLAM_FINE_END, LPLOT_WCHARM, 
-     >             XLP1, XLP2, GAMMACOLI, GAMMAT, UNLU_TAUMAX, 
-     >             UNLU_TAUMAX2, bKALPHA, bHYDROSOLVE, VELOMODFAK,
-     >             bForceCOLIP, bTDIFFUS, DRLINES_CARD)
+     $             BLLIST, 
+     >             REDISMODE, NEWWRC, BCOLIRAY, BKUDRITZKI,
+     >             CLHLP, BITCONT, BPLOT,  
+     >             IPLOT, LPLOT, ND, OPC, 
+     >             IVERS, BEMIX, EMIXSTART, BEMIXFIX, EMIXFIX, 
+     >             IVERS_FE_EXPFAC, BPLOTALPHA, ALPOPT, POPMIN,
+     >             XLAM_FINE_START, XLAM_FINE_END, LPLOT_WCHARM, XLP1,
+     >             XLP2, GAMMACOLI, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2,
+     >             bKALPHA, bHYDROSOLVE, VELOMODFAK, iTypeAlpha, 
+     >             bForceCOLIP, bTDIFFUS, bPLOTRTAU1, bNoIronLaser, 
+     >             iHTOTCUT, bMAXEMIX, bALOTri,
+     >             bNoNEGEDDIG, bDDVDOP, LPRDH, 
+     >             bDEBUG, CUTOPAMEANTHRES, DRLINES_CARD)
 C*******************************************************************************
 C***  DECODES INPUT CARDS FOR MAIN PROGRAM "COLI"
 C*******************************************************************************
 
       !IMPLICIT NONE
  
-      DIMENSION LINE(1),MODHIST(1)
-      CHARACTER(80) :: KARTE
-      CHARACTER*80 DRLINES_CARD
-      LOGICAL :: BLLIST, BCOLIRAY, CLHLP, BITCONT, 
-     >           BPLOT, BEMIX, BEMIXFIX, BPLOTALPHA
+      CHARACTER(120) :: KARTE, DRLINES_CARD, ALPOPT
+      CHARACTER(4) :: REDISMODE
+      LOGICAL :: NOLAP, LASERSET, DRNORUD, BLLIST, 
+     >           BCOLIRAY, CLHLP, BITCONT, 
+     >           BPLOT, BKUDRITZKI,
+     >           BEMIX, BEMIXFIX, BPLOTALPHA, bCustomVMOD,
+     >           bALOTri
+      INTEGER :: IVERS_FE_EXPFAC, iHTOTCUT
       INTEGER, DIMENSION(MAXPLOT) :: LPOPAB, LPOPABD, LPJNUE, LPJNUED,
      >                               LPSNUE, LPSNUED
-      REAL, INTENT(INOUT) :: VELOMODFAK
-      REAL :: PARALAS, tempREAL
-      CHARACTER(30), DIMENSION(20) :: ACTPAR
+      REAL, INTENT(INOUT) :: VELOMODFAK, POPMIN
+      INTEGER, INTENT(INOUT) :: iTypeAlpha
+      REAL :: PARALAS, tempREAL, CUTOPAMEANTHRES
+      CHARACTER(16), DIMENSION(20) :: ACTPAR
       CHARACTER(8) :: OPC
-      LOGICAL, INTENT(INOUT) :: bKALPHA, bForceCOLIP, bTDIFFUS
-      LOGICAL, INTENT(OUT) :: bHYDROSOLVE
+      LOGICAL, INTENT(INOUT) :: bKALPHA, bForceCOLIP, bTDIFFUS, bDDVDOP
+      LOGICAL, INTENT(OUT) :: bHYDROSOLVE, bPLOTRTAU1
+      LOGICAL :: bReadPOPMIN, bNoIronLaser, bMAXEMIX, 
+     >           bNoNEGEDDIG, bDEBUG
        
-      INTEGER :: LSOPA, LSINT, IPLOT, LPLOT
-      REAL :: RANGE1, RANGE2, DUNLU, DUNLUR
+      INTEGER :: LSOPA, LSINT, IPLOT, LPLOT, LPRDH
+      REAL :: RANGE1, RANGE2
 
 
       !File and channel handles (=KANAL)
@@ -42,10 +53,13 @@
 C***  DEFAULT VALUES
       LSOPA   = -1
       LSINT   = -1
+      NOLAP   = .FALSE.
+      LASERSET= .FALSE.
       LEVDEBUG= 0
       LASERV  = 1
       PARALAS = 0.01
       BLLIST  = .FALSE.
+      REDISMODE = 'CONT'
       BCOLIRAY = .FALSE.
       CLHLP = .FALSE.
       BITCONT = .TRUE.
@@ -57,7 +71,22 @@
       BPLOTALPHA = .FALSE.
       bHYDROSOLVE = .FALSE.
       bTDIFFUS = .TRUE.
-      DRLINES_CARD = ''
+      bCustomVMOD = .FALSE.
+      iTypeAlpha = 0
+      VELOMODFAK = 0.9          !default value for velocity field modification factor
+      bReadPOPMIN = (POPMIN < 1.E-99)
+      IF (bReadPOPMIN) THEN
+        POPMIN = 1.E-25           !default value should be the same as in STEAL -> DECSTE
+      ENDIF
+      bPLOTRTAU1 = .FALSE.
+      bNoIronLaser = .FALSE.
+      bALOTri = .FALSE.
+      iHTOTCUT = 0
+      bNoNEGEDDIG = .FALSE.     !default: Do not reset negative EDDIG
+      bDDVDOP = .FALSE.         !default: No depth-dependent VDOP
+      LPRDH = 0
+      bDEBUG = .FALSE.
+      CUTOPAMEANTHRES = 0.      !default: Do not cut out strong lines from mean opacities
     
 C***  Version of exponential factor in Fe lines (rates and eta) 
       IVERS_FE_EXPFAC = 1
@@ -71,7 +100,7 @@
       EMIXSTART = 1.0
       BEMIXFIX = .FALSE.
       EMIXFIX = 1.0
-      EMIXMAX=-1.
+      bMAXEMIX = .FALSE.
 
       DO I=1,MAXPLOT
         LPOPAB (I) = 0
@@ -111,6 +140,8 @@
       UNLU_TAUMAX = 1000.
       UNLU_TAUMAX2 = 100.
 
+      ALPOPT = ""
+
       OPEN (1, FILE='CARDS', STATUS='UNKNOWN')
       REWIND 1
     6 READ (1,FMT='(A)', END=100) KARTE
@@ -141,10 +172,17 @@
         ELSE IF ( ACTPAR(2) .EQ. 'LINELIST') THEN
 C                                 ========
             BLLIST = .TRUE.
+        ELSE IF ( ACTPAR(2) .EQ. 'DELTAH') THEN
+C                                 ======
+            READ (ACTPAR(3),8, ERR=99) XL
+            LPRDH=IFIX(XL)
+            IF (LPRDH == 0) LPRDH = 1
+        ENDIF
+        GOTO 6
         ENDIF
 
-      ELSEIF ( ACTPAR(1)(:7) .EQ. 'DRLINES' ) THEN
-C                              =======
+      IF ( ACTPAR(1)(:6) .EQ. 'DRLINE' ) THEN
+C                                  ======
          DRLINES_CARD = KARTE
  
       ELSEIF (ACTPAR(1) .EQ. 'CMFDLEV') THEN
@@ -153,9 +191,14 @@
         GOTO 6
         ENDIF
 
+      IF (ACTPAR(1) == 'OPAMEANTHRES') THEN
+        READ(ACTPAR(2), '(G10.3)', ERR=99) CUTOPAMEANTHRES
+        GOTO 6
+      ENDIF
 
       IF (ACTPAR(1) .EQ. 'LASERV') THEN
 C                         ======
+        LASERSET = .TRUE.
         READ (ACTPAR(2),'(I10)', ERR=99) LASERV
         IF (NPAR == 3) THEN
           READ (ACTPAR(3),'(G10.1)', ERR=99) PARALAS
@@ -169,6 +212,13 @@
                     PARALAS = tempREAL
                   ENDIF                    
                 ENDIF
+cc              CASE ('KONT', 'CONT', 'K', 'C')
+cc                IF (NPAR >= (IPAR+1)) THEN
+cc                  READ (ACTPAR(IPAR+1), '(F10.0)', IOSTAT=IERR) tempREAL
+cc                  IF (IERR == 0) THEN
+cc                    PARALKONT = tempREAL
+cc                  ENDIF                    
+cc                ENDIF
             ENDSELECT
           ENDDO
         ENDIF
@@ -182,6 +232,12 @@
         GOTO 6
       ENDIF
 
+      IF (ACTPAR(1) .EQ. 'REDISMODE') THEN
+C                         =========
+         REDISMODE = ACTPAR(2) 
+         GOTO 6
+      ENDIF
+
       IF (ACTPAR(1) .EQ. 'NEWWRC' ) THEN
 C                         ======
          READ (ACTPAR(2),'(F10.0)',ERR=99) XL
@@ -195,6 +251,14 @@
          ENDIF
       ENDIF
 
+      IF (KARTE(:4) == 'VDOP') THEN
+C                       ====
+         IF (NPAR > 2) THEN
+           IF (ACTPAR(3) == 'AUTO') bDDVDOP = .TRUE.
+         ENDIF
+         GOTO 6
+      ENDIF
+      
       IF (ACTPAR(1) == 'NOTDIFFUS') THEN
 C                       =========
          bTDIFFUS = .FALSE.
@@ -261,8 +325,15 @@
 C                           ====
            IF (ACTPAR(2) == 'ALPHA') THEN
               BPLOTALPHA = .TRUE.
+              ALPOPT = KARTE
               GOTO 6
            ENDIF
+
+           IF (ACTPAR(2) == 'RTAU1COLI') THEN
+              bPLOTRTAU1 = .TRUE.
+              GOTO 6
+           ENDIF
+           
         ENDIF
 
         IF (ACTPAR(1) .EQ. 'PURE' .AND. ACTPAR(2) .EQ. 'COLIRAY') THEN
@@ -323,6 +394,28 @@
             READ (ACTPAR(3),'(F10.0)', ERR=99) GAMMACOLI
             GOTO 6
           ENDIF
+          IF (ACTPAR(2) == 'KUDRITZKI') THEN
+            BKUDRITZKI = .TRUE.
+            GOTO 6
+          ENDIF
+          IF (ACTPAR(2) == 'NONEGACC') THEN
+            iHTOTCUT = 1
+            GOTO 6
+          ENDIF
+          IF (ACTPAR(2) == 'NO' .AND. ACTPAR(3)(1:3) == 'NEG'
+     >           .AND. ACTPAR(4) == 'EDDIG') THEN
+            bNoNEGEDDIG = .TRUE.
+            GOTO 6
+          ENDIF          
+          IF (ACTPAR(2) == 'NOFELASER') THEN
+            bNoIronLaser = .TRUE.
+            WRITE (0,*) 'COLI: NO IRON LASER ALLOWED'
+            GOTO 6
+          ENDIF
+          IF (ACTPAR(2) == 'DEBUG') THEN
+            bDEBUG = .TRUE.
+            GOTO 6
+          ENDIF
         ENDIF
 C***  End of Options beginning with COLI ...
 
@@ -356,20 +449,15 @@
          GOTO 6
          ENDIF
 
-        IF (ACTPAR(1) .EQ. 'EDDIMIX' .AND. 
-     >      ACTPAR(2) .EQ. 'MAX') THEN
-C                           =======
-         IF (NPAR .LT. 3) THEN
-           WRITE (0,*) 'ERROR: EDDIMIX MAX needs a value'
-           GOTO 99
-         ENDIF
-         
-         READ (ACTPAR(3),'(F10.0)', ERR=99) EMIXMAX
+        IF (ACTPAR(1) == 'EDDIMIX' .AND.  ACTPAR(2) == 'MAX') THEN
+C                         =======                       ===
+          bMAXEMIX = .TRUE.
+          GOTO 6
          ENDIF
 
-        IF (ACTPAR(1)(:16) == 'IRONLINES-EXPFAC') THEN
+        IF (ACTPAR(1)(:16) .EQ. 'IRONLINES-EXPFAC') THEN
 C                              ================
-           IF (ACTPAR(2) == 'OFF') THEN
+           IF (ACTPAR(2) .EQ. 'OFF') THEN
               IVERS_FE_EXPFAC = 0
               WRITE (0,*) '*** WARNING: non-standard ' // KARTE
            ELSEIF (ACTPAR(2) == 'TEFF') THEN
@@ -383,6 +471,13 @@
          GOTO 6
          ENDIF
 
+
+        IF (ACTPAR(1)(1:6) == 'POPMIN' .AND. bReadPOPMIN) THEN
+C                              ======
+          READ (ACTPAR(2),'(F10.0)', ERR=99) POPMIN
+          GOTO 6
+        ENDIF         
+         
         !Force calculation of force multipliers
         ! Note: Usually this is automatically forced from the HYDRO interval option
         !       By using the FORCEMULTIPLIERS card you can ensure that the calculation
@@ -391,12 +486,22 @@
         IF (ACTPAR(1)(1:9) == 'FORCEMULT') THEN
 C                              =========
          bKALPHA = .TRUE.
+         IF (.NOT. bHYDROSOLVE .AND. iTypeAlpha == 0) THEN
+           iTypeAlpha = 1
+         ENDIF
          IF (NPAR > 2) THEN
            DO I=2, NPAR
              IF ((ACTPAR(I) == 'VMOD') .AND. (NPAR >= (I+1))) THEN
                READ (ACTPAR(I+1), '(F20.0)', IOSTAT=IERR) tempREAL
                IF (IERR == 0) THEN
                  VELOMODFAK = tempREAL
+                 bCustomVMOD = .TRUE.
+               ENDIF               
+             ENDIF
+             IF ((ACTPAR(I) == 'AT') .AND. (NPAR >= (I+1))) THEN
+               READ (ACTPAR(I+1), '(F10.0)', IOSTAT=IERR) tempREAL
+               IF (IERR == 0) THEN
+                 iTypeAlpha = IFIX(tempREAL)
                ENDIF               
              ENDIF
            ENDDO
@@ -413,6 +518,13 @@
                READ (ACTPAR(I+1), '(F20.0)', IOSTAT=IERR) tempREAL
                IF (IERR == 0) THEN
                  VELOMODFAK = tempREAL
+                 bCustomVMOD = .TRUE.
+               ENDIF               
+             ENDIF
+             IF ((ACTPAR(I) == 'AT') .AND. (NPAR >= (I+1))) THEN
+               READ (ACTPAR(I+1), '(F10.0)', IOSTAT=IERR) tempREAL
+               IF (IERR == 0) THEN
+                 iTypeAlpha = IFIX(tempREAL)
                ENDIF               
              ENDIF
            ENDDO
@@ -421,6 +533,15 @@
         ENDIF
 
         IF (ACTPAR(1) .EQ. 'XJLAPP' .AND.
+     >         ACTPAR(2) .EQ. 'COLI') THEN
+          DO I=3, NPAR
+            IF (ACTPAR(I)(:3) .EQ. 'TRI') THEN
+              bALOTri = .TRUE.
+            ENDIF
+          ENDDO
+        ENDIF
+
+        IF (ACTPAR(1) .EQ. 'XJLAPP' .AND.
      >         ACTPAR(2) .EQ. 'NEW') THEN
 C                              ===========
          IF (NPAR .GT. 2) THEN
@@ -443,7 +564,24 @@
 
 C***  END-OF-DATA REACHED: REGULAR EXIT
   100 CONTINUE
-      CLOSE (1)
+      CLOSE(1)
+  
+C***  Check if Alpha-Type is in valid range:
+      IF (iTypeAlpha < 0 .OR. 
+     >     (iTypeAlpha > 3  .AND. iTypeAlpha < 10) .OR.
+     >     (iTypeAlpha > 12 .AND. iTypeAlpha /= 31)) THEN
+        WRITE (hCPR,*) 'INVALID ALPHA TYPE SPECIFIED!'
+        STOP 'ERROR in DECCOLI'
+      ENDIF
+
+C***  Default is different if response factor is calculated instead of alpha (AT == 3)
+      IF (iTypeAlpha == 3 .AND. (.NOT. bCustomVMOD)) THEN
+c        VELOMODFAK = 0.99   !more accurate default for response factor calculation
+        VELOMODFAK = 0.9   !try this first
+      ENDIF
+       
+C***  IF LASER VERSION NOT EXPLICITELY DECLARED, SET DEFAULT VALUE
+      IF (.NOT. LASERSET  .AND. NOLAP) LASERV = 0
 
       RETURN
 
diff -bur ./decfreq.f ../../powr-refactor/src/decfreq.f
--- ./decfreq.f	2024-07-28 13:13:13.000000000 +0200
+++ ../../powr-refactor/src/decfreq.f	2023-09-27 10:14:15.101755421 +0200
@@ -11,8 +11,10 @@
  
       COMMON /COMTEFF/ TEFF,TMIN,TMODIFY,SPHERIC
       CHARACTER KARTE*80, ACTPAR*20
+      CHARACTER(8), DIMENSION(NFDIM) :: KEY
       DIMENSION XLAMBDA(NFDIM)
-      CHARACTER*8 KEY(NFDIM)
+
+      REAL, INTENT(IN) :: XLAMBLUE
       LOGICAL OLDFGRID
  
 C***  IF NO REFERENCE TEMPERATURE IS SPECIFIED, TEFF IS DEFAULT
@@ -44,7 +46,7 @@
 C***    (RECOGNIZED BY BLANK ENTRY IN ARRAY "KEY")
       KK = 0
       DO 10 K=1, NF
-        IF (KEY(K) .NE. ' ' ) GOTO 10
+        IF (KEY(K) .NE. '        ') GOTO 10
         KK = KK + 1
         XLAMBDA(KK) = XLAMBDA(K)
    10 CONTINUE
diff -bur ./decomo.f ../../powr-refactor/src/decomo.f
--- ./decomo.f	2024-07-28 13:13:14.000000000 +0200
+++ ../../powr-refactor/src/decomo.f	2023-09-27 10:14:15.101755421 +0200
@@ -7,8 +7,6 @@
  
       CHARACTER(80) :: KARTE
       CHARACTER(80), DIMENSION(NPLOTOPADIM) :: OPTIONPLOTOPA
-      PARAMETER (MAXPAR = 3)
-      CHARACTER(20), DIMENSION(MAXPAR) :: ACTPAR
       LOGICAL NOTEMP, BUNLU, BPLOTRTAU1
       INTEGER :: NPLOTOPA, NPLOTOPADIM
 
@@ -28,53 +26,32 @@
  
     8 READ (1,4, END=99) KARTE
     4 FORMAT (A)
-      CALL SARGC(KARTE,NPAR)
-      IF ( NPAR .LT. 1) GOTO 8
-      IF ( NPAR .GT. 20) NPAR = 20
-C***  Get actual parameters
-      ACTPAR = ''
-      DO I=1, NPAR
-       CALL SARGV(KARTE,I,ACTPAR(I))
-      ENDDO
- 
-C***  PRINT options
-      IF (ACTPAR(1) .EQ. 'PRINT') THEN
-C                         =====
-
-         IF(ACTPAR(2) .EQ. 'INT') THEN
-C                           ===
-            READ (ACTPAR(3), 7) XL
-    7       FORMAT (F20.0)
+ 
+      IF (KARTE(:10) .EQ. 'PRINT INT ') THEN
+C                          ==========
+            DECODE (80,7,KARTE) XL
+    7       FORMAT (10X,F10.0)
+   77       FORMAT (11X,F10.0)
             LSINT=IFIX(XL)
             IF (LSINT.EQ.0) LSINT=1
-
-         ELSEIF (ACTPAR(2) .EQ. 'OPA') THEN
-C                                ===
-            READ (ACTPAR(3), 7) XL
+      ELSE IF (KARTE(:10) .EQ. 'PRINT OPA ') THEN
+C                               ==========
+            DECODE (80,7,KARTE) XL
             LSOPA=IFIX(XL)
             IF (LSOPA.EQ.0) LSOPA=1
-
-         ELSEIF (ACTPAR(2) .EQ. 'HTOTC') THEN
+      ELSE IF (KARTE(:11) .EQ. 'PRINT HTOTC') THEN
 C                               ===========
-            READ (ACTPAR(3), 7) XL
+            DECODE (80,77,KARTE) XL
             LSHTOT=IFIX(XL)
             IF (LSHTOT.EQ.0) LSHTOT=1
-         ENDIF
-
-C***  PLOT options
-      ELSEIF (ACTPAR(1) .EQ. 'PLOT') THEN
-C                             ====
-
-         IF (ACTPAR(2) .EQ. 'HTOTC') THEN
-C                            =====
+      ELSE IF (KARTE(:10) .EQ. 'PLOT HTOTC') THEN
+C                               ==========
             LPLOHTOT=1
-
-         ELSEIF (ACTPAR(2) .EQ. 'RTAU1') THEN
-C                                =====
+      ELSE IF (KARTE(:10) .EQ. 'PLOT RTAU1') THEN
+C                               ==========
             BPLOTRTAU1 = .TRUE.
-
-         ELSEIF (ACTPAR(2) .EQ. 'OPA') THEN
-C                                ===
+      ELSE IF (KARTE(:8) .EQ. 'PLOT OPA') THEN
+C                              ==========
             NPLOTOPA = NPLOTOPA + 1
             IF (NPLOTOPA .LE. NPLOTOPADIM) THEN 
                OPTIONPLOTOPA(NPLOTOPA) = KARTE
@@ -84,21 +61,15 @@
                WRITE (0,*) 
      >            'WARNING: more PLOT OPA options than dimensioned' 
             ENDIF
-         ENDIF
-C     Other options
-      ELSE
-
-         IF (KARTE(:8) .EQ. 'NO TEMPE') THEN
+      ELSE IF (KARTE(:8) .EQ. 'NO TEMPE') THEN
 C                            ========
             NOTEMP=.TRUE.
             IF (KARTE(30:40) .NE. ' ') 
      $         CALL DECNOT (MODHIST,MODHIST,KARTE,NOTEMP,'COMO')
-
-         ELSEIF (ACTPAR(1) .EQ. 'UNLUTEC') THEN
+      ELSE IF (KARTE(:7) .EQ. 'UNLUTEC') THEN
 C                                =======
             BUNLU=.TRUE.
          ENDIF
-      ENDIF
 
       GOTO 8
 
diff -bur ./decon.f ../../powr-refactor/src/decon.f
--- ./decon.f	2024-07-28 13:13:14.000000000 +0200
+++ ../../powr-refactor/src/decon.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,5 +1,5 @@
       SUBROUTINE DECON (LSOPA,LSINT,IFLUX,JOBMAX,MODHIST, 
-     >                  BUNLU, IVERS)
+     >                  BUNLU, bCLXJC, IVERS, POPMIN)
 C***********************************************************************
 C***  DECODING INPUT OPTIONS, CALLED FROM WRCONT *******************************
 C***********************************************************************
@@ -7,13 +7,18 @@
       IMPLICIT NONE
 
       INTEGER :: I, NPAR, IFLUX, JOBMAX, IVERS,
-     >           LSOPA, LSINT, IDX
+     >           LSOPA, LSINT
       INTEGER, DIMENSION(1) :: MODHIST
 
+      REAL :: XL, POPMIN
+ 
       CHARACTER(14), DIMENSION(5) :: ACTPAR
       CHARACTER(80) :: KARTE
 
-      LOGICAL BUNLU
+      INTEGER, EXTERNAL :: IDX
+
+      LOGICAL :: BUNLU, bCLXJC, bReadPOPMIN
+
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hCPR = 0 !write to wruniqX.cpr (stderr)
 
@@ -24,7 +29,12 @@
       IFLUX=-1
       JOBMAX=-1
       BUNLU = .FALSE.
+      bCLXJC = .FALSE.
       IVERS = 4
+      bReadPOPMIN = (POPMIN < 1.E-99)
+      IF (bReadPOPMIN) THEN
+        POPMIN = 1.E-25           !default value should be the same as in STEAL -> DECSTE
+      ENDIF
  
       OPEN (1,FILE='CARDS', STATUS='UNKNOWN')
       REWIND (1)
@@ -41,47 +51,74 @@
           CALL SARGV(KARTE,I,ACTPAR(I))
         ENDDO
 
-C***    PRINT options ************************
 
-        IF (ACTPAR(1) .EQ. 'PRINT') THEN
-C                           =====
-          IF (ACTPAR(2) .EQ. 'FLUX') THEN
-C                             ====
+        IF (KARTE(:10) .EQ. 'PRINT FLUX') THEN
+C                            ==========
              IFLUX=1
-
-          ELSE IF (ACTPAR(2) .EQ. 'INT') THEN
-C                                  ===
-             READ (ACTPAR(3), *, ERR=90) LSINT
-             IF (LSINT .EQ. 0) LSINT=1
-
-          ELSE IF (ACTPAR(2) .EQ. 'OPA ') THEN
-C                                  ===
-             READ (ACTPAR(3), *, ERR=90) LSOPA
-             IF (LSOPA .EQ. 0) LSOPA=1
-
+          CYCLE
           ENDIF
-
-C***    Other (not PRINT) options *****************************
-
-        ELSE IF (ACTPAR(1) .EQ. 'JOBMAX') THEN
-C                                ======
-          READ (ACTPAR(2), *, ERR=90) JOBMAX
-
-        ELSE IF (ACTPAR(1) .EQ. 'UNLUTEC') THEN
+        IF (KARTE(:10) .EQ. 'PRINT INT ') THEN
+C                            ==========
+          !DECODE (80,7,KARTE) XL
+          READ (UNIT=KARTE, FMT=7) XL
+    7     FORMAT (10X,F10.0)
+          LSINT=IFIX(XL)
+          IF (LSINT.EQ.0) LSINT=1
+          CYCLE
+        ENDIF
+        IF (KARTE(:10) .EQ. 'PRINT OPA ') THEN
+C                            ==========
+          !DECODE (80,7,KARTE) XL
+          READ (UNIT=KARTE, FMT=7) XL
+          LSOPA=IFIX(XL)
+          IF (LSOPA.EQ.0) LSOPA=1
+          CYCLE
+        ENDIF
+        IF (KARTE(:7) .EQ. 'JOBMAX=') THEN
+C                           =======
+          !DECODE (80,3,KARTE) XL
+          READ (UNIT=KARTE, FMT=3) XL
+    3     FORMAT (7X,F10.9)
+          JOBMAX=IFIX(XL)
+          CYCLE
+        ENDIF
+c        IF (KARTE(:8) .EQ. 'NO TEMPE') THEN
+cC                           ========
+c              NOTEMP=.TRUE.
+c              IF (KARTE(30:40) .NE. ' ')
+c     $          CALL DECNOT (MODHIST(1),MODHIST,KARTE,NOTEMP,'WRCONT')
+c              CYCLE
+c              ENDIF
+        IF (KARTE(:7) .EQ. 'UNLUTEC') THEN
 C                                =======
           BUNLU=.TRUE.
+          CYCLE
+        ENDIF
 
-        ELSE IF (ACTPAR(1) .EQ. 'OB-VERS') THEN
+        IF (ACTPAR(1) .EQ. 'OB-VERS') THEN
 C                                =======
           IF (NPAR .EQ. 2 .OR. ACTPAR(3) .EQ. 'WRCONT') THEN
-            READ (ACTPAR(2), *, ERR=90) IVERS
+            READ (ACTPAR(2),'(I10.0)', ERR=90) IVERS
+C            write (0,*) 'DECCON: IVERS = ', ivers
+          ENDIF
+          CYCLE 
+        ENDIF
+ 
+        IF (ACTPAR(1)(1:6) == 'POPMIN' .AND. bReadPOPMIN) THEN
+C                              ======
+          READ (ACTPAR(2),'(F10.0)', ERR=90) POPMIN
+          CYCLE
           ENDIF
 
+        IF (KARTE(:8) == 'COLI-XJC') THEN
+C                         ========
+          bCLXJC = .TRUE.
+          CYCLE
         ENDIF  
  
       ENDDO
 
-C***  END-OF-FILE REACHED *****************************************
+C***  END-OF-FILE REACHED:
     1 CONTINUE
       CLOSE (1)
       RETURN
diff -bur ./decstar.f ../../powr-refactor/src/decstar.f
--- ./decstar.f	2024-07-28 13:13:15.000000000 +0200
+++ ../../powr-refactor/src/decstar.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,18 +1,21 @@
       SUBROUTINE DECSTAR (MODHEAD, FM, RSTAR, VDOP, RMAX, TTABLE, 
      >                    NDDIM, OLDTEMP, MAXATOM, NATOM, ABXYZ, KODAT,
      >                    VPLOT, ATMASS, XDATA, MAXXDAT, OLDFGRID, 
-     >                    THIN, ThinCard, GLOG, GEFFLOG, GEDD, bSaveGEFF,
-     >                    XMSTAR, WRTYPE, TAUMAX, TAUACC,
+     >                    THIN, ThinCard, GLOG, GEFFLOG, GEDD, 
+     >                    bSaveGEFF, XMSTAR, WRTYPE, TAUMAX, TAUACC,
      >                    bTauFix, BTWOT, TFAC, DENSCON_LINE, BLACKEDGE, 
      >                    bOLDSTART, RadiusGridParameters, XMDOT, XLOGL,
      >                    RTRANS, BTAUR, DENSCON_FIX, MASSORIGIN, 
-     >                    LRTinput, ELEMENT, bOldStratification, 
-     >                    bHYDROSOLVE, GEddFix, 
-     >                    MLRELATION, NC, VTURB, 
-     >                    bOLDRAD, RADGAMMASTART, fHYDROSTART, 
-     >                    bFULLHYDROSTAT, bGAMMARADMEAN, GEFFKEY,
-     >                    bGREYSTART, XLAMBLUE, MDOTINPUT, LTESTART, 
-     >                    DRLINES_CARD)
+     >                    LRTinput, ELEMENT, iOldStratification, 
+     >                    bHYDROSOLVE, GEddFix, bOldMdot, VoldMod, 
+     >                    bOVTauMax, MLRELATION, NC, VTURBND, 
+     >                    VTURB_LINE, iOLDRAD, RADGAMMASTART, 
+     >                    fHYDROSTART, bFULLHYDROSTAT, bGAMMARADMEAN, 
+     >                    cVEXTEND, bGREYSTART, GEFFKEY, POPMIN, 
+     >                    XLAMBLUE, LTESTART, bOLDMODEL, XMDOTold, 
+     >                    XMSTARold, RSTARold, VNDold, VFINALold, 
+     >                    bForceDCUpdate, bOLDJ, bOVTauCut, bDCSCALE,
+     >                    TEFFold, XLOGLold, MDOTINPUT, DRLINES_CARD)
 C***********************************************************************
 C***  DECODES INPUT CARDS, CALLED FROM WRSTART
 C***********************************************************************
@@ -23,7 +26,8 @@
 C***  The second line has additional parameters for the 2-beta-law 
 C***     -- wrh  6-Apr-2006 17:21:57
       COMMON/VELPAR/ VFINAL,VMIN,BETA,VPAR1,VPAR2,RCON,HSCALE,
-     >     BETA2, BETA2FRACTION, VPAR1_2, VPAR2_2
+     >     BETA2, BETA2FRACTION, VPAR1_2, VPAR2_2, RONSET,
+     >     bSMOCO, VCON, VOFF
 
 C***  COMMON /COMTEFF/  TRANSFERS THE EFF. TEMPERATURE TO: 
 C***                    WRSTART, GREY, PRIMOD, DECFREQ, DTDR, JSTART 
@@ -34,48 +38,51 @@
       CHARACTER(8) :: OPSYS
 
       REAL :: FM, RSTAR, VDOP, RMAX, RTRANS, TEFF, 
-     >          TMIN, TMODIFY, TFAC,
-     >          VMIN, VFINAL, BETA, VPAR1, VPAR2,
-     >          RCON, HSCALE, BETA2, BETA2FRACTION,
-     >          VPAR1_2, VPAR2_2, fHYDROSTART,
-     >          XMDOT, XMSTAR, XMSTARG, XLOGL,
-     >          ABUND, ABREST, DENSUM, SUM,
-     >          XHY, YHE, XC, XO, tempREAL, VTURB, XLAMBLUE, XMDOTTRANS
+     >          TMIN, TMODIFY, TFAC, RONSET,
+     >          VMIN, VFINAL, BETA, VPAR1, VPAR2, VCON,
+     >          RCON, HSCALE, BETA2, BETA2FRACTION, VOFF,
+     >          VPAR1_2, VPAR2_2, fHYDROSTART, RSTARold,
+     >          XMDOT, XMSTAR, XMSTARG, XLOGL, XMSTARold,
+     >          ABUND, ABREST, DENSUM, SUM, XMDOTold, VNDold,
+     >          XHY, YHE, XC, XO, tempREAL, POPMIN, 
+     >          VFINALold, XLAMBLUE, XMDOTTRANS,
+     >          XLOGLold, TEFFOLD
 
       INTEGER :: NDDIM, MAXATOM, NATOM, MAXXDAT,
      >           MASSORIGIN, NPAR, IDXA, IDX,
-     >           KHY, KHE, KC, KO, IERR, MFORM, NC, LcalcCond
-      INTEGER, INTENT(OUT) :: GEddFix, LRTinput, MDOTINPUT
+     >           KHY, KHE, KC, KO, IERR, MFORM, NC, 
+     >           LcalcCond, RcalcCond
+      INTEGER, INTENT(OUT) :: GEddFix, LRTinput, iOldStratification, 
+     >                        iOLDRAD, MDOTINPUT
 
       REAL, DIMENSION(MAXATOM) :: ABXYZ, ATMASS
       REAL, DIMENSION(MAXXDAT) :: XDATA
       INTEGER, DIMENSION(MAXATOM) :: KODAT
       INTEGER, DIMENSION(8) :: DTVALUES
       LOGICAL :: LTESTART, TTABLE, SPHERIC, 
-     >           OLDTEMP, VPLOT, OLDFGRID,
+     >           OLDTEMP, VPLOT, OLDFGRID, bOLDMODEL, bOLDJ,
      >           ABMASS,ABNUMB,THIN, BTWOT, RMAX_IN_RSUN, BTAUR
       LOGICAL, INTENT(OUT) :: bSaveGEFF, bOLDSTART, bGREYSTART,
-     >                        bOldStratification, bTauFix, 
-     >                        bHYDROSOLVE, 
-     >                        bFULLHYDROSTAT, bGAMMARADMEAN, bOLDRAD
-      LOGICAL bCalcGLOGfromM, bLRTcomplete
+     >                        bTauFix, bForceDCUpdate, bOVTauCut,
+     >                        bHYDROSOLVE, bOldMdot, bOVTauMax,
+     >                        bFULLHYDROSTAT, bGAMMARADMEAN, bDCSCALE
+      LOGICAL :: bCalcGLOGfromM, bLRTcomplete, bSMOCO
       CHARACTER(100) :: MODHEAD
-      CHARACTER(8)  :: DAT, TIM, GEFFKEY
-      CHARACTER TIM1*8, TIM2*10
+      CHARACTER(8)  :: DAT, TIM, GEFFKEY, cVEXTEND
       CHARACTER(80) :: KARTE, ACTPAR, NEXTPAR, ThinCard
+      CHARACTER(120) :: DRLINES_CARD
       CHARACTER(2)  :: WRTYPE
       CHARACTER(20) :: ACTPAR2
       CHARACTER(10) :: SYS, NODE, REL, VER, MACH
       CHARACTER(33) :: HOST
-      CHARACTER*(*) :: DENSCON_LINE
+      CHARACTER*(*) :: DENSCON_LINE, VTURB_LINE
       CHARACTER(10), DIMENSION(NATOM) :: ELEMENT
       CHARACTER(80), DIMENSION(3) :: RadiusGridParameters     !contains all RADIUS-GRID CARDS (for subr. RGRID)
       CHARACTER(9) :: MLRELATION
-      CHARACTER*80 DRLINES_CARD
 
       REAL :: BLACKEDGE, DENSCON_FIX
       REAL :: GLOG, GEFFLOG, GEDD, q, QLOG, RADGAMMASTART
-      REAL :: TAUMAX, TAUACC
+      REAL :: TAUMAX, TAUACC, VoldMod, VTURBND
 
       !Laufvariablen und co.
       INTEGER :: I, K, NA, NZ, IPAR,
@@ -102,6 +109,8 @@
       RSTAR=-1.
       RMAX=-1.
       XLOGL = -99.
+      XMSTAR = -99.
+      GLOG = -99.
       RTRANS = -99.
       QLOG = -99.
       VDOP=-1.
@@ -127,9 +136,17 @@
       BTWOT = .FALSE.
       DENSCON_FIX = 1.
       DENSCON_LINE = ' '
+      VTURB_LINE = ' '
+      DRLINES_CARD = ''
       BLACKEDGE = .0
       BTAUR = .FALSE.
       BETA2FRACTION = .0
+      VCON = 1.0      
+      bSMOCO = .FALSE.
+      bForceDCUpdate = .FALSE.
+      bDCSCALE = .FALSE.
+      
+      q = -1.0
       GEDD = -1.0
       XLAMBLUE = -1. 
 C***  Number of core-rays
@@ -141,37 +158,47 @@
       bSaveGEFF = .FALSE.    !Determines if GEFFLOG is fixed in the MODEL file
       bCalcGLOGfromM = .FALSE.
       bOLDSTART = .FALSE.   !true if OLDSTART CARDS option has been set
-      DRLINES_CARD = ''
-
-ccc   wrstart used the subroutine GREY for establishing the first tau-scale
-ccc   (Rosseland mean, continuum opacities only). Andreas Sander
-ccc   suggested to use the subr. TAUSCAL for calculating the Rosseland mean. 
-ccc   To my opinion, this should be identical, but Andreas says results
-ccc   differ. Till this is settled, the switch for
-ccc   the new version is de-activated by setting the switch to TRUE
       bGREYSTART = .FALSE.
-ccc      bGREYSTART = .TRUE.
-
-      bOldStratification = .FALSE.  !true if stratification (ND, VELO, RADIUS, DENSCON) from old model should be kept (@todo: also MDOT?)
+      bOLDJ = .FALSE.       !true if radiation field XJC from old model is used 
+      iOldStratification = 0  !> 0 if stratification (ND, VELO, RADIUS, DENSCON) from old model should be kept (@todo: also MDOT?)
       bHYDROSOLVE = .FALSE. !true if hydro iteration will be done in STEAL
+      bOldMdot = .FALSE.
+      bOVTauMax = .FALSE.   !true if option TAUMAX has been set on OLD STRATIFICATION card
+      bOVTauCut = .FALSE.
+      cVEXTEND = ' '
       fHYDROSTART = -99.    !starting from OLD MODEL using v infered from hydro (fraction > 0.)
+      VoldMod = 1.
       bFULLHYDROSTAT = .FALSE.
       bGAMMARADMEAN = .FALSE.
-      bOLDRAD = .FALSE.
+      iOLDRAD = 0
       RADGAMMASTART = -99.
+      POPMIN = 1.E-25           !default value should be the same as in STEAL -> DECSTE
       GEFFKEY = '        '
 C***  Mass-Luminosity relation default: 
       MFORM = 2     ! 1 = Langer (1989); 2 = Graefener et al. (2011) 
       WRTYPE = ''   ! default: automatic choice of type for M-L relation
+C***  LcalcCont = Codenumber for the conditions to calculate the Luminosity
+C***    0 =
+C***    1 = Mass input given
+C***    2 = Eddington-Gamma input given
+C***    3 = 1 + 2 = Mass and Eddington-Gamma input given 
+C***                -> L can be determined if R is given
       LcalcCond = 0
 
+C***  RcalcCond = Codenumber for the calculation of the radius
+C***    0 = not yet defined
+C***    1 = direct input
+C***    2 = LRT relation
+C***    4 = inferred from M and log g
+      RcalcCond = 0
+
 C***  MASSORIGIN = Codenumber for source of the stellar mass (for PRIPARAM)
 C***    0 = Mass-luminosity relation   
 C***    1 = input   
 C***    2 = log g   
 C***    3 = log geff plus Eddington Gamma
       MASSORIGIN = 0
-      VTURB = .0
+      VTURBND = .0
 
 C***  MDOTINPUT: origin of the mass-loss rate
 C      MDOTINPUT = -1 : not specified --> ERROR
@@ -183,12 +210,24 @@
 
 
 C***  CONSTRUCT MODEL HEADER  *********
-        CALL DATE_AND_TIME(DATE=TIM1, TIME=TIM2)
-        WRITE (DAT,'(A)') 
-     >       TIM1(3:4) // '/' // TIM1(5:6) // '/' // TIM1(7:8)
-        WRITE (TIM,'(A)') 
-     >       TIM2(1:2) // ':' // TIM2(3:4) // ':' // TIM2(5:6)
-
+      IF (OPSYS .EQ. 'DEC/UNIX') THEN
+        CALL MY_DATE (DAT)
+C        CALL DATE_AND_TIME(VALUES=DTVALUES)
+C        WRITE(UNIT=DAT,FMT='(I4,"/",I2,"/",I2)') 
+C     >          DTVALUES(1), DTVALUES(2), DTVALUES(3)
+        CALL MY_CLOCK(TIM)
+      ELSE IF (OPSYS .EQ. 'CRAY') THEN
+        !CALL DATE (DAT)
+        CALL DATE_AND_TIME(VALUES=DTVALUES)
+        WRITE(UNIT=DAT,FMT='(I4,"/",I2,"/",I2)') 
+     >          DTVALUES(1), DTVALUES(2), DTVALUES(3)
+        !CALL DATE_AND_TIME(DATE=DAT)
+        CALL CLOCK(TIM)
+      ELSE
+        WRITE (0,*) 'OPSYS NOT RECOGNIZED'
+        WRITE (0,*) 'OPSYS=', OPSYS
+        STOP 'ERROR IN SUBR. DECSTAR'
+      ENDIF
       MODHEAD='MODEL START'
       MODHEAD(13:)=DAT
       MODHEAD(25:)=TIM
@@ -240,8 +279,8 @@
 C                         =====
             TTABLE=.TRUE.
 
-      ELSEIF (ACTPAR(:7) .EQ. 'DRLINES' ) THEN
-C                              =======
+      ELSE IF (ACTPAR(:6) .EQ. 'DRLINE') THEN
+C                               ======  
          DRLINES_CARD = KARTE
 
       ELSE IF ((KARTE(:4) == 'THIN') .OR.
@@ -252,7 +291,7 @@
             IF (NPAR > 2) THEN
               DO IPAR=3, NPAR
                 CALL SARGV(ThinCard,IPAR,ACTPAR) 
-                IF (ACTPAR == 'FULL') THEN
+                IF (ACTPAR(1:4) == 'FULL') THEN
                   bFULLHYDROSTAT = .TRUE.
                 ENDIF
                 IF (ACTPAR == 'MEAN') THEN
@@ -275,21 +314,96 @@
       ELSE IF (KARTE(:8) == 'OLDSTART') THEN
 C                            ========
             bOLDSTART = .TRUE.
+            IF (NPAR > 1) THEN  
+              DO IPAR=2, NPAR
+                CALL SARGV (KARTE, IPAR, ACTPAR)
+C                IF (ACTPAR == 'DEPART') THEN
+C                  write info here!
+C                ENDIF
+C                IF (ACTPAR == 'TAU') THEN
+C                  write info here!
+C                ENDIF
+ccc             possible further values: DEPART, TAU (only read by ADAPTER currently)               
+              ENDDO
+           ENDIF
+           IF (.NOT. bOLDMODEL) GOTO 95
+              
+      ELSE IF (KARTE(:10) == 'HYDROSTART') THEN
+C                             ==========
+         fHYDROSTART = 1.
+        IF (NPAR > 1) THEN
+          CALL SARGV (KARTE,2,ACTPAR)
+          READ (ACTPAR, '(F10.0)', ERR=99) fHYDROSTART
+          IF (fHYDROSTART > 1. .OR. fHYDROSTART < 0.) THEN
+            WRITE (hCPR,'(A)') 'INVALID DAMPING VALUE FOR HYDROSTART'
+            GOTO 92
+          ENDIF
+        ENDIF
 
       ELSE IF (KARTE(:5) .EQ. 'OLD T') THEN
 C                              =====
             OLDTEMP=.TRUE.
             IF (KARTE(:9) .EQ. 'OLD T TAU') BTAUR = .TRUE.
+           IF (.NOT. bOLDMODEL) GOTO 95
+            
 
       ELSE IF (KARTE(:9) .EQ. 'OLD FGRID') THEN
 C                              =========
             OLDFGRID = .TRUE.
+           IF (.NOT. bOLDMODEL) GOTO 95
 
       ELSE IF ((KARTE(:9) .EQ. 'OLD STRAT')
-                               !=========
+C                               =========
      >    .OR. (KARTE(:5) .EQ. 'OLD V')) THEN
-                                !=====   
-         bOldStratification = .TRUE.
+C                                ======   
+        IF (.NOT. bOLDMODEL) GOTO 95
+        iOldStratification = 1
+        CALL SARGV (KARTE, 2, ACTPAR)
+        IF (NPAR > 2) THEN
+          DO i=3, NPAR 
+            CALL SARGV (KARTE, i, ACTPAR)
+            SELECTCASE (ACTPAR)
+              CASE ('VFINAL', 'VINF')
+                IF (NPAR >= (i+1)) THEN
+                  CALL SARGV (KARTE, i+1, NEXTPAR)
+                  READ (NEXTPAR, '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    VoldMod = tempREAL
+                    !store abolute value as negative number, modificator as positive
+                    VoldMod = -1. * VoldMod
+                  ENDIF
+                ENDIF
+              CASE ('MOD', 'VMOD', 'MODFAK')
+                IF (NPAR >= (i+1)) THEN
+                  CALL SARGV (KARTE, i+1, NEXTPAR)
+                  READ (NEXTPAR, '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    !store abolute value as negative number, modificator as positive
+                    VoldMod = tempREAL
+                  ENDIF
+                ENDIF
+              CASE ('GRID')
+                iOldStratification = 2
+              CASE ('TAU') 
+                cVEXTEND = 'TAU'
+              CASE ('EXTRAP') 
+                cVEXTEND = 'EXTRAP'
+              CASE ('SCALE', 'STRETCH')
+                cVEXTEND = 'STRETCH'
+              CASE ('DCNEW', 'DENSCON-UPDATE')
+                bForceDCUpdate = .TRUE.
+              CASE ('DCSCALE', 'DENSCON-SCALE')
+                bDCSCALE = .TRUE.
+              CASE ('MDOT', 'KEEPMDOT')
+                bOldMdot = .TRUE.
+              CASE ('TAUCUT')
+                bOVTauCut = .TRUE.
+              CASE ('TAUMAX')
+C***            revised Mar 2019: still iterate for TAUMAX by shifting V up/down to "hit" TAUMAX
+                bOVTauMax = .TRUE.
+            ENDSELECT
+          ENDDO
+        ENDIF
             
       ELSE IF (KARTE(:7) .EQ. 'TMODIFY') THEN
 C                              =======
@@ -345,22 +459,40 @@
       ELSE IF (ACTPAR .EQ. 'RSTAR') THEN
 C                           =====
       CALL SARGV (KARTE, 2, ACTPAR)
+        IF (ACTPAR == 'OLD') THEN
+          IF (.NOT. bOLDMODEL) GOTO 95
+          RSTAR = RSTARold/RSUN
+          WRITE (hCPR,'(A,F8.4)')
+     >      'RSTAR TAKEN FROM OLD MODEL: ', RSTAR
+        ELSE 
       READ (ACTPAR, '(F20.0)',ERR=92) RSTAR
+        ENDIF
+        RcalcCond = 1
  
       ELSE IF (KARTE(:5) .EQ. 'LOG L') THEN
 C                              =====
       CALL SARGV (KARTE, 3, ACTPAR)
+        IF (ACTPAR == 'OLD') THEN
+          IF (.NOT. bOLDMODEL) GOTO 95
+          XLOGL = XLOGLold
+          WRITE (hCPR,'(A,F8.4)')
+     >      'LUMINOSITY TAKEN FROM OLD MODEL: log L/Lsun = ', XLOGL
+        ELSE 
       READ (ACTPAR, '(F20.0)',ERR=92) XLOGL
+        ENDIF
   
       ELSE IF (KARTE(:6) .EQ. 'VELPAR') THEN
 C                              ======
-         CALL DECVELPAR(KARTE, VFINAL, VMIN, BETA, RMAX)
+         VMIN = VNDold
+         VFINAL = VFINALold
+         CALL DECVELPAR(KARTE, VFINAL, VMIN, BETA, RMAX, VOFF)         
          
       ELSE IF (ACTPAR .EQ. '2BETALAW') THEN
-         CALL SARGV (KARTE,3,ACTPAR)
-         READ (ACTPAR, '(F10.0)', ERR=99) BETA2 
-         CALL SARGV (KARTE,5,ACTPAR)
-         READ (ACTPAR, '(F10.0)', ERR=99) BETA2FRACTION 
+         CALL DEC2BETA(KARTE, BETA2, BETA2FRACTION, RONSET)
+c         CALL SARGV (KARTE,3,ACTPAR)
+c         READ (ACTPAR, '(F10.0)', ERR=99) BETA2 
+c         CALL SARGV (KARTE,5,ACTPAR)
+c         READ (ACTPAR, '(F10.0)', ERR=99) BETA2FRACTION 
  
       ELSE IF (KARTE(:4) .EQ. 'VDOP') THEN
 C                              ====
@@ -374,7 +506,15 @@
       ELSE IF (ACTPAR .EQ. 'MDOT') THEN
 C                           ====
         CALL SARGV (KARTE, 2, ACTPAR)
+        IF (ACTPAR == 'OLD') THEN
+          IF (.NOT. bOLDMODEL) GOTO 95
+          IF (XMDOTold < -100.) GOTO 96
+          XMDOT = XMDOTold
+          WRITE (hCPR,'(A,F8.4)')
+     >      'MASS LOSS RATE TAKEN FROM OLD MODEL: ', XMDOT
+        ELSE 
         READ (ACTPAR, '(F20.0)',ERR=92) XMDOT
+        ENDIF
         MDOTINPUT = 1 
 
       ELSE IF (ACTPAR(1:5) == 'MDOTT' .OR. ACTPAR == 'MDTRANS') THEN
@@ -386,7 +526,20 @@
       ELSE IF (ACTPAR .EQ. 'TEFF') THEN
 C                           ====
         CALL SARGV (KARTE, 2, ACTPAR)
+        IF (ACTPAR == 'OLD') THEN
+          IF (.NOT. bOLDMODEL) GOTO 95
+          TEFF = TEFFold
+          WRITE (hCPR,'(A,F8.4)')
+     >      'TSTAR (in CARDS: TEFF) TAKEN FROM OLD MODEL: ', TEFF
+        ELSE
+          IDXA = IDX(ACTPAR)
+          IF (ACTPAR(IDXA-2:IDXA) == 'DEX') THEN
+            READ (ACTPAR(:IDXA-3), '(F20.0)',ERR=92) TEFF
+            TEFF = 10.**TEFF
+          ELSE
         READ (ACTPAR, '(F20.0)',ERR=92) TEFF
+          ENDIF
+        ENDIF
 
       ELSE IF (ACTPAR .EQ. 'NCORE') THEN
 C                           =====
@@ -398,14 +551,28 @@
         CALL SARGV (KARTE, 2, ACTPAR)
         IF (ACTPAR .NE. '?') THEN
           IF (MASSORIGIN .NE. 0) THEN
+            IF (RcalcCond > 0) THEN
             WRITE (0, '(A)') '*** DOUBLE DEFINITION OF STELLAR MASS'
             GOTO 92
+            ELSE
+              RcalcCond = 4
           ENDIF
-          READ (ACTPAR, '(F20.0)', ERR=92) XMSTAR
+          ELSE
           MASSORIGIN = 1
           LcalcCond = LcalcCond + 1
         ENDIF
  
+          IF (ACTPAR == 'OLD') THEN
+            IF (.NOT. bOLDMODEL) GOTO 95
+            XMSTAR = XMSTARold
+            WRITE (hCPR,'(A,F8.4)')
+     >        'STELLAR MASS TAKEN FROM OLD MODEL: ', XMSTAR
+          ELSE 
+            READ (ACTPAR, '(F20.0)', ERR=92) XMSTAR
+          ENDIF
+
+        ENDIF
+ 
       ELSE IF ((KARTE(:10) .EQ. 'LOG G_GRAV') .OR.
      >         (KARTE(:9) .EQ. 'LOG GGRAV') .OR.
      >         (KARTE(:8) .EQ. 'LOG GRAV')) THEN
@@ -413,12 +580,17 @@
         CALL SARGV (KARTE, 3, ACTPAR)
         IF (ACTPAR .NE. '?') THEN
           IF (MASSORIGIN .NE. 0) THEN
+            IF (RcalcCond > 0) THEN
             WRITE (0, '(A)') '*** DOUBLE DEFINITION OF STELLAR MASS'
             GOTO 92
+            ELSE
+              RcalcCond = 4
           ENDIF
-          READ (ACTPAR, '(F20.0)', ERR=92) GLOG
+          ELSE
           MASSORIGIN = 2
         ENDIF
+          READ (ACTPAR, '(F20.0)', ERR=92) GLOG
+        ENDIF
  
       ELSE IF ((KARTE(:9) == 'LOG G_EFF') .OR.
 C                               =========
@@ -476,18 +648,31 @@
           LcalcCond = LcalcCond + 2
         ENDIF
 
+      ELSE IF (ACTPAR == 'QION-START') THEN
+
+        CALL SARGV (KARTE, 2, ACTPAR)
+        IF (ACTPAR /= 'AUTO') THEN
+          READ (ACTPAR, '(F20.0)', ERR=92) q
+        ENDIF
+ 
       ELSE IF (ACTPAR == 'RADGAMMA-START') THEN
 C                         ==============
         CALL SARGV (KARTE, 2, ACTPAR)
-        IF (ACTPAR /= 'OLD') THEN
-          READ (ACTPAR, '(F20.0)', ERR=92) RADGAMMASTART
-        ELSE
-          bOLDRAD = .TRUE.
+        IF (ACTPAR == 'CONT') THEN
+C***      Approximate Gamma_rad via continuum opacities        
+          iOLDRAD = 1
+        ELSEIF (ACTPAR == 'OLD') THEN
+C***      Take Gamma_rad from old MODEL
+          IF (.NOT. bOLDMODEL) GOTO 95
+          iOLDRAD = 2
           IF (NPAR > 2) THEN
             CALL SARGV (KARTE, 3, ACTPAR)
             !Use MEAN value only? (for WRSTART)
             IF (ACTPAR == 'MEAN') bGAMMARADMEAN = .TRUE.
           ENDIF
+        ELSE 
+C***      Take explicit given value        
+          READ (ACTPAR, '(F20.0)', ERR=92) RADGAMMASTART        
         ENDIF  
 
       ELSE IF (KARTE(:7) == 'MLANGER') THEN
@@ -583,34 +768,36 @@
             WRITE (0, *) '*** Valid types are: OB, WN, WC'
             GOTO 92
         ENDIF
-C***    VTURB enters the hydrostatic equation via 
-C***          P_gas = rho * (v_sound^2 + v_turb^2)
-C***          and, therefore, differs from the definition of v_mic
-C***          (hitherto only in FORMAL) for the line broadening:
-C***          v_dop = sqrt( v_th^2 + v_mic^2) 
-C***          Hence: v_mic = sqrt(2) * v_turb
-      ELSE IF (ACTPAR .EQ. 'VTURB') THEN
+        
+      ELSE IF (ACTPAR == 'VTURB') THEN
+        VTURB_LINE = KARTE
         IF (NPAR .GT. 1) THEN
            CALL SARGV (KARTE, 2, ACTPAR2)
-           READ (ACTPAR2,'(F20.0)',ERR=98) VTURB
+           READ (ACTPAR2,'(F20.0)',ERR=98) VTURBND
         ELSE
            GOTO 97
         ENDIF
-      ELSE IF (ACTPAR .EQ. 'VMIC') THEN
+        
+      ELSE IF (ACTPAR == 'VMIC') THEN
+        VTURB_LINE = KARTE
         IF (NPAR .GT. 1) THEN
            CALL SARGV (KARTE, 2, ACTPAR2)
-           READ (ACTPAR2,'(F20.0)',ERR=98) VTURB
-           VTURB = VTURB / SQRT(2.) 
+           READ (ACTPAR2,'(F20.0)',ERR=98) VTURBND
+           VTURBND = VTURBND / SQRT(2.)
         ELSE
            GOTO 97
         ENDIF
 
-      ELSE IF (ACTPAR(:8) .EQ. 'BLUEMOST') THEN
+      ELSE IF (ACTPAR == 'POPMIN') THEN
+C                         ======
+        CALL SARGV (KARTE, 2, ACTPAR)
+        READ (ACTPAR, '(F20.0)',ERR=92) POPMIN
+        
+      ELSE IF (ACTPAR(:8) == 'BLUEMOST') THEN
 C                           ========
          CALL SARGV (KARTE, 2, ACTPAR2)
          READ (ACTPAR2, '(F20.0)',ERR=92) XLAMBLUE
 
-
 C*********** SPECIAL BLOCK FOR X-RAYS  **************************
       ELSE IF (ACTPAR .EQ. 'XRAY') THEN
 C                           ====
@@ -660,9 +847,17 @@
             IF (ACTPAR .EQ. 'BLACKEDGE') THEN
                CALL SARGV (KARTE, 3, ACTPAR)
                READ (ACTPAR, '(F10.0)', ERR=92) BLACKEDGE
+            ELSEIF (ACTPAR == 'OLD') THEN
+               bOLDJ = .TRUE.
+               IF (.NOT. bOLDMODEL) GOTO 95
             ENDIF
          ENDIF
 
+      ELSE IF (KARTE(:5) == 'OLD J') THEN
+         LTESTART = .FALSE.
+         bOLDJ = .TRUE.
+         IF (.NOT. bOLDMODEL) GOTO 95
+
       ELSE IF (ACTPAR .EQ. 'SPECIAL_OUTER_POINTS') THEN
          RadiusGridParameters(2) = KARTE
 
@@ -694,25 +889,11 @@
                      GOTO 92
                   ENDIF
                   ABXYZ(K)=ABUND
-C*                Default: by number 
-                  IF (NPAR .EQ. 2) THEN
-                     IF (ABMASS) GOTO 91
-                     ABNUMB=.TRUE.
-                  ENDIF
-C*                Check for "mass" or "number"
-                  DO IPAR=3, NPAR
-                     CALL SARGV (KARTE, IPAR, ACTPAR2)
-                     CALL LOWERCASE (ACTPAR2)
-                     IF (ACTPAR2(:4) .EQ. 'mass' .OR. 
-     >                   ACTPAR2(:5) .EQ. '(mass') THEN
-                        IF (ABNUMB) GOTO 91
+                  IF (KARTE(21:30) .NE. ' ') THEN
                         ABMASS=.TRUE.
-                     ELSEIF (ACTPAR2(:6) .EQ. 'number' .OR. 
-     >                       ACTPAR2(:7) .EQ. '(number') THEN
-                        IF (ABMASS) GOTO 91
+                  ELSE
                         ABNUMB=.TRUE.
                      ENDIF
-                  ENDDO
                   EXIT
                ENDIF
             ENDDO
@@ -734,6 +915,14 @@
       CLOSE (1)
 C******************************************************************
 
+C***  ERROR STOP IN CASE OF MIXED TYPES (BY NUMBER / MASS FRACTION) OF
+C***  ABUNDANCE VALUES
+      IF (ABMASS .AND. ABNUMB) THEN
+        WRITE (0,*) 
+     >  'ALL abundances must be given EITHER by mass OR by number!'
+         GOTO 92
+      ENDIF
+
 C***  COMPUTATION OF THE RELATIVE ABUNDANCE (BY NUMBER OR MASS FRACTION)
 C***  OF HELIUM
       ABREST=0.
@@ -745,6 +934,7 @@
 
       IF (ABREST .GT. 1.) THEN
          WRITE(hCPR,'(A)') 'REL. ABUNDANCES add up to more than 100%'
+         WRITE(hCPR,*) ' SUM of non-HE elements: ', ABREST
          STOP 'ERROR detected in DECSTAR'
       ENDIF
 
@@ -821,6 +1011,7 @@
          ENDIF
       ENDIF      
 
+      IF (q < 0.) THEN
 C***  Start approximation for q (number of free electrons per mass unit)
       !@todo: Set Q depending on type of star or s.th. like that
       !q = n_e / (AMU n_i) aber diese Groessen sind erst spaeter bekannt
@@ -838,10 +1029,18 @@
       ELSE
         q = 0.25    !WNE
       ENDIF
-
+      ENDIF
 
 C***  CHECK OF MISSING SPECIFICATIONS
 
+C***  Rstar has not been specified in the CARDS
+C***    but can be inferred from LOG GGRAV and MSTAR            
+      IF (RSTAR < .0 .AND. XMSTAR > 0. .AND. GLOG > 0.) THEN
+        RSTAR = SQRT(GCONST * XMSTAR * XMSUN / 10.**GLOG)
+        RSTAR = RSTAR / RSUN
+        RcalcCond = 4
+      ENDIF
+
       bLRTcomplete = .FALSE.
       IF (TEFF < .0) THEN
         IF ((RSTAR > 0.) .AND. (XLOGL /= -99)) THEN
@@ -872,17 +1071,20 @@
             STOP 'ERROR'
       ENDIF
 
+
       IF (.NOT. bLRTcomplete) THEN
         !This is only called if TEFF has been set in the CARDS file
         IF (RSTAR < .0) THEN
-          !Rstar has not been specified in the CARDS
+          !Rstar has not been specified in the CARDS and could not be inferred from log g and M
           IF (XLOGL .NE. -99.) THEN
             RSTAR = 10.**(0.5*XLOGL) / (TEFF/TEFFSUN)**2
+            RcalcCond = 2
             LRTinput = 2
           ELSEIF (LcalcCond == 3) THEN
             !In the rare case that MSTAR and EDDINGTON-GAMMA are given, L can be calculated:
             XLOGL = LOG10( GEDD * XMSTAR / ( 10**(-4.51) * q ) )
             RSTAR = 10.**(0.5*XLOGL) / (TEFF/TEFFSUN)**2
+            RcalcCond = 2
             LRTinput = 4
           ELSE
               WRITE(hCPR,'(A)') 
@@ -972,7 +1174,8 @@
  
 C***  OPTION 'OLDTEMP' OVERWRITES OTHER OPTIONS:
       IF (OLDTEMP) THEN
-         TTABLE=.FALSE.
+ccc        De-activated by ansander, 17-03-2021 
+ccc         TTABLE=.FALSE.
          SPHERIC=.FALSE.
          TMIN=.0
       ENDIF
@@ -991,10 +1194,11 @@
 
      
       !Warning if full a_rad integration should be performed, but no good start is given
-      IF (bFULLHYDROSTAT .AND. (.NOT. bOldStratification)
-     >      .AND. (.NOT. bOLDRAD) .AND. RADGAMMASTART < 0.) THEN
+      IF (bFULLHYDROSTAT .AND. (iOldStratification == 0)
+     >      .AND. (iOLDRAD == 0) .AND. RADGAMMASTART < 0.) THEN
         WRITE (hCPR,'(A)') 'WARNING: HYDROSTATIC INTEGRATION'
-     >                          // ' will have a poor start'
+     >                          // ' will have a poor start. ' 
+     >      // 'Set RADGAMMA-START card to improve the situation!'
       ENDIF
       
       !System g/M, geff, GEDD ueberbestimmt        
@@ -1058,7 +1262,7 @@
          !LOG G vorgegeben oder aus LOG GEFF und GEDD berechnet
          XMSTARG = 10.**GLOG * RSTAR * RSTAR / GCONST 
          XMSTAR = XMSTARG / XMSUN
-      ELSE
+      ELSEIF (RcalcCond .NE. 4) THEN
          !Masse direkt vorgegeben
          bCalcGLOGfromM = .TRUE.
       ENDIF
@@ -1133,7 +1337,7 @@
       ENDIF
   
   
-      IF (bOldStratification) THEN
+      IF (iOldStratification > 0) THEN
         THIN = .FALSE.      !Ignore HYDROSTATIC INTEGRATION in WRSTART if OLD STRAT is used
       ENDIF
   
@@ -1142,18 +1346,21 @@
 
 C***  ERROR EXITS ****************************************************
 
-   91 CONTINUE
-      WRITE (0,*) 'ERROR: ' //  
-     >  'ALL abundances must be given EITHER by mass OR by number!'
-      WRITE (0,*)   
-     >   'Default if Element line has no further option: by number' 
-      GOTO 92
-
    92 CONTINUE
       WRITE (0,*)'DECSTAR: ERROR WHILE DECODING THE FOLLOWING LINE:'
       WRITE (0,*) KARTE
       STOP 'ERROR'
 
+   95 WRITE (hCPR,'(A)') 'DECSTAR: OLD MODEL REQUIRED BUT NOT FOUND!'
+      WRITE (hCPR,'(A)') 'AN OLD MODEL IS REQUIRED DUE TO THE LINE: '
+      WRITE (hCPR,'(A)') KARTE(:IDX(KARTE))
+      STOP 'FATAL ERROR IN DECSTAR'
+
+   96 WRITE (hCPR,'(A)') 'DECSTAR: OLD MODEL DOES NOT CONTAIN MDOT!'
+      WRITE (hCPR,'(A)') 'AN OLD MODEL IS REQUIRED DUE TO THE LINE: '
+      WRITE (hCPR,'(A)') KARTE(:IDX(KARTE))
+      STOP 'FATAL ERROR IN DECSTAR'
+      
    97 WRITE (0,'(A)') '*** ERROR: PARAMETER MISSING'
       WRITE (0,'(A)') 'THE ERROR OCCURED IN THE FOLLOWING LINE: '
       WRITE (0,'(A)') KARTE(:IDX(KARTE))
diff -bur ./decste.f ../../powr-refactor/src/decste.f
--- ./decste.f	2024-07-28 13:13:15.000000000 +0200
+++ ../../powr-refactor/src/decste.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,103 +1,112 @@
       SUBROUTINE DECSTE (                                                   !Parameter count
      >     LSRAT,LSPOP,JOBMAX,EPSILON,REDUCE,IHIST,                         !6
      >     IFRRA, ITORA, IPRICC, IPRILC, LSEXPO, LSTAU, IFLUX,              !13
-     >     IDAT, LEVELPL, MAXSETS, NPLOT, NDIM, NEWWRC, 
-     >     NGAMC,NGAMR,NGAML,NGAMD,AGAMC,AGAMR,AGAML,AGAMD,DELTAC,          !29
-     >     TPLOT, TPLOTOPT, JOBNUM, NOEXTRAP, MODHIST,        !36
-     >     STHLP,NODATOM,NSCHAR,NOLAP,ITBR,ITMAX,OLDSTART,COMPO,            !44
-     >     ELEMENT,SYMBOL,NATOM,NATOUT,BRRESET,                             !49
-     >     DRLINES_CARD,NOPOP, BAUTO, BAUTO_ABORT, SMALLPOP, POPMIN,             !55
-     >     BINBOX, POPRANG,                                                 !57
-     >     COREX, BCOREX, VPLOT, BUNLU, UNLUTECLINE, BPRIUNLU,              !63
-     >     ND, IPRINTZERORATES, PRILEVRA,                                   !66
-     >     LEVELPLDEP, NPLOTDEP,                                            !68
-     >     BITCONT, bTDIFFUS, BPGAHIST, AG, BAG, BPGAHISTE,                 !74
-     >     PLOTOPT, MAXPLOTOPT, NPLOTOPT, OPC, BTALTER,                     !79
-     >     BPLOCC, LPLOCC, KPLOCC, BRUDZERO,                                !83
-     >     BXJLAPPNEW, BXJCAPPNEW, BNEWOPER, IPLOT_XJLAPP, IPLOT_XJCAPP,    !90
-     >     LPLOT_XJCAPP, NITER_PLOT_JAPP, BPLOTAPP, BNEWTONRESET,           !94
-     >     XLAM_FINE_START, XLAM_FINE_END, BTRACE_POPNUM,                   !97
-     >     BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX,                  !101
-     >     BNUEFE, BXJLAPPCORE, WJCMIN, NKONV_THRESH,                       !105
-     >     iBLOCKINVERSION, RSTAR, RMAX, TAUMAX, bENSURETAUMAX, TAUACC,     !111
-     >     bTauStrict, ReduceTauCorrections, TauCorLimits, FQLIMIT,         !115
-     >     RadiusGridParameters, VMIN, bThinWind, ThinCard, bSUMMARY,       !120   
-     >     bHYDROSOLVE, bLateTau, HydroCard, AlphaCard,                     !124
-     >     DENSCON_FIX, DENSCON_LINE, MFORM, XMSTAR, GLOG, bUpdateMass,     !130
-     >     WRTYPE, MODHEAD, bModHeadUpdate, bOLDVELO, bTauMaxSafe,          !135
-     >     bFULLHYDROSTAT, bGAMMARADMEAN, GEDDreduce, iZRType, iAMT,        !140
-     >     CLUMP_SEP, MacroCard, OPALINE_SCALE, NBACKUP, GEFFKEY, bUCPP,    !146
-     >     FLUXEPS, HYSTACC, IHSSTATUS, bNoFeTCORR, bUseTWOPNT,             !151
-     >     bRELSCHARMERACC)     
+     >     IDAT, LEVELPL, MAXSETS, NPLOT, NDIM, NEWWRC,                     !19
+     >     NGAMC,NGAMR,NGAML,NGAMD,AGAMC,AGAMR,AGAML,AGAMD,DELTAC,          !28
+     >     TPLOT, TPLOTOPT, JOBNUM, NOEXTRAP, MODHIST,                      !33
+     >     STHLP,NODATOM,NSCHAR,NOLAP,ITBR,ITMAX,OLDSTART,COMPO,            !41
+     >     ELEMENT,SYMBOL,NATOM,NATOUT,BRRESET,                             !46
+     >     DRLINES_CARD, NOPOP, BAUTO, BAUTO_ABORT, SMALLPOP, POPMIN,       !52
+     >     BINBOX, POPRANG,                                                 !54
+     >     COREX, BCOREX, VPLOT, BUNLU, UNLUTECLINE, BPRIUNLU,              !60
+     >     ND, IPRINTZERORATES, PRILEVRA,                                   !63
+     >     LEVELPLDEP, NPLOTDEP,                                            !65
+     >     BITCONT, bTDIFFUS, BPGAHIST, AG, BAG, BPGAHISTE,                 !71
+     >     PLOTOPT, MAXPLOTOPT, NPLOTOPT, OPC, BTALTER,                     !76
+     >     BPLOCC, LPLOCC, KPLOCC, BRUDZERO,                                !80
+     >     BXJLAPPNEW, BXJCAPPNEW, BNEWOPER, IPLOT_XJLAPP, IPLOT_XJCAPP,    !85
+     >     LPLOT_XJCAPP, NITER_PLOT_JAPP, BPLOTAPP, BNEWTONRESET,           !89
+     >     XLAM_FINE_START, XLAM_FINE_END, BTRACE_POPNUM,                   !92
+     >     BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX,                  !96
+     >     BNUEFE, BXJLAPPCORE, WJCMIN, NKONV_THRESH,                       !100
+     >     iBLOCKINVERSION, RSTAR, RMAX, TAUMAX, bENSURETAUMAX, TAUACC,     !106
+     >     bTauStrict,                                                      !107
+     >     RadiusGridParameters, VMIN, bThinWind, ThinCard, bSUMMARY,       !112   
+     >     TaumaxCard, bHYDROSOLVE, bLateTau, HydroCard, AlphaCard,         !117
+     >     DENSCON_FIX, DENSCON_LINE, MFORM, XMSTAR, GLOG, bUpdateMass,     !123
+     >     WRTYPE, MODHEAD, bModHeadUpdate, bOLDVELO,                       !127
+     >     bFULLHYDROSTAT, bGAMMARADMEAN, GEDDreduce, iZRType, iAMT,        !132
+     >     CLUMP_SEP, MacroCard, OPALINE_SCALE, NBACKUP, GEFFKEY,           !137
+     >     bHydroHelp, bHYSTloose, ICMMODE, bUCPP,                          !141
+     >     bUpdateVT, VTURB, fTNDCOR, bTMTHOM, bKUBATDEBUG,                 !146
+     >     bRELSCHARMERACC, bUseTWOPNT, FLUXEPS, HYSTACC, IHSSTATUS,        !151
+     >     NDOUT, VTURB_LINE, ALOMIN, bLAMAPPCOLI, bDDVDOP,                 !156
+     >     bFRACINV, bForceTDIFFUS, bNoFeTCORR, TRACEELEM, bINCADV,         !161
+     >     ENTOT, RHO, iALOentry, bALOTri)                                  !165
+
 C*******************************************************************************
 C***  DECODING INPUT OPTIONS FOR MAIN PROGRAM "STEAL"
 C*******************************************************************************
 
       IMPLICIT NONE
 
-      INTEGER :: I, J, IN, MAXPLOTOPT, MAXSETS, NDIM, ND,
-     >           NA, NATOM, NATOUT, ITBR, NLINE, IPRINTZERORATES, NPAR,
-     >           IND, ISTART, IERR, IHSSTATUS,
+      INTEGER :: I, J, K, IN, MAXPLOTOPT, MAXSETS, NDIM, ND, L,
+     >           NA, NATOM, NATOUT, ITBR, IPRINTZERORATES, NPAR,
+     >           IND, ISTART, IERR, IHSSTATUS, NZ,
      >           LSTAU, LSRAT, LSPOP, LSEXPO,
      >           IHIST, IFLUX, IDAT, IPRICC, IPRILC,
      >           JOBNUM, JOBMAX, NPLOT, NPLOTDEP, NPLOTOPT,
      >           NEWWRC, NSCHAR, ITMAX, MASSORIGIN, NKONV_THRESH,
      >           IDX, LPLOCC, KPLOCC, IFRRA, ITORA,
-     >           MGC, MGR, MGL, MGD, MFORM, iAMT,
+     >           MGC, MGR, MGL, MGD, MFORM, iAMT, ICMMODE, NDOUT,
      >           DELTAC, NITER_PLOT_JAPP, iBLOCKINVERSION, iZRType,
      >           IPLOT_XJLAPP, IPLOT_XJCAPP, LPLOT_XJCAPP, NBACKUP
 
+      INTEGER, INTENT(IN) :: iALOentry
+
       !INTEGER :: IFIX   !IFIX(x) ist ein Alias von INT(x) : konvertiert Real in Integer
 
 
       CHARACTER(256) :: KARTE, TPLOTOPT
-      CHARACTER(1200) :: UNLUTECLINE
-      CHARACTER(120) :: DENSCON_LINE, 
-     >                 ThinCard, HydroCard, AlphaCard, MacroCard
+      CHARACTER(1200) :: UNLUTECLINE, HydroCard
+      CHARACTER(120) :: DENSCON_LINE, VTURB_LINE, DRLINES_CARD,
+     >                 ThinCard, AlphaCard, MacroCard, TaumaxCard
       CHARACTER(256), DIMENSION(MAXPLOTOPT) :: PLOTOPT
       CHARACTER(10), DIMENSION(MAXSETS, NDIM) :: LEVELPL, LEVELPLDEP
       CHARACTER(10), DIMENSION(NATOM) :: ELEMENT
+      LOGICAL, DIMENSION(NATOM) :: TRACEELEM
       CHARACTER(2), DIMENSION(NATOM) :: SYMBOL
       CHARACTER(10) :: PRILEVRA
       CHARACTER(8) :: OPC, GEFFKEY
       CHARACTER(2) :: WRTYPE
       CHARACTER(40) :: CURPAR
       CHARACTER(100) :: MODHEAD, HEADLINE
-      CHARACTER*80  DRLINES_CARD
+
       REAL, DIMENSION(10) :: AGAMC,AGAMR,AGAML,AGAMD
       REAL, DIMENSION(7) :: AG
-      REAL, DIMENSION(2), INTENT(OUT) :: TauCorLimits
+      REAL, DIMENSION(ND) :: VTURB, ENTOT, RHO
 
       INTEGER, DIMENSION(1) :: MODHIST
       INTEGER, DIMENSION(10) :: NGAMC,NGAMR,NGAML,NGAMD
 
 
-      LOGICAL NOEXTRAP, TPLTAU, STHLP, NODATOM, NOLAP, OLDSTART,
-     >        COMPO, NOPOP, BAUTO, BAUTO_ABORT, NEWATOM,
-     >        BCOREX, BUNLU, BPRIUNLU, bUCPP, bNoFeTCORR
-      LOGICAL BRUDZERO, bUseTWOPNT, bRELSCHARMERACC
-      LOGICAL BITCONT, bTDIFFUS, BPGAHIST, BAG, BPGAHISTE, BNEWTONRESET
-      LOGICAL RMAX_IN_RSUN
+      LOGICAL :: NOEXTRAP, TPLTAU, STHLP, NODATOM, NOLAP, OLDSTART,
+     >           COMPO, DRNORUD, NOPOP, BAUTO, BAUTO_ABORT, NEWATOM,
+     >           BCOREX, BUNLU, BPRIUNLU, bUCPP, bTMTHOM, BNEWTONRESET,
+     >           bUseTWOPNT, BRUDZERO, RMAX_IN_RSUN, bRELSCHARMERACC,
+     >           BITCONT, bTDIFFUS, BPGAHIST, BAG, BPGAHISTE, bDDVDOP,
+     >           bForceTDIFFUS, bNoFeTCORR, bALOTri
       REAL :: RSTAR, RMAX, DENSCON_FIX, XL, XLC, XMSTAR, HYSTACC,
-     >        EPSILON, REDUCE, Y0, BRRESET, COREX,
-     >        YMAX, YMIN, XMAX, XMIN,
+     >        EPSILON, REDUCE, Y0, BRRESET, COREX, ALOMIN,
+     >        YMAX, YMIN, XMAX, XMIN, fTNDCOR,
      >        GAMMA, GAMMAC, GAMMAR, GAMMAL, GAMMAD, 
      >        ANG, ANGC, ANGR, ANGL, ANGD,
      >        SMALLPOP, SMALLPOP2, POPMIN, POPRANG, WJCMIN,
      >        XLAM_FINE_START, XLAM_FINE_END, CLUMP_SEP, OPALINE_SCALE,
-     >        tempREAL, ReduceTauCorrections, GEDDreduce, HYSTACCMIN
+     >        tempREAL, GEDDreduce, HYSTACCMIN, RONSET, RSTARorg
       REAL :: VFINAL, VMIN, VMINCAND, BETA, BETA2, BETA2FRACTION,
-     >        VPAR1, VPAR2, VPAR1_2, VPAR2_2, RCON, HSCALE,
-     >        TAUMAX, TAUACC, GLOG, FQLIMIT, FLUXEPS
-      LOGICAL NOTEMP,TPLOT, BINBOX, VPLOT
+     >        VPAR1, VPAR2, VPAR1_2, VPAR2_2, RCON, HSCALE, VTURBND,
+     >        TAUMAX, TAUACC, GLOG, POPMIN_OLD, VCON, FLUXEPS
+      LOGICAL NOTEMP,TPLOT, BINBOX, VPLOT, bFRACINV, bINCADV
       LOGICAL BPLOCC, BNUEFE
       LOGICAL BXJLAPPNEW, BXJCAPPNEW, BNEWOPER, BXJLAPPCORE,
      >        BPLOTAPP, BTRACE_POPNUM, BTALTER,
      >        BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX,
      >        bENSURETAUMAX, bHYDROSOLVE, bLateTau,
      >        bThinWind, bTauStrict, bSUMMARY, bUpdateMass, 
-     >        bModHeadUpdate, bOLDVELO, bTauMaxSafe, 
-     >        bFULLHYDROSTAT, bGAMMARADMEAN
+     >        bModHeadUpdate, bOLDVELO, bLAMAPPCOLI,
+     >        bFULLHYDROSTAT, bGAMMARADMEAN, bKUBATDEBUG,
+     >        bHydroHelp, bHYSTloose, bUpdateVT, bSMOCO
       CHARACTER(80), DIMENSION(3) :: RadiusGridParameters           !contains all RADIUS-GRID CARDS (for subr. RGRID)
 
       COMMON/VELPAR/ VFINAL,VMINCAND,BETA,VPAR1,VPAR2,RCON,HSCALE,
@@ -182,7 +191,8 @@
       MGL=1
       MGD=1
       DELTAC=1.0
-
+      bLAMAPPCOLI = .FALSE.
+      bALOTri = .FALSE.
 C***  DR-RATES CALCULATED WITH CONTINUUM RADIATION FIELD
       DRLINES_CARD = ''
 C***  RUDIMENTAL LINES ARE SET TO f=0 (NO RADIATIVE RATES)
@@ -235,19 +245,36 @@
       BINBOX = .FALSE.
 C***  DIFFUSION APPROXIMATION is now standard (old TDIFFUS cards line)
       bTDIFFUS = .TRUE.
+      bForceTDIFFUS = .FALSE.
+      fTNDCOR = 0.
+C***  Default: TAUMAX value does not refer to THOMSON scale
+      bTMTHOM = .FALSE.
+C***  Default: No debug output for thermal balance routine
+      bKUBATDEBUG = .FALSE.
 C***  Default: Absolute accuracy for Scharmer iteration (instead of relative)
       bRELSCHARMERACC = .FALSE.
 C***  Default: Allow the use of the Two-point Broyden method
       bUseTWOPNT = .TRUE.
+C***  Default: Do not invert DM matrix for fractional corrections
+      bFRACINV = .FALSE.
 C***  Default: Do not switch off temperature correction of COLI Fe rates
       bNoFeTCORR = .FALSE.
+C***  Default: Do not consider advection terms in INITFCORR
+      bINCADV = .FALSE.
 
 C***  SMALLPOP: smaller POPNUMS are not accounted for covergence criterion
 C***            of the inner iteration
       SMALLPOP = 1.E-12
+C***  NDOUT: outermost depth point considered for convergence criterion 
+C***         Default: Negative or zero value = automatic calculation in PRICORR
+      NDOUT = -1
 
 C***  POPMIN: smaller POPNUMs are set to this value 
+      IF (POPMIN < 1.E-99) THEN
       POPMIN = 1.E-25
+      ELSE 
+        POPMIN_OLD = POPMIN
+      ENDIF
 
 C***  RANGE OF POPNUM PLOT
       POPRANG = -15.
@@ -272,6 +299,8 @@
 C***  Clumping stuff 
       DENSCON_FIX = 1.
       DENSCON_LINE = ' '
+C***  Depth-dependent microturbulence
+      VTURB_LINE = ' '
 
 C***  Do not use new Integration of Approximate Radiation Fields
       BXJLAPPNEW  = .FALSE.
@@ -307,7 +336,8 @@
       BTRACE_POPNUM = .FALSE.
 
 C***  Minimum Scharmer Weight
-      WJCMIN = 0.1
+      WJCMIN = 0.1    !continua
+      ALOMIN = 0.1    !lines
 
 C***  Threshold for maximum number of allowed diverged points in LINPOP
       NKONV_THRESH = 30      
@@ -323,11 +353,6 @@
       TAUACC = 1.E-4
       bENSURETAUMAX = .FALSE.
       bTauStrict = .TRUE.
-      ReduceTauCorrections = 1.0    !default reducing factor for vmin changes in taumax enforcement routine
-      TauCorLimits(1) = -999.       !
-      TauCorLimits(2) = -999.
-      bTauMaxSafe = .FALSE.
-      FQLIMIT = -1.                 !default: no flux ratio limit for TAUMAX fixing
       GEDDreduce = 1.               !default: do not take a fraction of last GEDDRAD
       FLUXEPS = -1.
       bUCPP = .FALSE.
@@ -337,8 +362,13 @@
 C***  HYDRO PARAMATERS (added 17.08.2011 by ansander)           
       bHYDROSOLVE = .FALSE.     !Default: hydro branch is not used
       bLateTau = .FALSE.        !Default: Tau iteration is done directly after hydro
+      bHYSTloose = .FALSE.
       
       UNLUTECLINE = 'UNLUTEC'
+      HydroCard = 'HYDRO'
+      
+C***  Use Depth-dependent doppler profiles? (Default = no)
+      bDDVDOP = .FALSE.
       
 C***  Write model parameter summary file in this steal job
       bSUMMARY = .FALSE.
@@ -347,6 +377,7 @@
       iZRType = 1               !Default: Standard method for ZERO_RATES determination
                                 !Values: 0 = no ZERO_RATES, 1 = standard/wrh, 2 = Goetz method
       iAMT = 0                  !AUTO MODIFY TEMPERATURE switch (0 = UNLU, 1 = TEMP, -1 = NOTEMP)                                
+      ICMMODE = 1               !CORRMAX calculation modus (0 = consider everything, 1 = consider only converged)
       
       !how to calculate stellar mass (needed? perhaps not here but in wrstart)
       ! 0 = Mass-luminosity relation   
@@ -356,12 +387,18 @@
       MFORM = 2         !New default: Use Goetz formula if MASSORIGIN = 0
       bUpdateMass = .FALSE.
       bModHeadUpdate = .FALSE.
+      bUpdateVT = .FALSE.
       bOLDVELO = .FALSE.
       CLUMP_SEP = 0.            !default: no macroclumping
       OPALINE_SCALE = 1.        !default: no scaling of line opacities (changes a_lines)
+      DO K=1, NATOM
+        TRACEELEM(K) = .FALSE.
+      ENDDO
 
 C***  END OF DEFAULT SETTINGS  -----------------------------------------
 
+      RSTARorg = RSTAR          !Backup input RSTAR (for update option)
+
       OPEN (1, FILE='CARDS', STATUS='UNKNOWN')
       REWIND 1
     8 READ (1,4, END=99) KARTE
@@ -380,7 +417,6 @@
    20  CONTINUE
 C***  Erase not used parameter fields
       DO 98, I=NPAR+1, 20
-ccc??        ACTPAR(I) = ''
         ACTPAR(I) = '0.0'
 98    CONTINUE
 
@@ -470,7 +506,9 @@
      >            ACTPAR(2)  ==  'ALPHA' .OR. 
      >            ACTPAR(2)  ==  'GAMMA' .OR. 
      >            ACTPAR(2)  ==  'SIGMAFE' .OR. 
+     >            ACTPAR(2)  ==  'FGSTRAT' .OR. 
      >            ACTPAR(2)  ==  'FORCEMULT' .OR. 
+     >            ACTPAR(2)  ==  'ACCELEM' .OR. 
      >            ACTPAR(2) .EQ. 'ACC'        ) THEN
             IF (NPLOTOPT .EQ. MAXPLOTOPT) THEN
                WRITE (0, '(A,/,A,/,A)') 'STEAL: WARNING ----  MORE ' //
@@ -693,8 +731,8 @@
 C                              ======
             READ (ACTPAR(2), '(F10.0)', ERR=1) DELTAC
 
-      ELSE IF (ACTPAR(1) .EQ. 'DRLINES') THEN
-C                              =======
+      ELSE IF (KARTE(:6) .EQ. 'DRLINE') THEN
+C                              ======
          DRLINES_CARD = KARTE
  
       ELSE IF (KARTE(:8) .EQ. 'NO TEMPE') THEN
@@ -731,6 +769,9 @@
 C                              =====
             READ(ACTPAR(2),'(I10)',ERR=1) ITMAX
             
+      ELSE IF (ACTPAR(1)(1:7) == 'FRACINV') THEN
+C                                 =======
+            bFRACINV = .TRUE.
       ELSE IF (ACTPAR(1) == 'SPLITINVERSION') THEN
 C                            ==============
             iBLOCKINVERSION = 1
@@ -747,6 +788,42 @@
                ENDIF
             ENDIF            
  
+      ELSE IF (ACTPAR(1) == 'ZERORATES') THEN
+C                            =========
+C     @TODO:  Check for good keywords for the particular methods
+            IF (NPAR == 2) THEN
+               IF (ACTPAR(2) == 'NONE') THEN
+                 iZRType = 0
+               ELSEIF (ACTPAR(2) == 'PREDICT') THEN
+                 iZRType = 1
+               ELSEIF (ACTPAR(2) == 'LADDER') THEN
+                 iZRType = 2
+               ELSE
+                  READ (ACTPAR(2), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                      iZRType = IFIX(tempREAL)
+                  ENDIF
+               ENDIF
+            ENDIF                  
+
+      ELSE IF (ACTPAR(1) == 'CMMODE') THEN
+C                            ======
+C     @TODO:  Check for good keywords for the particular methods
+            IF (NPAR == 2) THEN
+               IF (ACTPAR(2) == 'ALL') THEN
+                 ICMMODE = 0
+               ELSEIF (ACTPAR(2) == 'CONVERGED') THEN
+                 ICMMODE = 1
+C               ELSEIF (ACTPAR(2) == 'LADDER') THEN
+C                 iZRType = 2
+               ELSE
+                  READ (ACTPAR(2), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                      ICMMODE = IFIX(tempREAL)
+                  ENDIF
+               ENDIF
+            ENDIF                  
+            
       ELSE IF (ACTPAR(1) .EQ. 'NO' .AND. ACTPAR(2) .EQ. 'OVERLAP') THEN
 C                              ==                        =======
             NOLAP = .TRUE.
@@ -805,9 +882,19 @@
          IF (SMALLPOP2 .NE. SMALLPOP) THEN
             WRITE (*,'(A, G12.3, A, G12.3)') 
      >        'STEAL/DECSTE: WARNING: SMALLPOP=', SMALLPOP2, 
-     >        'choosen different from recommended default', SMALLPOP 
+     >        ' chosen different from recommended default', SMALLPOP 
             ENDIF
             SMALLPOP = SMALLPOP2
+C***     Optional parameter for outermost depth point considered in CORMAX
+C***     (This is passed to STEAL->PRICORR)   added by ansander, 05-Oct-2016
+         IF (ACTPAR(3) == 'NDOUT') THEN
+           IF (ACTPAR(4) /= 'AUTO') THEN
+             READ (ACTPAR(4),'(F10.0)', ERR=1, IOSTAT=IERR) tempREAL
+             IF (IERR == 0) THEN
+               NDOUT = tempREAL
+             ENDIF
+           ENDIF
+         ENDIF
 
       ELSE IF (ACTPAR(1)(1:6) .EQ. 'POPMIN' ) THEN
 C                                   =======
@@ -826,6 +913,22 @@
 C                             ======================
             BITCONT = .FALSE.
 
+      ELSE IF (ACTPAR(1) == 'TDIFFCOR') THEN
+C                              =======
+            fTNDCOR = 1.
+            IF (NPAR > 1) THEN
+              READ (ACTPAR(2), '(F10.0)', IOSTAT=IERR) tempREAL
+              IF (IERR == 0) THEN
+                  fTNDCOR = tempREAL
+              ENDIF
+            ENDIF
+            
+      ELSE IF (ACTPAR(1) == 'TDIFFUS' .AND. ACTPAR(2) == 'ALWAYS') THEN
+C                            =======
+C***        Perform TDIFFUS corrections even if no other temperature
+C***        corrections are applied
+            bForceTDIFFUS = .TRUE.
+
       ELSE IF (ACTPAR(1) == 'NOTDIFFUS') THEN
 C                              =======
             bTDIFFUS = .FALSE.
@@ -840,6 +943,11 @@
          BTALTER = .TRUE.
 
       ELSE IF (ACTPAR(1) == 'TCORR' .AND. 
+     >         ACTPAR(2) == 'ADVECTION') THEN
+C                            =========
+         bINCADV = .TRUE.
+
+      ELSE IF (ACTPAR(1) == 'TCORR' .AND. 
 C                            =====
      >         ACTPAR(2) == 'FERATES' .AND.
 C                            =======
@@ -853,7 +961,31 @@
 
       ELSE IF (ACTPAR(1) .EQ. 'XJLAPP') THEN
 C                              ======
-         IF (ACTPAR(2) .EQ. 'NEW') THEN
+         IF (ACTPAR(2) == 'COLI') THEN
+C                          ====         
+            IF (iALOentry > 0) THEN
+              bLAMAPPCOLI = .TRUE.
+            ELSE
+              WRITE (hCPR,*) '* WARNING: ALO from COLI requested'
+     >            // ' but not found -- fallback to default OPC'
+            ENDIF
+            DO I=3, NPAR
+C***          Optional parameter: Specify ALOMIN = min "TAU" for using ALO
+              IF (I < NPAR .AND. ACTPAR(3) == 'MIN') THEN
+                READ (ACTPAR(4),'(F10.0)', ERR=1) ALOMIN
+              ENDIF
+C***          Optional parameter to request using the tri-diagonal ALO
+              IF (ACTPAR(I)(:3) == 'TRI') THEN
+                IF (iALOEntry < 3) THEN
+                  WRITE (hCPR,*) '* WARNING: Tri-diagonal ALO requested'
+     >            // ' but not found -- applying diagonal ALO instead'
+                ELSE
+                  bALOTri = .TRUE.
+                ENDIF
+              ENDIF
+            ENDDO
+
+         ELSE IF (ACTPAR(2) .EQ. 'NEW') THEN
 C                            ===
             BXJLAPPNEW = .TRUE.
          ELSE IF (ACTPAR(2) .EQ. 'CORE') THEN
@@ -928,9 +1060,10 @@
 
       ELSE IF (KARTE(:6) == 'VELPAR') THEN
 C                            ======
+         VMINCAND = VMIN
          CALL DECVELPAR(KARTE, VFINAL, VMINCAND, BETA, RMAX)
          IF (VMIN < 0) THEN
-            !use VMIN from CARDS only if not stored in MODEL
+C***        use VMIN from CARDS only if not stored in MODEL
             VMIN = VMINCAND
          ELSE
             VMINCAND = VMIN
@@ -950,6 +1083,8 @@
          IF (NPAR > 2) THEN
            DO i=3, NPAR
              SELECTCASE (ACTPAR(i))
+               CASE ('LOOSE')
+                 bHYSTloose = .TRUE.
                CASE ('FULL', 'FULLHD')
                  bFULLHYDROSTAT = .TRUE.
                CASE ('MEAN')
@@ -959,13 +1094,13 @@
                  IF (NPAR >= (i+1)) THEN
                    READ (ACTPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
                    IF (IERR == 0) THEN
-                     GEDDreduce = tempREAL
-                     IF (GEDDreduce > 1. .OR. GEDDreduce < 0.)  THEN
+                     IF (tempREAL > 1. .OR. tempREAL < 0.)  THEN
                        WRITE (hCPR,'(A)') ' *** Error: invalid choice'
      >                    // ' of REDUCE parameter, must be '
      >                    // ' between 0 and 1!'
                        GOTO 1
                      ENDIF                   
+                     GEDDreduce = tempREAL
                    ENDIF
                  ENDIF
                CASE ('ACC', 'EPS')
@@ -1004,6 +1139,11 @@
       ELSE IF (ACTPAR(1) == 'TAUMAX') THEN
 C                            ======
          READ (ACTPAR(2), '(F10.0)', ERR=1) TAUMAX
+         TaumaxCard = KARTE
+C***     Only parameters which are also required for other routines
+C***     than just ENSURETAUMAX are decoded here. The rest, such as 
+C***     accuracy settings or numerical paramers, is decoded
+C***     in ENSURETAUMAX itself.
          IF (NPAR > 2) THEN
           DO i=3, NPAR 
             SELECTCASE (ACTPAR(i))
@@ -1015,8 +1155,6 @@
                     TAUACC = tempREAL
                   ENDIF
                 ENDIF
-              CASE ('SAFE')
-                bTauMaxSafe = .TRUE.
               CASE ('MIN')
                 bTauStrict = .FALSE.
                 bENSURETAUMAX = .TRUE.
@@ -1035,52 +1173,20 @@
                     TAUACC = tempREAL * TAUMAX
                   ENDIF                  
                 ENDIF
-              CASE ('REDUCE')
-                ReduceTauCorrections = 0.2
-                IF (NPAR >= (i+1)) THEN
-                  READ (ACTPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
-                  IF (IERR == 0) THEN
-                     IF (tempREAL > 1. .OR. tempREAL < 0.)  THEN
-                       WRITE (hCPR,'(A)') ' *** Error: invalid choice'
-     >                    // ' of REDUCE parameter, must be '
-     >                    // ' between 0 and 1!'
-                       GOTO 1
-                     ENDIF                   
-                    ReduceTauCorrections = tempREAL
-                  ENDIF                  
-                ENDIF
-              CASE ('CORLIMIT', 'CORRLIMIT')
-                IF (NPAR >= (i+1)) THEN
-                  READ (ACTPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
-                  IF (IERR == 0) THEN
-                    TauCorLimits(1) = tempREAL
-                    IF (NPAR >= (i+2)) THEN
-                      !Note: This second parameter is not interpreted yet
-                      READ (ACTPAR(i+2),'(F10.0)',IOSTAT=IERR) tempREAL
-                      IF (IERR == 0) THEN
-                        TauCorLimits(2) = tempREAL
-                      ELSE
-                        TauCorLimits(2) = 1.0
-                      ENDIF                                    
-                    ENDIF
-                  ELSE
-                    !Use default values
-                    TauCorLimits(1) = -1.0
-                  ENDIF                                    
-                ENDIF
-              CASE ('FLUXQUOTLIMIT', 'FQLIM', 'FQL')
-                FQLIMIT = 0.05  !default if criterion is set
-                IF (NPAR >= (i+1)) THEN
-                  READ (ACTPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
-                  IF (IERR == 0) THEN
-                    FQLIMIT = tempREAL
-                  ENDIF           
-                ENDIF            
+              CASE ('THOM', 'THOMSON')
+                bTMTHOM = .TRUE.               
             ENDSELECT
           ENDDO
 
          ENDIF
 
+      ELSE IF (ACTPAR(1) .EQ. 'TAUFIX') THEN
+C                              ======
+C     note: Deprecated CARD => use TAUMAX card
+        WRITE (hCPR,*) '*** ERROR: DEPRECARED TAUFIX CARD FOUND ***'
+        WRITE (hCPR,*) '--- Use TAUMAX card options instead! ---'
+        STOP 'FATAL ERROR in DESCTE'
+        
       ELSE IF (ACTPAR(1) .EQ. 'DENSCON') THEN
 C                              =======         
          READ (ACTPAR(2), '(F10.0)',ERR=1) DENSCON_FIX
@@ -1098,11 +1204,13 @@
       ELSE IF (ACTPAR(1) == 'HYDRO') THEN
 C                            =====
         bHYDROSOLVE = .TRUE.
-        HydroCard = KARTE
+        HydroCard = TRIM(HydroCard) // KARTE(6:)
         DO I=2, NPAR
           SELECTCASE (ACTPAR(I))
             CASE ('LATETAU', 'LTAU', 'LT')
               bLateTau = .TRUE.
+            CASE ('ANALYSE')
+              bHydroHelp = .TRUE.
           ENDSELECT
         ENDDO
     
@@ -1126,7 +1234,7 @@
 C                            =======
         MFORM = 2
       ELSE IF (ACTPAR(1) == 'MSTAR') THEN
-        !Fallback if MSTAR was not in model file
+C***    Fallback if MSTAR was not in model file
         IF ((XMSTAR < -90.) .AND. (GLOG < -90.)) THEN
           READ (ACTPAR(2), '(F10.0)') XMSTAR
           IF (XMSTAR <= 0.) THEN
@@ -1136,6 +1244,16 @@
             GLOG = ALOG10(GCONST * XMSTAR * XMSUN / RSTAR / RSTAR)
           ENDIF
         ENDIF
+      ELSE IF (ACTPAR(1) == 'VTURB' .OR. ACTPAR(1) == 'VMIC') THEN
+C                            =====                     ====      
+        VTURB_LINE = KARTE
+        
+c      ELSE IF (ACTPAR(1) == 'VTURBUPDATE') THEN
+c        bUpdateVT = .TRUE.
+c        READ (ACTPAR(2), '(F10.0)', ERR=1) VTURBND
+c        DO L=1, ND
+c          VTURB(L) = VTURBND
+c        ENDDO
       ELSE IF (ACTPAR(1) == 'MASSUPDATE') THEN
 C                            ==========
 C       !Changes the mass on the fly (either direct input or m-r relation)
@@ -1143,21 +1261,70 @@
         bUpdateMass = .TRUE.
         IF (NPAR > 1) THEN
           READ (ACTPAR(2), '(F10.0)', ERR=1) XMSTAR          
+          GLOG = ALOG10(GCONST * XMSTAR * XMSUN / RSTAR / RSTAR)
         ELSE
           XMSTAR = 0.
         ENDIF
+      ELSE IF (ACTPAR(1) == 'RSTARUPDATE') THEN
+C                            ===========
+C***    Manual change of RSTAR on the fly 
+C***    This is only a debug option that should be used with care
+C***    Input is expected in solar radii
+        IF (NPAR > 1) THEN
+          READ (ACTPAR(2), '(F10.0)', ERR=1) RSTAR
+          RSTAR = RSTAR * RSUN
+          GLOG = ALOG10(GCONST * XMSTAR * XMSUN / RSTAR / RSTAR)
+C***      Scale total density with new radius
+          DO L=1, ND
+            ENTOT(L) = ENTOT(L) * (RSTARorg/RSTAR)**2
+            RHO(L) = RHO(L) * (RSTARorg/RSTAR)**2
+          ENDDO           
+          bUpdateMass = .TRUE.
+        ELSE
+          WRITE (0,*) '*** ERROR: RSTARUPDATE NEEDS A PARAMETER'
+          STOP '*** FATAL ERROR IN STEAL->DECSTE'
+        ENDIF        
+
       ELSE IF (KARTE(:8) == 'HEADLINE') THEN
 C                            ========
         HEADLINE = KARTE(10:)        
       ELSE IF (KARTE(:14) == 'RENEW HEADLINE') THEN
 C                             ==============
         bModHeadUpdate = .TRUE.
+      ELSE IF (ACTPAR(1) == 'DEBUGTB') THEN
+C                            =======
+        bKUBATDEBUG = .TRUE.
       ELSE IF (ACTPAR(1) == 'BACKUP') THEN
 C                            ======
         NBACKUP = 50
         IF (NPAR > 1) THEN
           READ (ACTPAR(2), '(I10)', ERR=1) NBACKUP
         ENDIF
+      ELSE IF (KARTE(:4) == 'VDOP') THEN
+C                            ====
+         IF (NPAR > 2) THEN
+           IF (ACTPAR(3) == 'AUTO') bDDVDOP = .TRUE.
+         ENDIF
+      ELSE
+C***  Check if the card refers to an element name
+        CALL FINDCHARGE (ACTPAR(1), NZ)
+C***    NZ > 0 means that an element of this name is known
+        IF (NZ > 0) THEN
+c          IFOUNDELEMENT = 0
+          DO K=1, NATOM
+            IF (ACTPAR(1) == ELEMENT(K)) THEN      
+C***          ELEMENT IS NOT ONLY IN CARDS, BUT ALSO IN DATOM            
+c              IFOUNDELEMENT = 1
+C***          Look for keyword 'TRACE' -> this element will not be 
+C***           considered for max/min correction calculation
+              DO I=3, NPAR
+                IF (ACTPAR(I) == 'TRACE') THEN
+                  TRACEELEM(K) = .TRUE.
+                ENDIF
+              ENDDO
+            ENDIF
+          ENDDO
+        ENDIF
       ENDIF
       GOTO 8
 
diff -bur ./deriv.f ../../powr-refactor/src/deriv.f
--- ./deriv.f	2024-07-28 13:13:17.000000000 +0200
+++ ../../powr-refactor/src/deriv.f	2023-09-27 10:14:15.101755421 +0200
@@ -1,12 +1,14 @@
       SUBROUTINE DERIV (DM,NRANK,I,NPLUS1,EN,CRATE,RRATE,EXPFAC,NFEDGE,
      $      WCHARM,ND,L,ENLTE,PHI,PWEIGHT,NFL,DELTAX,XMAX,
-     $      XRED,XBLUE,DETAL,DOPAL,SLNEW,OPAL,XJLAPP,XJCAPP,
-     $      FWEIGHT,DOPA,DETA,OPAC,SCNEW,XLAMBDA,NF,SCNEIND,OPACIND,
-     $      NDIM,N,EINST,SIGMAKI,RUDLINE,
-     $      LASTIND,INDLOW,INDNUP,KONTLOW,KONTNUP,LASTKON,
-     $      IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,VDOP,ATEST,BTEST,
+     $      XRED,XBLUE,DETAL,DOPAL,SLNEW,OPAL,XJLAPP,XJCAPP,FWEIGHT,
+     $      DOPA,DETA,OPAC,SCNEW,XLAMBDA,NF,SCNEIND,OPACIND,NDIM,N,
+     $      EINST,SIGMAKI,RUDLINE, bLAMAPPCOLI, XLAMAPPMEAN, bUSEALO,
+     $      LASTIND,LASTINDAUTO,INDLOW,INDNUP,KONTLOW,KONTNUP,LASTKON,
+     $      IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,VDOPUNIT,
+     >      ATEST,BTEST,
      $      RDIEL,IONGRND,KODRLOW,LASTKDR,WFELOW,WFENUP,BDIAG, WEIGHT,
-     >      ELEVEL, NRB_CONT, TL, ENE, NOM, bBLOCKINVERSION)
+     >      ELEVEL, NRB_CONT, TL, ENE, NOM, NCHARG, DEXFAC,
+     >      iBLOCKINVERSION)
 C*******************************************************************************
 C***  DERIVATIVE OF RATE EQ. COEFFICIENTS : 
 C***  D(I,M,J):= N(M) * D(RATCO(M,J))/DN(I) - N(J) * D(RATCO(J,M))/DN(I)
@@ -21,14 +23,20 @@
       DIMENSION XJLAPP(2),SCNEIND(2),OPACIND(2)
       DIMENSION SIGMAKI(NF,LASTKON)
       DIMENSION DM(NRANK,NRANK)
-      DIMENSION INDLOW(LASTIND),INDNUP(LASTIND), NBLENDS(LASTIND)
-      DIMENSION KONTLOW(LASTKON),KONTNUP(LASTKON),NFEDGE(LASTKON)
-      DIMENSION KODRLOW(LASTKDR)
-      DIMENSION WFELOW(ND,LASTIND),WFENUP(ND,LASTIND)
-      INTEGER, DIMENSION(N) :: NOM
-      LOGICAL NRB_CONT(LASTKON)
-      LOGICAL RUDLINE(LASTIND), BDIAG(LASTIND)
-      LOGICAL :: bBLOCKINVERSION
+      INTEGER, DIMENSION(LASTIND) :: INDLOW, INDNUP, NBLENDS
+      INTEGER, DIMENSION(MAXLAP, LASTIND) :: IBLENDS
+      INTEGER, DIMENSION(LASTKON) :: KONTLOW, KONTNUP, NFEDGE
+      INTEGER, DIMENSION(LASTKDR) :: KODRLOW
+      REAL, DIMENSION(ND, LASTIND) :: WFELOW, WFENUP
+      REAL, DIMENSION(ND, LASTINDAUTO) :: XLAMAPPMEAN
+      REAL, DIMENSION(LASTIND) :: XLAMZERO, DEXFAC
+      INTEGER, DIMENSION(N) :: NOM, NCHARG
+      LOGICAL NRB_CONT(LASTKON), bLAMAPPCOLI
+      LOGICAL, DIMENSION(LASTIND) :: RUDLINE, BDIAG
+      LOGICAL, DIMENSION(LASTINDAUTO) :: bUSEALO
+      INTEGER :: iBLOCKINVERSION
+
+      REAL :: SUMSL, SUMOPAL, SUMDETA, SUMDOPA
 
 C***  CI : FACTOR IN SAHA EQUATION (MIHALAS, P. 113)
       DATA CI / 2.07E-16 /
@@ -38,6 +46,9 @@
       DATA C2 / 3.9724E-16 /
 C***  C4 = 4 * PI / (H * C) * 1.E-8
       DATA C4 / 6.326840507E8 /
+C***  Speed of light in km/s      
+      REAL, PARAMETER :: CLIGHTKMS = 2.99792458E5
+      
 
 C***  DEFINE KMAX = HIGHEST FREQUENCY INDEX WITH NON-ZERO WCHARM(L,K)
       DO 4 K=NF,1,-1
@@ -57,7 +68,7 @@
 C***  BOUND-FREE TRANSITIONS *******************************************
       DO 8 KONT=1,LASTKON
       NUP=KONTNUP(KONT)
-      IF (bBLOCKINVERSION .AND. (NOM(I) /= NOM(NUP))) GOTO 8
+      IF (iBLOCKINVERSION > 0 .AND. (NOM(I) /= NOM(NUP))) GOTO 8
       ENNUP=EN(NUP)
       ENLTEUP=ENLTE(NUP)
 
@@ -104,6 +115,10 @@
 C!!!      QUL= ENLTEUP * ENLOW / (ENLTELO*ENNUP)
       NFMAX = MIN0 (NFEDGLO, KMAX)
       DO 2 K=1,NFMAX
+c***  TEST: I think here is a minus bug (ansander Mar 2017)      
+c      DJCDNI = WCHARM(L,K) * (DETA(K)-DOPA(K)*SCNEW(K)) / OPAC(K)
+c      SUM = SUM - 
+c     - SIGMAKI(K,KONT)* XLAMBDA(K)* (QUL-EXPFAC(K)) * DJCDNI *FWEIGHT(K)
       DJCDNI = WCHARM(L,K) * (DOPA(K)*SCNEW(K)-DETA(K)) / OPAC(K)
       SUM = SUM + 
      + SIGMAKI(K,KONT)* XLAMBDA(K)* (QUL-EXPFAC(K)) * DJCDNI *FWEIGHT(K)
@@ -197,7 +212,11 @@
       IF (RUDLINE(IND)) GOTO 7
  
 C***  ZERO CORE: ZERO DERIVATIVE TERM
+      IF (bLAMAPPCOLI) THEN
+        IF (.NOT. bUSEALO(IND) .AND. .NOT. BDIAG(IND)) GOTO 7     
+      ELSE
       IF (XRED(IND) .GE. XBLUE(IND) .AND. .NOT. BDIAG(IND)) GOTO 7
+      ENDIF
 
 C***  test !!! muss mit RADNET uebereinstimmen!
       if (slnew(ind) .lt. 1.e-100) goto 7
@@ -215,17 +234,15 @@
             IF(I .EQ. NUP) DJLDNI = WFENUP(L, IND)
             WAVENUM=ELEVEL(NUP)-ELEVEL(LOW)
             W3=WAVENUM*WAVENUM*WAVENUM
-            DLOWUP = (ENNUP - EN(LOW) * WEIGHT(NUP)/WEIGHT(LOW) ) * 
+            DLOWUP = (ENNUP * DEXFAC(IND)
+     >               - EN(LOW) * WEIGHT(NUP)/WEIGHT(LOW) ) * 
      >               EINST(NUP,LOW) * DJLDNI / (C2*W3) 
          ELSE
             DLOWUP = .0
          ENDIF
+         
+C***  NON-IRON LINES: --------------------------------------------------         
       ELSE
-C***     Note that DJLDNI returned by JLDERIV has the meaning of -DJLDNI !
-         CALL JLDERIV (DJLDNI,IND,DELTAX,XMAX,XRED,XBLUE,
-     $   DETAL,DOPAL,SLNEW,OPAL,NFL,PHI,PWEIGHT,OPACIND,SCNEIND,
-     $   IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,
-     $   VDOP,I,INDNUP,INDLOW,ATEST,BTEST)
 
 C***     TERM FOR NET RADIATIVE BRACKETS
          ETAL=SLNEWI*OPALI
@@ -233,7 +250,44 @@
      $          / (ETAL*ETAL) * XJLAPP(IND)
 
 C***     TERM FOR SCHARMER NON-LINEARITY
+        IF (bLAMAPPCOLI) THEN
+          DJLDNI = 0.
+          SUMDETA = 0.
+          SUMSL   = 0.
+          SUMOPAL = 0.
+          SUMDOPA = 0.
+          
+          IF (bUSEALO(IND)) THEN
+            DO LB=1, NBLENDS(IND)
+C***        Consider contributions  from all blending lines          
+              INDLB = IBLENDS(LB,IND)
+              IF (OPAL(INDLB) > 0.) THEN
+C***          Add this term only if ALO has been used in SETXJL
+C***          (i.e. not done for LASER situation)
+                SUMDETA = SUMDETA + DETAL(INDLB)
+                SUMDOPA = SUMDOPA + DOPAL(INDLB)
+                SUMOPAL = SUMOPAL + OPAL(INDLB)
+                SUMSL   = SUMSL   + SLNEW(INDLB) * OPAL(INDLB)
+              ENDIF    
+            ENDDO  
+            IF (SUMOPAL > 0. .AND. SUMDETA > 0.) THEN
+              SUMSL  = SUMSL / SUMOPAL
+              DSLDNI = SUMDETA / SUMOPAL - SUMDOPA * SUMSL / SUMOPAL
+              DJLDNI = XLAMAPPMEAN(L, IND) * DSLDNI
+              DLOWUP = DLOWUP - DJLDNI/SLNEWI        
+            ENDIF
+          ENDIF
+        
+        ELSE      
+C***      Note that DJLDNI returned by JLDERIV has the meaning of -DJLDNI !
+          CALL JLDERIV (DJLDNI,IND,DELTAX,XMAX,XRED,XBLUE,
+     $    DETAL,DOPAL,SLNEW,OPAL,NFL,PHI,PWEIGHT,OPACIND,SCNEIND,
+     $    IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,NBLENDS,
+     $    VDOPUNIT,I,INDNUP,INDLOW,ATEST,BTEST)
+
          DLOWUP=DLOWUP+DJLDNI/SLNEWI
+         ENDIF  
+           
 C***     COMMON PRE-FACTORS
          DLOWUP= ENNUP * EINST(NUP,LOW) * DLOWUP
       ENDIF
diff -bur ./difdtdr.f ../../powr-refactor/src/difdtdr.f
--- ./difdtdr.f	2024-07-28 13:13:17.000000000 +0200
+++ ../../powr-refactor/src/difdtdr.f	2023-11-21 10:10:55.285269778 +0100
@@ -1,6 +1,6 @@
       SUBROUTINE DIFDTDR (DTDR,TEFF,XJC,HEDDI,TRND,RND,ND,EN,POPNUM,
-     $                   RNEND,ENTOTND,RSTAR,NDIM,N,LEVEL,NCHARG,WEIGHT,
-     $                   ELEVEL,EION,EINST,ALPHA,SEXPO,
+     >                   POPMIN,RNEND,ENTOTND,RSTAR,NDIM,N,LEVEL,
+     >                   NCHARG,WEIGHT,ELEVEL,EION,EINST,ALPHA,SEXPO,
      $                   ADDCON1, ADDCON2, ADDCON3, 
      $                   IGAUNT,NOM,NF,
      $                   XLAMBDA,FWEIGHT,
@@ -11,8 +11,8 @@
 C***  CALCULATES "DTDR", THE TEMPERATURE GRADIENT (-DT/DR !!) 
 C***    AT THE INNER BOUNDARY 
 C***  - ONLY CALLED, IF TEMPERAURE CORRECTIONS ARE TO BE APPLIED
-C***  - CALLED FROM: WRCONT, COMO, ETL
-C***  - "DTDR" IS USED BY: DIFFUS, MOMO
+C***  - CALLED FROM: WRCONT, COMO, COLI
+C***  - "DTDR" IS USED BY: DIFFUS, MOMO, CLDIFFUS
 C***  FORMULATION: KUDRITZKI 1973, THESIS TU BERLIN
 C***  CONCEPT: 
 C***  INCIDENT RADIATION I+ = B-NUE + MUE * D(BNUE)/DTAU-ROSS.
@@ -23,18 +23,16 @@
  
       DIMENSION FWEIGHT(NF),XLAMBDA(NF),XJC(ND,NF),HEDDI(NF)
       DIMENSION EN(N),POPNUM(ND,N)
-      LOGICAL BKUDRITZKI
+      REAL, INTENT(IN) :: POPMIN
+      LOGICAL :: BKUDRITZKI
  
 C***  tiefenabh. clumping nach goetz
       DIMENSION DENSCON(ND),FILLFAC(ND)
 
-C***  DATA: STEBOL = STEFAN-BOLTZMANN CONSTANT (CGS-UNITS) / PI
-      DATA STEBOL / 1.8046E-5 /
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5   !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS) / PI
  
 C***  CORRECT TOTAL FLUX AS DETERMINED BY THE GIVEN EFFECTIVE TEMPERATURE
-      HTOT=0.25*STEBOL*TEFF*TEFF*TEFF*TEFF
-
-C      WRITE (0,*) 'OPAROSS-COLI:', OPARND
+      HTOT=0.25*STEBOLDPI*TEFF*TEFF*TEFF*TEFF
  
       IF (OPARND .LE. 0.) THEN
 C***  CALCULATION OF THE ROSSELAND MEAN OPACITY AT R=R*
@@ -42,16 +40,15 @@
    20   EN(I)=POPNUM(ND,I)
 C***  Clump density
         ENTOTNDDENS = ENTOTND * DENSCON(ND)
-        CALL OPAROSS (OPARND,EN,TRND,RNEND,ENTOTNDDENS,RSTAR,NDIM,N,
-     $              LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
-     $              ALPHA,SEXPO,
+        CALL OPAROSS (OPARND,EN,TRND,RNEND,ENTOTNDDENS,
+     >                RSTAR,NDIM,N,LEVEL,NCHARG,WEIGHT,
+     >                ELEVEL,EION,EINST,ALPHA,SEXPO,
      $              ADDCON1, ADDCON2, ADDCON3, 
      $              IGAUNT,NF,XLAMBDA,FWEIGHT,NOM,
-     $              MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,RND,
-     $              KONTNUP,KONTLOW,LASTKON)
+     $              MAXATOM,SIGMATHK,SEXPOK,EDGEK,
+     $              KODAT,RND,KONTNUP,KONTLOW,LASTKON,POPMIN)
 C***  Scale opacity down with filling factor
         OPARND = OPARND * FILLFAC(ND)
-C        WRITE (0,*) 'OPAROSS-COMO:', OPARND
       ENDIF
 
 C***  INTEGRAL "HINT" ACCOUNTS FOR THE POSSIBLE DEVIATION
@@ -64,7 +61,7 @@
         ENDDO
       ENDIF
 
-      DTDR=0.75*OPARND*(HTOT-HINT)/STEBOL/TRND/TRND/TRND
+      DTDR=0.75*OPARND*(HTOT-HINT)/STEBOLDPI/TRND/TRND/TRND
  
       RETURN
       END
Only in .: diff-wrh-source
diff -bur ./dliop.f ../../powr-refactor/src/dliop.f
--- ./dliop.f	2024-07-28 13:13:18.000000000 +0200
+++ ../../powr-refactor/src/dliop.f	2023-09-27 10:14:15.105755485 +0200
@@ -1,5 +1,6 @@
-      SUBROUTINE DLIOP (I,ENTOTL,DOPAL,DETAL,XRED,XBLUE,VDOP,RSTAR,N,
-     $       NDIM,EINST,WEIGHT,ELEVEL,LASTIND,INDLOW,INDNUP, EN)
+      SUBROUTINE DLIOP (I,ENTOTL,DOPAL,DETAL,XRED,XBLUE,VDOPUNIT,RSTAR,
+     >       N,NDIM,EINST,WEIGHT,ELEVEL,LASTIND,INDLOW,INDNUP, EN, 
+     >       LASTINDAUTO, bLAMAPPCOLI, bUSEALO, iBLOCKINVERSION)
 C*******************************************************************************
 C***  DERIVATIVES OF LINE OPACITIES AND EMISSIVITIES WITH RESPECT TO EN(I)
 C***  AT CURRENT DEPTH POINT
@@ -12,6 +13,9 @@
       DIMENSION EINST(NDIM,NDIM),WEIGHT(NDIM),ELEVEL(NDIM)
       DIMENSION INDLOW(LASTIND),INDNUP(LASTIND)
       DIMENSION DETAL(2),DOPAL(2),XRED(2),XBLUE(2), EN(2)
+      LOGICAL, DIMENSION(LASTINDAUTO) :: bUSEALO
+      LOGICAL :: bLAMAPPCOLI
+      INTEGER :: iBLOCKINVERSION
 
 C***  C2 = 2 * H * C     ( CGS UNITS )
       DATA C2 / 3.9724E-16 /
@@ -36,10 +40,14 @@
       NUP=INDNUP(IND)
 
 C***  NO DERIVATIVES CALCULATED, IF NOT NECESSARY:
-      IF ( (XRED(IND) .GE. XBLUE(IND)) .OR.
-     $      EINST(LOW,NUP) .EQ. -2. ) THEN
-         DETAL(IND)=5HUNDEF
-         DOPAL(IND)=5HUNDEF
+      IF (((.NOT. bLAMAPPCOLI) .AND. 
+     >     ((XRED(IND) .GE. XBLUE(IND)) .OR.
+     >      EINST(LOW,NUP) .EQ. -2. ))
+     >   .OR. (bLAMAPPCOLI .AND. 
+ccc   No derivates needed in case of rudimental lines (or sometimes in XJLCF method)
+     >   (.NOT. bUSEALO(IND) .OR. EINST(LOW,NUP) .EQ. -2. ) ) ) THEN
+         DETAL(IND)=TRANSFER('UNDEF', DETAL(IND))
+         DOPAL(IND)=TRANSFER('UNDEF', DOPAL(IND))
          GOTO 1
          ENDIF
 
@@ -52,7 +60,7 @@
 
       XLAMCM=1./(ELEVEL(NUP)-ELEVEL(LOW))
 C***  DND= DELTA-NUE-DOPPLER (HERTZ)
-      DND=VDOP*1.E5/XLAMCM
+      DND=VDOPUNIT*1.E5/XLAMCM
       EMINDU=EINST(NUP,LOW)*XLAMCM*XLAMCM/PI8*RSTAR
 
       IF (I .EQ. LOW) THEN
diff -bur ./drtrans.f ../../powr-refactor/src/drtrans.f
--- ./drtrans.f	2024-07-28 13:13:19.000000000 +0200
+++ ../../powr-refactor/src/drtrans.f	2023-09-27 10:14:15.105755485 +0200
@@ -2,7 +2,7 @@
      >                    DELXLAP,NBLINE,MAXLAP,INDLOW,INDNUP,LASTIND,
      >                    MAXIND,LEVEL,WEIGHT,ELEVEL,N,EINST,NDIM,
      >                    POPNUM,T,ND,ALN,VDOP,EION,ENTOT,RNE,
-     >                    MAXNSUBLEVEL, NSUBLOW, BROAD, LINPRO, AVOIGT, 
+     >                    MAXSUBL,NSUBLOW,BROAD,LINPRO,AVOIGT, 
      >                    DENSCON,NMOD, MAXMOD, NDDIM, 
      >                    MAINQN, NCHARG, NOM, IND_ORIGLEV)
 C***********************************************************************
@@ -26,7 +26,7 @@
       DIMENSION INDLOW(LASTIND),INDNUP(LASTIND)
       DIMENSION POPNUM(NDDIM,NDIM,NMOD)
       REAL, DIMENSION (NDDIM,NMOD) :: T, ENTOT, RNE, DENSCON
-      DIMENSION NSUBLOW(MAXNSUBLEVEL)
+      DIMENSION NSUBLOW(MAXSUBL)
       CHARACTER KARTE*80
       CHARACTER*10 LEVEL(N), LEV, LEVUP,LEVLOW
       CHARACTER*8 LINPRO(MAXLAP), LINPROBL
@@ -42,7 +42,7 @@
 C***  NLOW: NUMBER OF /LOWERLEVELS from splitting LEVELS
       NLOW=0
 C***  NSUBLOW: POINTER TO ADDITIONAL LEVELS IN THE ORIGINAL ARRAYS
-      DO 10 I=1, MAXNSUBLEVEL
+      DO 10 I=1,MAXSUBL
    10 NSUBLOW(I)=0
 
 C***  1. READ INPUT FOR DRTRANSIT HANDLING OF SPECIFIED LINE  ----------
@@ -141,10 +141,11 @@
             STOP 'NDIM1'
          ENDIF
          NLOW=NLOW+1
-         IF (NLOW .GT. MAXNSUBLEVEL) THEN
-            WRITE (0,*)  '*** More sublevels than dimensioned!'
-            WRITE (0,*)  '*** FATAL ERROR in subr. DRTRANS'
-            STOP '*** ERROR: NLOW'
+         IF (NLOW .GT. MAXSUBL) THEN
+            PRINT *,
+     >           ' >>>>> SUBR. DRTRANS: ERROR STOP (NLOW .GT. MAXSUBL)'
+            CALL REMARK ('DRTRANS: NLOW GREATER THAN MAXSUBL')
+            STOP 'NLOW'
          ENDIF
          NSUBLOW(NLOW)=N
          READ (KARTE,3) LEVEL(N),NW,ELEVEL(N)
diff -bur ./elimin.f ../../powr-refactor/src/elimin.f
--- ./elimin.f	2024-07-28 13:13:20.000000000 +0200
+++ ../../powr-refactor/src/elimin.f	2023-09-27 10:14:15.105755485 +0200
@@ -1,7 +1,7 @@
       SUBROUTINE ELIMIN (XLAM,EMFLUX,FLUXIN,U,Z,
      $          A,B,C,W,BX,WX,XJC,RADIUS,P,BCORE,DBDR,
      $          OPA,ETA,THOMSON,EDDI,ND,NP,NPDIM,ENTOT,K,
-     $          IWARN, ST, BELIFI, IVERS)
+     $          IWARN, IWARN2, ST, BELIFI, IVERS)
 C***  FEAUTRIER SCHEME FOR CONTINUOUS RADIATION TRANSFER IN SPHERICAL SYMMETRY
 C***  TAPE7 = MASS STORAGE FILE FOR FEAUTRIER MATRICES
 C***  LAST PARAMETER -1 IN WRITMS IS VERY IMPORTANT ]
@@ -12,6 +12,10 @@
       DIMENSION EDDI(3,ND)
       DIMENSION P(NPDIM),BX(NPDIM,NPDIM),WX(NPDIM),B(2)
       DIMENSION U(ND,NP),Z(ND,NP)
+      
+C***  To avoid underflows define minimum allowed positive real/intensity/flux
+      REAL, PARAMETER :: RTINY = 1.E-300
+
 C***  To Store Feautrier Matrices ST(94*95,89)
       DIMENSION ST((NPDIM+1)*NPDIM,ND)
       LOGICAL BELIFI
@@ -87,8 +91,13 @@
         IWARN = IWARN + 1
         EDDI(1,ND) = 0.01
       ENDIF
+      IF (EDDI(1,ND) .GT. 1.) THEN
+        IWARN2 = IWARN2 + 1
+        EDDI(1,ND) = 1.0
+      ENDIF
       FL=3.-1./EDDI(1,ND)
       DO 5 J=1,JMAX
+        IF (ABS(WX(J)) < RTINY) WX(J) = RTINY
     5 U(ND,J)=WX(J)
       CALL EQUAL (A,WX,JMAX)
       NC2=NP-ND+2
@@ -114,8 +123,16 @@
       CALL VADD (WX,W,JMAX)
 C***  WX(J) IS THE FEAUTRIER-INTENSITY U AT RADIUS R(L)
       DO 3 J=1,JMAX
+        IF (ABS(WX(J)) < RTINY) WX(J) = RTINY
     3 U(L,J)=WX(J)
       CALL MOMENT0 (ND,RADIUS,L,JMAX,Z,WX,XJC(L),.FALSE.)
+c      WRITE (0,*) ' L=', L
+c      WRITE (0,*) ' RL=', RL
+c      WRITE (0,*) ' JMAX=', JMAX
+c      WRITE (0,*) ' P=', P
+c      WRITE (0,*) ' WX=', WX
+c      WRITE (0,*) ' XK=', XK
+      IF (ABS(XK) < RTINY) XK = RTINY
       CALL MOMENT2 (RL,JMAX,P,WX,XK)
       IF (XJC(L) .GT. .0) THEN
          EDDI(1,L)=XK/XJC(L)
@@ -128,7 +145,10 @@
         IWARN = IWARN + 1
         EDDI(1,L) = 0.01
       ENDIF
-
+      IF (EDDI(1,L) .GT. 1.) THEN
+        IWARN2 = IWARN2 + 1
+        EDDI(1,L) = 1.
+      ENDIF
 C***  THIS IS AN INGENIOUS (;) RECURSION FORMULA FOR THE SPHERICITY FACTOR ]
       RLP=RADIUS(L+1)
       FLP=FL
diff -bur ./ensuretaumax.f ../../powr-refactor/src/ensuretaumax.f
--- ./ensuretaumax.f	2024-07-28 13:13:20.000000000 +0200
+++ ../../powr-refactor/src/ensuretaumax.f	2024-07-22 09:27:16.100033925 +0200
@@ -20,7 +20,7 @@
      >    TOLD2,        !old temperature two iterations ago (for interpolation)
      >    TOLD3,        !old temperature three iterations ago (for interpolation)
      >    CKONVER,      !char vector indicating if depth point is converged
-     >    bTauMaxSafe,  !if true taumax is only adjusted if all depth points are conv.
+     >                        TaumaxCard,  !TAUMAX CARDS-line
      >    LASTTAU,      !Number of STEAL jobs since last TAUMAX iteration
      >    GLOG,         !log g
      >    GEFFLOG,      !log geff (only > 0 if geff or Eddington Gamma predefined in the CARDS file)
@@ -37,6 +37,7 @@
      >    P,            !Impact parameter grid
      >    Z,            !z values (via z=sqrt(r^2-p^2)
      >    VTURB,        !turbulence velocity in km/s
+     >                        VMACH,        !sound speed in km/s
      >    ARAD,         !radiative acceleration (from COLI)
      >    APRESS,       !pressure acceleration (from STEAL->INITFCORR)
      >    AMECH,        !mechanical acceleration (inerta, from STEAL->INITFCORR)
@@ -58,16 +59,14 @@
      >    bUNLU,        !True if temperature corrections are allowed
      >    HTOTL,
      >    HTOTCMF0,
-     >    FQLIMIT,
+     >                        HMEAN,
      >    bFULLHYDROSTAT,
      >    bGAMMARADMEAN,
      >    TAUROSS,
      >    CORMAX,       !max corrections in this steal job
-     >    TauCorLimits, !correction limits from CARDS for tau adjustment
      >    INCRIT,       !specifies RGRID criterion for each depth point
      >    VCRIT,        !specifies velocity criterion for each depth point
      >    SCRATCH,      !Scratcharray for popnum interpolation stuff
-     >    ReduceTauCorrections,    !CARDS option for tau reducing has been set
      >    GEDDreduce,   !reduce GEDD change by mixing with old value
      >    QIONMEAN,
      >    GAMMARADMEAN,
@@ -76,21 +75,31 @@
      >    bTauUpdated,  !returns if tau iteration was done or not
      >    JOBNUM,
      >    POPMIN,
-     >    XJCorg,
+     >                        MacroDamp,    !damping of GAMMAs due to Macroclumping
+     >                        bNoARAD,      !true if ARAD from COLI has not yet been calculated
+     >                        bTMNoOS,     
+     >                        bHYSTloose,
+     >                        bTMTHOM,
      >    NCOLIP,
      >    NEWWRC,
      >    NTOLD,
      >    DEPARTNDorg,
+C                   !Backup and temporary arrays
+     >                        VELOorg, RADIUSorg, ENTOTorg, TAUSCALorg,
+     >                        Torg, T1old, T2old, T3old, RI, AMACHorg,
+     >                        RNEorg, GEFFLnew, GEFFL, GAMMARAD, 
+     >                        RNEdummy, RHELP, ARADHELP, VHELP, 
+     >                        XJCorg,
 C     
 C         !Parameters after here are only needed to call TAUSCAL
-     >    NDIM,MAXKONT,POPNUM,POP1,POP2,    !5     
+     >                        NDIM,MAXKONT,POPNUM,POP1,POP2,           ! 5     
      >    POP3,N,EN,LEVEL,NCHARG,WEIGHT,    !11
      >    ELEVEL,EION,EINST,ALPHA,SEXPO,    !16
      >    ADDCON1, ADDCON2, ADDCON3,        !19
      >    IGAUNT,NOM,NF,                    !22
      >    XLAMBDA,FWEIGHT, TAUTHOM,         !25
-     >    MAXATOM,SIGMATHK,SEXPOK,EDGEK,    !29
-     >    KODAT,KONTNUP,KONTLOW,LASTKON     !33
+     >                        MAXATOM,MAXION,SIGMATHK,SEXPOK,EDGEK,    !30
+     >                        KODAT,KONTNUP,KONTLOW,LASTKON            !34
      >    )
 C***********************************************************************
 C***  THIS SUBROUTINE adjusts the velocity field such that the innermost
@@ -119,31 +128,27 @@
       INCLUDE 'interfacebib.inc'
 
       INTEGER, INTENT(IN) :: ND, NDDIM, NP, NPDIM, NATOM, JOBNUM,
-     >                       N, NDIM, NF, MAXKONT, MAXATOM, LASTKON,
-     >                       NCOLIP, NEWWRC, NTOLD
-      REAL, INTENT(IN) :: TAUMAX, TAUACC, TEFF, RSTAR, VTURB, 
-     >                    CORMAX, ReduceTauCorrections, GEDDreduce,
+     >                       N, NDIM, NF, MAXKONT, MAXATOM, MAXION, 
+     >                       LASTKON, NCOLIP, NEWWRC, NTOLD
+      REAL, INTENT(IN) :: TAUMAX, TAUACC, TEFF, RSTAR, 
+     >                    CORMAX, GEDDreduce,
      >                    XMDOT, POPMIN
-      REAL, DIMENSION(2), INTENT(IN) :: TauCorLimits
+      REAL, DIMENSION(2) :: TauCorLimits                     !correction limits from CARDS for tau adjustment
       REAL, INTENT(INOUT) :: GEDD, GLOG, GEFFLOG, RMAX, RCONorg, 
      >                       VMIN, XMSTAR, GEDDRAD, HYSTACC
       REAL, DIMENSION(ND), INTENT(IN) :: TAUROSS             !full tau from COLI (not changed here)
       REAL, DIMENSION(ND), INTENT(INOUT) :: RADIUS, VELO, GRADI, ENTOT,
      >                                      T, TAUTHOM, TAUROSScont,
      >                                      RHO, XMU, RNE, GRSTATIC,
-     >                                      TOLD, TOLD2, TOLD3
-      REAL, DIMENSION(ND-1), INTENT(IN) :: ARAD, APRESS, AMECH, AGRAV, 
-     >                                     HTOTL, HTOTCMF0
-      REAL, DIMENSION(ND, NF), INTENT(INOUT) :: XJC
+     >                                      TOLD, TOLD2, TOLD3, VMACH, 
+     >                                      VTURB
+      REAL, DIMENSION(ND, NF), INTENT(INOUT) :: XJC, XJCorg
       INTEGER, INTENT(INOUT) :: LASTTAU, IHSSTATUS
       CHARACTER(1), DIMENSION(ND) :: CKONVER
-
-C***  Info on depth point criteria from GEOMESH>RGRID and 
-C***   the velocity calculation criterion
-      CHARACTER(8), DIMENSION(ND), INTENT(INOUT) :: INCRIT, VCRIT     
-
+      CHARACTER(8), DIMENSION(ND), INTENT(INOUT) :: INCRIT, VCRIT     !gives back depth point criterion from GEOMESH>RGRID and the velocity calculation criterion
       LOGICAL, INTENT(IN) :: bENSURETAUXMAX, bThinWind, bTauStrict, 
-     >                       bGEddFix, bUNLU, bTauMaxSafe
+     >                       bGEddFix, bUNLU, bTMTHOM, 
+     >                       bNoARAD
       LOGICAL, INTENT(OUT) :: bTauUpdated
 
       INTEGER :: NDVALUE, NC
@@ -168,8 +173,6 @@
       REAL, DIMENSION(NF), INTENT(IN) :: FWEIGHT, XLAMBDA
       CHARACTER(10), DIMENSION(N), INTENT(IN) :: LEVEL
 
-      REAL, DIMENSION(ND, NF), INTENT(INOUT) :: XJCorg
-
       !Internal variables
       INTEGER :: I, J, K, L, ITTAU, Nct, LastDAMP, IT_failsafe, LL,
      >           NA, IPAR, NPAR, LCON, LfM, LTMCM, NHYSTBAD, NTAUIV,
@@ -180,67 +183,75 @@
 C***  The full Eddington factor may not be higher than GAMMARADmax 
 C***    to have some safety distance to the Eddington limit, 
 C***    which helps keeping the density stratification stable. 
-C***      A maximum value of 0.9 is also used in TLUSTY 
-      REAL, PARAMETER :: GAMMARADmax = 0.9
+C***      A maximum value of 0.9 is used in TLUSTY 
+C***     Update 13.02.2022, ansander: Increased GAMMARADmax from 0.9 to 0.99
+C***     -- maybe make this a switch in the future
+      REAL, PARAMETER :: GAMMARADmax = 0.99
+      REAL, PARAMETER :: FLUXNEGMAXFRAC = 1.E-4 !maximum fraction of negative flux for a depth point
       REAL, DIMENSION(MAXITTAU) :: VMINHIST   !history of vmin steps
       REAL, DIMENSION(MAXITTAU) :: TAUMAXHIST !history of TAUROSScont(ND)
 
 C***  Attention! The following block of vectors is loccaly dimensioned
 C***             ("HEAP variables" since dimension ND is formal parameter!)
       REAL, DIMENSION(ND) :: RADIUSorg, VELOorg, TAUSCALorg, RI,
-     >                       OPAROSSorg, Torg, T1old, T2old, T3old,
-     >                       GEDDTHOM, GEFFL, GAMMARAD, RHELP,
-     >                       ENTOTorg, DR, ARADHELP, RNEorg
-      REAL, DIMENSION(ND-1) :: ARADmod
+     >                       Torg, T1old, T2old, T3old, TMOD, TMODorg,
+     >                       GEFFL, GEFFLnew, GAMMARAD, 
+     >                       ENTOTorg, DR, AMACH, AMACHorg, RNEorg,
+     >                       MacroDamp, RNEdummy, 
+     >                       RHELP, ARADHELP, VHELP
+      REAL, DIMENSION(ND-1) :: ARAD, APRESS, AMECH, AGRAV, 
+     >                         HTOTL, HTOTCMF0, HMEAN, ARADmod
           
       REAL :: ATMEAN, FM, STEPDAMP, RSTARSU, RNEL, XMSTARG,
      >        VFINAL, VMINCAND, BETA, BETA2, BETA2FRACTION, TAUCURMAX,
      >        VPAR1, VPAR2, HSCALE, VPAR1_2, VPAR2_2, FQLIMIT,
      >        RCON, VMINOLD, VMINOLD2, CORLOG, VCON, ARADL, FQ,
-     >        TAUCHECK, TROLD, TROLD2, TAU23, R23, GEDDL,
+     >        TAUCHECK, TROLD, TROLD2, TAU23, R23, Tcon, GEDDL,
      >        VMIN_over, VMIN_under, VMIN_min, VMIN_max, DARADDR,
-     >        DAGRAVDR, RL, XLSTAR, XLSTARS, Qhopf, Qorg, 
+     >        DAGRAVDR, RL, RHOL, XLSTAR, XLSTARS, Qhopf, Qorg, 
      >        P1, P2, RHOINT, APR, GFR, VPAR1cand, VPAR2cand,
      >        GAMMARADMEAN, VL, TL, TscaleFac, RINT, TAUINT,
      >        facMass, DIFF1, DIFF2, ENTOTL, AGRAVL, MECHRATIOLOG,
      >        HSCALEold, TauGammaEffect, QIONMEAN, fGAMMACOR, XMG,
-     >        GAMMARADMEANcalc, GEDDreducenow, RCRIT, ENEL,
+     >        GAMMARADMEANcalc, GEDDreducenow, RCRIT, tempREAL,
      >        GLOGorg, XMSTARorg, GEFFLOGorg, HYSTRATIO, GEDDreduceL,
-     >        DIFFTAUMAX_J, DIFFTAUMAX_MIN, 
-     >        QVorg, QVnew, QRHOnew, QRHOorg, Textrap, TAUTHICK
-      REAL, DIMENSION(3) :: TMCORRMAX
+     >        BESTTAUACC, CURTAUACC, ReduceTauCorrections, ENEL,
+     >        QVorg, QVnew, QRHOorg, QRHOnew, RONSET,
+     >        DIFFTAUMAX_MIN, DIFFTAUMAX_J,
+     >        Textrap, TAUTHICK, HYSTMODRATIO, HDRATIO, AMECHL, VELOINT
 
-C***  Vector, true if HYSTACC fulfilled per depth point 
-      LOGICAL, DIMENSION(ND) :: HYSTGOOD
+      REAL, DIMENSION(3) :: TMCORRMAX
+      LOGICAL, DIMENSION(ND) :: HYSTGOOD        !HYSTACC fullfilled per depth point (or not)
       
       CHARACTER(8), DIMENSION(ND) :: VELOCRITERION
-      CHARACTER(40) :: ACTPAR
+      CHARACTER(40), DIMENSION(20) :: CURPAR
       CHARACTER(4) :: TMENFCRIT, CTFMT
-      CHARACTER(8) :: TAUFLAB
+      CHARACTER(12) :: TAUFLAB
 
       LOGICAL bNewVelo, bHydroStat, bNoRGrid, bNoDetails, 
-     >        bTauInterpolation, bUseBisection, bTauCycle,
-     >        bReduceDone, bThinImprove, bFixGEFF, bHScaleOnly,
+     >        bTauMaxSafe,
+     >        bTauInterpolation, bTauCycle,
+     >        bReduceDone, bFixGEFF, bHScaleOnly,
      >        bFULLHYDROSTAT, bGAMMARADMEAN, bPrintChanges, 
      >        bForceTAUMAX, bPrintHYST, bTauInterval, 
-     >        bTMTHOM, bTMNoOS, bHYSTloose, bUseENTOT, bRCON,
-     >        bARADCHECK, bOldThinGrid, bVDAMP, bWRCnext
+     >        bTMNoOS, bHYSTloose, bUseENTOT, bRCON,
+     >        bSKIPNEGARAD, bARADCHECK, bOldThinGrid, bVDAMP, bTMIX,
+     >        bWRCnext, bIVWRC, bKeepTTAU
       
-      REAL, EXTERNAL :: WRVEL   !velocity field function 
+      REAL, EXTERNAL :: WRVEL         !velocity field function WRVEL(L) return type
 
 C***  Tiefenabhaengiges Clumping nach Goetz Graefener
       REAL, DIMENSION(ND), INTENT(INOUT) :: DENSCON, FILLFAC       
       REAL, INTENT(IN) :: DENSCON_FIX
-      CHARACTER(80), INTENT(IN) :: DENSCON_LINE, ThinCard
+      CHARACTER(120), INTENT(IN) :: DENSCON_LINE, ThinCard, TaumaxCard
 
-C***  !contains all RADIUS-GRID CARDS (for subr. RGRID)
-      CHARACTER(80), DIMENSION(3) :: RadiusGridParameters           
+      CHARACTER(80), DIMENSION(3) :: RadiusGridParameters           !contains all RADIUS-GRID CARDS (for subr. RGRID)
 
       REAL, DIMENSION(NP), INTENT(INOUT) :: P
       REAL, DIMENSION(ND*NP), INTENT(INOUT) :: Z
 
 C***  The following variables are just declared to call PRIMOD
-      LOGICAL :: OLDTEMP, BTWOT, TTABLE, FALSEdummy
+      LOGICAL :: OLDTEMP, BTWOT, TTABLE, FALSEdummy, bSMOCO
       REAL :: TFAC, TEFFdummy, ZEROdummy, ZEROdummy2
       INTEGER :: JOBNOLD, JOBNOLD2
       CHARACTER(100) :: MODHEAD, MODOLD, MODOLD2
@@ -277,13 +288,29 @@
       ZEROdummy2 = 0.
       FALSEdummy = .FALSE.
       bForceTAUMAX = .FALSE.
+      RCRIT = -1.
       
-C***  interpolate POPNUM, GEFFL over ENTOT (if true), or RADIUS (if false)
-      bUseENTOT = .FALSE.      
+C***  Default settings of advanced options      
+      bTauMaxSafe = .FALSE.     !if true taumax is only adjusted if all depth points are conv.
+      ReduceTauCorrections = 1.0    !default reducing factor for vmin changes in taumax enforcement routine
+      TauCorLimits(1) = -999.       !
+      TauCorLimits(2) = -999.
+      FQLIMIT = -1.                 !default: no flux ratio limit for TAUMAX fixing
+      bHYSTloose = .FALSE.         !if true, ensuretaumax is not enforced if TAUMAX is good, but HYST not
+      bNoRGrid = .FALSE.           !.FALSE. = change to a new grid (default)
+
+C***  Numerical tweaks      
+      bUseENTOT = .FALSE.          !if true, interpolations are performed over density instead of radius
+      bTMIX = .FALSE.
+      bKeepTTAU = .TRUE.           !if true, the temperature in the opt. thick part is interpolated on TAU afterwards
 
+C***  Debug options      
       bPrintHYST = .FALSE.     !default: do not print hydrostatic situation
       bPrintChanges = .FALSE.  !default: do not print changes to V and T
       
+C**** Default: perform stratification update before next WRCONT 
+      bIVWRC = .TRUE.
+
 C***  if true, TAUMAX iteration is performed in only every NTAUIV-th job
       bTauInterval = .FALSE.    
       NTAUIV = 5
@@ -292,11 +319,8 @@
 C***   Changed to FALSE by wrh  4-Apr-2019, as suggested by Andreas 
       bTMNoOS = .FALSE.          
       
-C***  if true, iteration is done based on TAUTHOM instead of TAUROSScont
-      bTMTHOM = .FALSE.         
-
 C***  if true, ensuretaumax is not enforced if TAUMAX is good, but HYST not
-      bHYSTloose = .FALSE.      
+C      bHYSTloose = .FALSE.      
 
 C***  if true, damping applies to the whole v(r) changes, otherwise toVMIN only
       bVDAMP = .TRUE.           
@@ -323,6 +347,7 @@
         ENDDO
       ENDIF
       
+      
 C***  Ensure useful format for TAU output, even for very large TAUMAX      
       IF (TAUMAX > 9999.) THEN
         CTFMT = 'G9.5'
@@ -346,6 +371,10 @@
 C***  XMU = mean particle mass (atoms and electrons)
       DO L=1, ND
         XMU(L) = ATMEAN / (1. + RNE(L))
+        AMACH(L) = SQRT ( RGAS * T(L) / XMU(L) / 1.E10 + VTURB(L)**2 )        !modified amach (includes turbulence)
+        AMACHorg(L) = AMACH(L)
+        TMOD(L) =  (T(L) + TOLD(L) + TOLD2(L)) / 3.
+        TMODorg(L) = TMOD(L)
       ENDDO
 
 C***  RHO = mass density from current ENTOT
@@ -363,11 +392,92 @@
 C***  The constant "3.02" converts M_sun/yr/(4pi Rsun^2) gram/cm^2/s 
       FM = 10.**(XMDOT+3.02) / RSTARSU**2 
 
+C***  XMG = GGRAV * XMSTAR       
+      XMG = AGRAV(1) * (RI(1)*RSTAR)**2
+
       RCON = RCONorg
       IF (VMIN < 0.) THEN
           VMIN = VMINCAND
       ENDIF
       
+C***  Decode additional TAUMAX card options      
+      CALL SARGC (TaumaxCard, NPAR)
+      DO i=1, NPAR
+        CALL SARGV(TaumaxCard,i,CURPAR(I))
+      ENDDO      
+      IF (NPAR > 2) THEN
+C***     Note: Basic parameters which are required in more places than just 
+C***           this routine are decoded in DECSTE
+         DO i=3, NPAR 
+            SELECTCASE (CURPAR(i))
+              CASE ('REDUCE')
+                ReduceTauCorrections = 0.2
+                IF (NPAR >= (i+1)) THEN
+                  READ (CURPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    IF (tempREAL > 1. .OR. tempREAL < 0.)  THEN
+                      WRITE (hCPR,'(A)') ' *** Error: invalid choice'
+     >                    // ' of REDUCE parameter, must be '
+     >                    // ' between 0 and 1!'
+                      WRITE (hCPR,*) 
+     >                      'DECSTE: ERROR WHILE DECODING TAUMAX LINE'
+                    ENDIF                  
+                    ReduceTauCorrections = tempREAL
+                  ENDIF                  
+                ENDIF
+              CASE ('CORLIMIT', 'CORRLIMIT')
+                TauCorLimits(1) = -1.0    !Default value
+                IF (NPAR >= (i+1)) THEN
+                  READ (CURPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    TauCorLimits(1) = tempREAL
+                    IF (NPAR >= (i+2)) THEN
+                      !Note: This second parameter is not interpreted yet
+                      READ (CURPAR(i+2),'(F10.0)',IOSTAT=IERR) tempREAL
+                      IF (IERR == 0) THEN
+                        TauCorLimits(2) = tempREAL
+                      ELSE
+                        TauCorLimits(2) = 1.0
+                      ENDIF                                    
+                    ENDIF
+                  ENDIF                                    
+                ENDIF
+              CASE ('FLUXQUOTLIMIT', 'FQLIM', 'FQL')
+                FQLIMIT = 0.05  !default if criterion is set
+                IF (NPAR >= (i+1)) THEN
+                  READ (CURPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    FQLIMIT = tempREAL
+                  ENDIF           
+                ENDIF            
+              CASE ('OS', 'ALLOWOV', 'OVERSHOOT')
+                bTMNoOS = .FALSE.               
+              CASE ('IV')
+                bTauInterval = .TRUE.
+                IF (NPAR >= (i+1)) THEN
+                  READ (CURPAR(i+1), '(F10.0)', IOSTAT=IERR) tempREAL
+                  IF (IERR == 0) THEN
+                    NTAUIV = IFIX(tempREAL)
+                  ENDIF           
+                ENDIF            
+              CASE ('NOIVWRC')
+                bIVWRC = .FALSE.
+              CASE ('FIXGRID')
+                bNoRGrid = .TRUE.               
+              CASE ('TMIX')
+                bTMIX = .TRUE.               
+              CASE ('VMIX')
+                bVDAMP = .TRUE.               
+              CASE ('NOVMIX')
+                bVDAMP = .FALSE.         
+              CASE ('NOTTAU')
+                bKeepTTAU = .FALSE.
+              CASE ('SAFE')
+                bTauMaxSafe = .TRUE.
+            ENDSELECT
+         ENDDO      
+      ENDIF
+      
       !This calculates the continuum tau-rosseland vector
       CALL TAUSCAL(RSTAR, ND, RADIUS, RNE, ENTOT,
      >              T, POPNUM, NDIM, N, EN, LEVEL, NCHARG, WEIGHT,
@@ -376,9 +486,9 @@
      >              IGAUNT, NOM, NF,
      >              XLAMBDA, FWEIGHT,
      >              TAUTHOM, TAUROSScont,
-     >              MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT,
+     >              MAXATOM, MAXION, SIGMATHK, SEXPOK, EDGEK, KODAT,
      >              KONTNUP, KONTLOW, LASTKON, 
-     >              DENSCON, FILLFAC
+     >              DENSCON, FILLFAC, POPMIN
      >     )
      
 C***  Consistency check: Is VFINAL kept? Stop otherwise!
@@ -423,16 +533,17 @@
           IF (ABS(HYSTRATIO) > HYSTACC) THEN
             HYSTGOOD(L) = .FALSE.
             IF (bFULLHYDROSTAT) THEN
-              ! Enforce TAUMAX iteration even with good TAUMAX if 
-              ! hydrostatic equation is not fulfilled.
-              ! (can be switched off with the "LOOSE" option)
+              !Enforece TAUMAX iteration even with good TAUMAX if 
+              ! hydrostatic equation is not fullfilled but should
+              ! be due to specified CARDS parameters
+              ! (can be skipped if LOOSE option is set on HYDROSTATIC INTEGRATION card)
               bForceTAUMAX = .NOT. bHYSTloose
             ENDIF
             NHYSTBAD = NHYSTBAD + 1
           ENDIF
           IF (bPrintHYST) THEN
-            WRITE (hCPR,'(A, I3, 3X, F7.4, 2X, L1, 1(3X, F12.5))') 
-     >        'HyS: ', L, HYSTRATIO, HYSTGOOD(L), VELO(L)
+            WRITE (hCPR,'(A, I3, 3X, F7.4, 2X, L1, 2(3X, F12.5))') 
+     >        'HyS: ', L, HYSTRATIO, HYSTGOOD(L), AMACH(L), VELO(L)
           ENDIF
         ENDIF
       ENDDO      
@@ -450,10 +561,10 @@
 C***  Otherwise it refers to the full Rosseland continuum tau. (default)
       IF (bTMTHOM) THEN
         TAUCURMAX = TAUTHOM(ND)
-        TAUFLAB = ' TAUTHOM'
+        TAUFLAB = '    TAUTHOM '
       ELSE
         TAUCURMAX = TAUROSScont(ND)
-        TAUFLAB = ' TAUcont'
+        TAUFLAB = ' TAUROSScont'
       ENDIF
       
 C***  Interval option for velocity update
@@ -461,10 +572,12 @@
 C***  criteria enforces this, it is also possible to restrict the run of
 C***  this routine to every N-th STEAL job.
 C***  To switch this on, the bTauInterval logical must be .TRUE.
-      IF (.NOT. bWRCnext) THEN
-            WRITE (hCPR,FMT='(A,F6.1,A,I2,A,F10.5)') 
-     >      'TAUMAX update postponed; current values: ' //
-     >        'TAUMAX=', TAUMAX,
+      IF ((LASTTAU >= 0 .AND. LASTTAU < NTAUIV .AND. bTauInterval)
+     >                         .OR. (bIVWRC .AND. .NOT. bWRCnext)) THEN
+         WRITE (hCPR, FMT='(A)') 
+     >      'ENSURETAUMAX is skipped in this job.'
+            WRITE (hCPR,FMT='(A,F10.5,A,I2,A,F10.5)') 
+     >        ' current diagnosis: TAUMAX=', TAUMAX,
      >        '  ' // TAUFLAB // '(',ND ,')=', TAUCURMAX
             bTauUpdated = .FALSE.
          RETURN
@@ -540,7 +653,15 @@
         ARADmod(L) = ARAD(L)
       ENDDO
       
-C***  Interpolate over negative ARAD (and negative FLUX) points
+      IF (.NOT. bTMIX) THEN
+        DO L=1, ND
+          TMOD(L) = T(L)
+        ENDDO
+      ENDIF
+      
+C***  Check for positive ARAD and warn (+smooth) or skip TAUMAX 
+C***   if any negative value occurs in the relevant (hydrostatic) part
+      bSKIPNEGARAD = .FALSE.
       bARADCHECK = .FALSE.
       LL=0
       LCHECK=0
@@ -548,9 +669,31 @@
         IF (.NOT. bFULLHYDROSTAT) EXIT
         IF (bGAMMARADMEAN) EXIT
         bARADCHECK = .TRUE.
+c***    Sanity check => skip routine if ARAD from COLI is not yet available
+        IF (bNoARAD) THEN
+          WRITE (hCPR, FMT='(A)') 
+     >      'ENSURETAUMAX skipped because ARAD is not yet calculated.'
+        ENDIF
         TAUINT = 0.5 * (TAUROSS(L) + TAUROSS(L+1))
         LCHECK = LCHECK + 1
-        IF (ARAD(L) > 0. .AND. HTOTL(L) > 0.) THEN
+        IF (ARAD(L) < 0. .OR. HTOTL(L) < 0.) THEN
+          IF (bSKIPNEGARAD) THEN
+            IF (ARAD(L) < 0.) THEN
+              WRITE (hCPR, FMT='(A)') 
+     >          'ENSURETAUMAX skipped due to negative a_rad.'
+            ELSE
+              WRITE (hCPR, FMT='(A)') 
+     >          'ENSURETAUMAX skipped due to negative flux.'
+            ENDIF
+            WRITE (hCPR,FMT='(A,F10.5,A,I2,A,F10.5)') 
+     >        ' current diagnosis: TAUMAX=', TAUMAX,
+     >        '  ' // TAUFLAB // '(',ND ,')=', TAUCURMAX
+            bTauUpdated = .FALSE.
+            RETURN
+          ELSE 
+            WRITE (hCPR,*) 'Skipping ', ARAD(L), HTOTL(L)
+          ENDIF
+        ELSEIF (.NOT. bSKIPNEGARAD) THEN
 C***      Store "good" ARAD values in HELP arrays for interpolation  
           LL = LL + 1
           ARADHELP(LL) = ARAD(L)
@@ -559,8 +702,8 @@
         ENDIF
       ENDDO      
 
-C***  Interpolation
-C***  for boundaries: take last "good" value
+C***  Interpolate over negative ARAD (and negative FLUX) points
+C***  (for boundaries: take last "good" value)
 C***  There must always be at least two good points
 C***  (if LL == LCHECK all ARAD values are fine and nothing needs to be done!)
       IF (LL < LCHECK .AND. LL >= 2) THEN
@@ -575,7 +718,7 @@
             CALL SPLINPOX(ARADmod(L),RI(L),ARADHELP,RHELP,LL)
           ENDIF
         ENDDO               
-      ELSEIF (bARADCHECK .AND. LL < 2) THEN
+      ELSEIF (bARADCHECK .AND. (.NOT. bSKIPNEGARAD) .AND. LL < 2) THEN
         WRITE (hCPR, FMT='(A)') 
      >   'WARNING: BAD ARAD => ENSURETAUMAX SKIP FORCED'        
           WRITE (hCPR,FMT='(A,F10.5,A,I2,A,F10.5)') 
@@ -640,6 +783,7 @@
         TAUSCALorg(L) = TAUROSScont(L)
         ENTOTorg(L) = ENTOT(L)
         Torg(L) = T(L)
+        TMODorg(L) = TMOD(L)
         RNEorg(L) = RNE(L)
       ENDDO
       DO K=1, NF
@@ -655,6 +799,15 @@
 C***  (NDIM+2)*(NDIM+2)
       CALL BACKUPPOPNUM(ND, N, POPNUM, SCRATCH)      
 
+C***  Calculate "quality" of old grid
+C***  (will be used in a later comparison with a potential new grid)
+      QRHOorg = 1.
+      QVorg = 0.
+      DO L=1, ND-1
+        QRHOorg = MAX(QRHOorg, RHO(L+1)/RHO(L))
+        QVorg = MAX(QVorg, VELO(L) - VELO(L+1))        
+      ENDDO
+
 C***  Calculate Eddington Gamma and g_eff
       XLSTAR = PI4 * STEBOL * RSTAR*RSTAR * TEFF*TEFF*TEFF*TEFF
       XLSTARS = XLSTAR / XLSUN
@@ -682,6 +835,7 @@
         ENDIF
         ENTOT(L) = ENTOTorg(L)
         T(L) = Torg(L)
+        TMOD(L) = TMODorg(L)
         RNE(L) = RNEorg(L)
         XMU(L) = ATMEAN / (1. + RNE(L))
       ENDDO
@@ -728,9 +882,9 @@
         !GEFF was fixed by wrstart => Calculate GEDD and new mass
         CALL CALCMASSFROMGEFF(bFixGEFF, bFULLHYDROSTAT,
      >                        XMSTAR, GLOG, GEFFLOG, 
-     >                        ARAD, APRESS, AGRAV, RADIUS, ND,
-     >                        RSTAR, RCON, RI, TAUROSS,
-     >                        GAMMARADMEAN, GEDD,
+     >                        ARADmod, APRESS, AGRAV, RADIUS, ND,
+     >                        RSTAR, RCON, RI, VELO, TAUROSS,
+     >                        VMACH, GAMMARADMEAN, GEDD,
      >                        LOG10(XLSTARS), QIONMEAN, fGAMMACOR)
         IF (bFULLHYDROSTAT) THEN
           GEDD = GAMMARADMEAN
@@ -814,7 +968,8 @@
             GEFFL(L) = 10**(GEFFLOG)
           ELSE
             GEFFL(L) = (10**GLOG) 
-     >        - RNE(L)/(ATMEAN*QIONMEAN) * ( (10**GLOG) - (10**GEFFLOG) ) 
+     >        - RNE(L)/(ATMEAN*QIONMEAN) * ((10**GLOG) - (10**GEFFLOG)) 
+     >                      * MacroDamp(L)      !needed if MACROCLUMP cards option is used
           ENDIF
         ENDIF
       ENDDO
@@ -829,7 +984,6 @@
       bHydroStat = .TRUE.      !default value: hydrostatic domain is achieved
 
       !prepare bisection    
-      bUseBisection = .FALSE.   !FALSE = bisection method is currently not in use
       VMIN_over = -1.0
       VMIN_under = -1.0
       VMIN_min = VMIN
@@ -851,9 +1005,12 @@
         WRITE (hCPR,*) 'ENSURETAUMAX WARNING> Old velocity might not '
      >    // 'be a beta-type law'
         RCON = RADIUS(1)    !this is needed to avoid SPLINPOX errors
-        bRCON= .FALSE.
+        bRCON = .FALSE.
+      ELSEIF (RCON < RADIUS(ND)) THEN
+C**     Previous stratification had no hydrostatic domain (on current grid)
+        bRCON = .FALSE.
       ELSE
-        bRCON= .TRUE.
+        bRCON = .TRUE.
       ENDIF
 
 C***  Major update Mar 2016: In contrast to earlier versions,
@@ -894,7 +1051,7 @@
 C***        Damping the correction may be counter-productive, when 
 C***        the relation between VMIN and TAUMAX was non-monotonic!
 C***        Therefore:
-            bReduceDone = .TRUE.
+            IF (bVDAMP) bReduceDone = .TRUE.
           ENDIF
 
 C***      Transfer VMIN to VELPAR common block          
@@ -911,7 +1068,7 @@
 C***      for HYDROSTATIC INTEGRATION only the scale height H_0 is calculated
           bHScaleOnly = bThinWind
           CALL INITVEL (RMAX, TEFF, GEFFLOG, RSTAR, XMU(ND),
-     >                  VTURB, bHScaleOnly, bHydroStat) 
+     >                  VTURB(ND), bHScaleOnly, bHydroStat) 
 
 C***      bThinWind = HYDROSTATIC INTEGRATION card has been found            
           IF (bThinWind) THEN
@@ -920,9 +1077,8 @@
 C***        The default connection criterion a continouus gradient
 C***        between both velocity laws
 C***        (can be changed to a fraction of the sonic speed via CARDS option)
-            CALL VELTHIN (T, RADIUS, VELO, ND, RSTAR, RMAX,
+            CALL VELTHIN (TMOD, RADIUS, VELO, ND, RSTAR, RMAX,
      >                    GEFFL, XMU, VTURB, ThinCard, VELOCRITERION)
-     
           ELSE
 C***        Simple exponential law with constant scale height 
 C***        (i.e. barometric formula) in the inner part:
@@ -953,6 +1109,8 @@
             SELECTCASE (VELOCRITERION(L))
               CASE ('HYSTINT ')
                 VCRIT(L) = 'HS      '
+              CASE ('HYDROINT')
+                VCRIT(L) = 'HD      '
               CASE ('STATIC  ')
                 VCRIT(L) = 'ST      '
               CASE ('BETA    ')
@@ -990,9 +1148,9 @@
      >              IGAUNT, NOM, NF,
      >              XLAMBDA, FWEIGHT,
      >              TAUTHOM, TAUROSScont,
-     >              MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT,
+     >              MAXATOM, MAXION, SIGMATHK, SEXPOK, EDGEK, KODAT,
      >              KONTNUP, KONTLOW, LASTKON, 
-     >              DENSCON, FILLFAC
+     >              DENSCON, FILLFAC, POPMIN
      >      )
           IF (bTMTHOM) THEN
             TAUCURMAX = TAUTHOM(ND)
@@ -1064,33 +1222,35 @@
               CYCLE
             ENDIF            
 
-C***        If not yet converged:
-            IF (ABS(TAUCURMAX-TAUMAX) > TAUACC) THEN
-C***           Check if bisection is possible               
-               IF (VMIN_OVER > .0 .AND. VMIN_UNDER > .0) THEN
-                  VMIN = 0.5 * (VMIN_OVER + VMIN_UNDER)
-                  BTAUCYCLE = .TRUE.
-               ENDIF 
+            
+              !How effective is this stuff?
+              IF (((ABS(TAUCURMAX) - TAUMAX) > TAUACC) .AND.
+     >                                (ITTAU/10*10 == ITTAU) .AND. 
+     >                             ((TROLD - TROLD2) > TAUACC)) THEN
+                VMIN = (VMINOLD2*(TROLD-TAUMAX) - 
+     >                VMINOLD*(TROLD2-TAUMAX)) / 
+     >                  (TROLD - TROLD2)
+                bTauCycle = .TRUE.
             ENDIF
 
 C***          TAUROSScont TOO LARGE: New vmin is at v(TAUMAX) using spline interpolation
               IF (bTauStrict .AND. (.NOT. bTauCycle) .AND.
      >            (TAUCURMAX > TAUMAX+TAUACC)) THEN
-                VMIN = VMIN*(TAUCURMAX/TAUMAX)**(.5*STEPDAMP)
-c                !SPLINPO offen makes a too large step inside, try other things first
-c                IF ((VMINOLD2 > 0.) .AND. (TROLD2 > 0.) .AND. 
-c     >                           (TROLD2 < (TAUMAX-TAUACC))) THEN
-c                  !Only last step was too large, try half step
-c                  VMIN = (VMINOLD2 + VMINOLD) / 2.
-c                ELSEIF (bTMTHOM) THEN
-c                  ! standard method: 
-c                  ! calculate new v_min by using v(tau) interpolation
-c                  CALL SPLINPOX(VMIN, TAUMAX, VELO, TAUTHOM, ND)
-c                ELSE
-c                  ! standard method: 
-c                  ! calculate new v_min by using v(tau) interpolation
-c                  CALL SPLINPOX(VMIN, TAUMAX, VELO, TAUROSScont, ND)
-c                ENDIF
+                VMIN_over = VMIN
+                !SPLINPO offen makes a too large step inside, try other things first
+                IF ((VMINOLD2 > 0.) .AND. (TROLD2 > 0.) .AND. 
+     >                           (TROLD2 < (TAUMAX-TAUACC))) THEN
+                  !Only last step was too large, try half step
+                  VMIN = (VMINOLD2 + VMINOLD) / 2.
+                ELSEIF (bTMTHOM) THEN
+                  ! standard method: 
+                  ! calculate new v_min by using v(tau) interpolation
+                  CALL SPLINPOX(VMIN, TAUMAX, VELO, TAUTHOM, ND)
+                ELSE
+                  ! standard method: 
+                  ! calculate new v_min by using v(tau) interpolation
+                  CALL SPLINPOX(VMIN, TAUMAX, VELO, TAUROSScont, ND)
+                ENDIF
                 bTauCycle = .TRUE.
               ENDIF
 
@@ -1098,6 +1258,7 @@
               !STEPDAMP can damp this adjustment by using higher roots
               IF ((.NOT. bTauCycle) 
      >             .AND. (TAUCURMAX < TAUMAX-TAUACC)) THEN
+                VMIN_under = VMIN
                 VMIN = VMIN*(TAUCURMAX/TAUMAX)**(.5*STEPDAMP)
                 bTauCycle = .TRUE.                
               ENDIF
@@ -1158,9 +1319,9 @@
      >                IGAUNT, NOM, NF,
      >                XLAMBDA, FWEIGHT,
      >                TAUTHOM, TAUROSScont,
-     >                MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT,
+     >              MAXATOM, MAXION, SIGMATHK, SEXPOK, EDGEK, KODAT,
      >                KONTNUP, KONTLOW, LASTKON, 
-     >                DENSCON, FILLFAC
+     >              DENSCON, FILLFAC, POPMIN
      >        )
               IF (bTMTHOM) THEN
                 TAUCURMAX = TAUTHOM(ND)
@@ -1220,7 +1381,8 @@
       ENDDO
 
 C***  To test for a new grid, bNoRGrid needs to be .FALSE.      
-      bNoRGrid = .FALSE.    
+c     This is overruled by a CARDS setting
+c      bNoRGrid = .FALSE.    
       
       gridloop: DO
       
@@ -1285,28 +1447,33 @@
       IF (.NOT. bNoRGrid) THEN
             
 C***    Interpolation of temperature on the new radius grid
-        CALL INTERPOLATETEMP(T, Torg, RADIUS, RADIUSorg, ND)
+        CALL INTERPOLATETEMP(T, Torg, RADIUS, RADIUSorg, 
+     >                       ENTOT, ENTOTorg,  
+     >                       TAUROSS, TEFF, ND, bUseENTOT)
 
 C***    Interpolation of Popnumbers on new radius grid
         CALL INTERPOLATEPOPNUM(POPNUM, SCRATCH, POPMIN,
      >                         RADIUS, RADIUSorg, ENTOT, ENTOTorg,
+     >                         RNE, RNEorg, T, Torg,
      >                         N, ND, ABXYZ, NFIRST, NLAST, NATOM, 
+     >                         NCHARG, WEIGHT, EION, ELEVEL, NOM,
      >                         bUseENTOT)
 
-C***    re-calculate RNE(L) and XMU(L) from new POPNUMs
+C***    re-calculate XMU(L) from new POPNUMs
         DO L=1, ND
-          RNEL=0.0
-          DO J=1,N
-            RNEL = RNEL + NCHARG(J) * POPNUM(L,J)
-          ENDDO
-          RNE(L)=RNEL
           XMU(L) = ATMEAN / (1. + RNE(L))
         ENDDO
 
 C***    --- Interpolation of old temperatures on Radius-Grid ---
-        CALL INTERPOLATETEMP(TOLD , T1old, RADIUS, RADIUSorg, ND)
-        CALL INTERPOLATETEMP(TOLD2, T2old, RADIUS, RADIUSorg, ND)
-        CALL INTERPOLATETEMP(TOLD3, T3old, RADIUS, RADIUSorg, ND)
+        CALL INTERPOLATETEMP (TOLD, T1old, RADIUS, RADIUSorg, 
+     >                        ENTOT, ENTOTorg,  
+     >                        TAUROSS, TEFF, ND, bUseENTOT)
+        CALL INTERPOLATETEMP (TOLD2, T2old, RADIUS, RADIUSorg, 
+     >                        ENTOT, ENTOTorg,  
+     >                        TAUROSS, TEFF, ND, bUseENTOT)
+        CALL INTERPOLATETEMP (TOLD3, T3old, RADIUS, RADIUSorg, 
+     >                        ENTOT, ENTOTorg,  
+     >                        TAUROSS, TEFF, ND, bUseENTOT)
         
         WRITE (hCPR,*) '*** ENSURETAUMAX: New radius grid established'
         
@@ -1329,12 +1496,18 @@
       ENDDO
     
       DO L=1, ND 
+        IF (.NOT. bKeepTTAU) EXIT
         IF (TAUROSScont(L) < TAUTHICK) CYCLE
         IF (TAUROSScont(L) <= TAUSCALorg(ND)) THEN
           CALL SPLINPOX(T(L), TAUROSScont(L), Torg, TAUSCALorg, ND)
           CALL SPLINPOX(TOLD(L), TAUROSScont(L), T1old, TAUSCALorg, ND)
-          CALL SPLINPOX(TOLD2(L), TAUROSScont(L), T2old, TAUSCALorg, ND)
-          CALL SPLINPOX(TOLD3(L), TAUROSScont(L), T3old, TAUSCALorg, ND)
+          IF (NTOLD > 1) THEN
+            CALL SPLINPOX(TOLD2(L),TAUROSScont(L),T2old,TAUSCALorg, ND)
+          ENDIF
+          IF (NTOLD > 2) THEN
+            CALL SPLINPOX(TOLD3(L),TAUROSScont(L),T3old,TAUSCALorg, ND)
+          ENDIF
+C***      Note: SCRATCH still contains the POPNUMs on TAUSCALorg
           DO J=1, ND
             CALL SPLINPOX(POPNUM(L,J), TAUROSScont(L), 
      >                                SCRATCH(1,J), TAUSCALorg, ND)
@@ -1343,8 +1516,12 @@
           Textrap= ((TAUROSScont(L)+0.67)/(TAUSCALorg(ND)+0.67))**(0.25)
           T(L)     = Torg(ND)  * Textrap
           TOLD(L)  = T1old(ND) * Textrap
-          TOLD2(L) = T2old(ND) * Textrap
-          TOLD3(L) = T3old(ND) * Textrap
+          IF (NTOLD > 1) TOLD2(L) = T2old(ND) * Textrap
+          IF (NTOLD > 2) TOLD3(L) = T3old(ND) * Textrap
+C!TEST    DEBUG OUTPUT
+c          WRITE (hCPR,'(A,I2,5(2X,G14.6))') 'DEBUG TEXTRAP ', L, 
+c     >          Torg(ND), T(L), TAUSCALorg(ND), TAUROSScont(L), 
+c     >          (TAUROSScont(L)/TAUSCALorg(ND))**(0.25)
 
           ENEL = RNE(L) * ENTOT(L)
 C***      LTEPOP returns the LTE population numbers
@@ -1365,34 +1542,41 @@
         XMU(L) = ATMEAN / (1. + RNE(L))
       ENDDO
             
+      CALL POP_RENORM(POPNUM, ND, N, NATOM, NFIRST, NLAST, ABXYZ)
+            
+            
+      DO L=1, ND
+        RNEdummy(L) = RNE(L)
+      ENDDO
+            
             
 C***  Interpolation of older popnumbers on the new radius grid
 C***  and interpolation on TAU in the optical thick part
       CALL REGRIDOLDPOP(POP1, T1old, SCRATCH, ND, N, T,
      >                  POPMIN, TAUTHICK, bNoRGrid,
      >                  RADIUS, RADIUSorg, ENTOT, ENTOTorg,
-     >                  RNE, RNEorg, ABXYZ, NFIRST, NLAST, 
+     >                  RNEdummy, RNEorg, ABXYZ, NFIRST, NLAST, 
      >                  NATOM, WEIGHT, NCHARG, EION, ELEVEL, NOM, 
      >                  TAUROSScont, TAUSCALorg,
-     >                  EN, DEPARTNDorg, bUseENTOT)
+     >                  EN, DEPARTNDorg, bUseENTOT, bKeepTTAU)
 
       IF (NTOLD > 1) THEN      
         CALL REGRIDOLDPOP(POP2, T2old, SCRATCH, ND, N, T,
      >                    POPMIN, TAUTHICK, bNoRGrid,
      >                    RADIUS, RADIUSorg, ENTOT, ENTOTorg,
-     >                    RNE, RNEorg, ABXYZ, NFIRST, NLAST, 
+     >                    RNEdummy, RNEorg, ABXYZ, NFIRST, NLAST, 
      >                    NATOM, WEIGHT, NCHARG, EION, ELEVEL, NOM, 
      >                    TAUROSScont, TAUSCALorg,
-     >                    EN, DEPARTNDorg, bUseENTOT)
+     >                    EN, DEPARTNDorg, bUseENTOT, bKeepTTAU)
       ENDIF
       IF (NTOLD > 2) THEN      
         CALL REGRIDOLDPOP(POP3, T3old, SCRATCH, ND, N, T,
      >                    POPMIN, TAUTHICK, bNoRGrid,
      >                    RADIUS, RADIUSorg, ENTOT, ENTOTorg,
-     >                    RNE, RNEorg, ABXYZ, NFIRST, NLAST, 
+     >                    RNEdummy, RNEorg, ABXYZ, NFIRST, NLAST, 
      >                    NATOM, WEIGHT, NCHARG, EION, ELEVEL, NOM, 
      >                    TAUROSScont, TAUSCALorg,
-     >                    EN, DEPARTNDorg, bUseENTOT)
+     >                    EN, DEPARTNDorg, bUseENTOT, bKeepTTAU)
       ENDIF
 
 C     ------- end of POPNUM interpolation ----------------------
@@ -1410,9 +1594,9 @@
      >             IGAUNT, NOM, NF,
      >             XLAMBDA, FWEIGHT,
      >             TAUTHOM, TAUROSScont,
-     >             MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT,
+     >             MAXATOM, MAXION, SIGMATHK, SEXPOK, EDGEK, KODAT,
      >             KONTNUP, KONTLOW, LASTKON, 
-     >             DENSCON, FILLFAC)
+     >             DENSCON, FILLFAC, POPMIN)
             
 C***  Final calculation of the DENSCON and FILLFAC vectors,
 C***  now including all damping and grid update effects
@@ -1512,7 +1696,7 @@
      >             R23, TEFF, bThinWind, ITTAU, MAXITTAU, RCON, 
      >             BTWOT, MODOLD2, JOBNOLD2, TFAC,
      >             BETA, VPAR1cand, VPAR2cand, DENSCON, BETA2, 
-     >             BETA2FRACTION, HSCALE, bNoDetails,.FALSE.,VTURB)
+     >             BETA2FRACTION, HSCALE, bNoDetails,.FALSE.,VTURB(ND))
 
       GEDDRAD = GAMMARADMEAN        !store new GAMMARADMEAN in GEDDRAD (saved in MODEL)
       bTauUpdated = .TRUE.
diff -bur ./expint1exp.f ../../powr-refactor/src/expint1exp.f
--- ./expint1exp.f	2024-07-28 13:13:22.000000000 +0200
+++ ../../powr-refactor/src/expint1exp.f	2023-09-27 10:14:15.105755485 +0200
@@ -53,6 +53,4 @@
       ENDIF
 
       RETURN
-
       END
-
Only in ../../powr-refactor/src/: extrap.exe
Only in ../../powr-refactor/src/: extrap.exe.opt
diff -bur ./extrap.f ../../powr-refactor/src/extrap.f
--- ./extrap.f	2024-07-28 13:13:22.000000000 +0200
+++ ../../powr-refactor/src/extrap.f	2024-02-06 10:04:34.886882505 +0100
@@ -13,19 +13,23 @@
 C***********************************************************************
  
 C***  DEFINE ARRAY DIMENSIONS ******************************************
-      PARAMETER ( MAXATOM =          26 )
-      PARAMETER ( NDIM    =        2560 )
-      PARAMETER ( NFDIM   = 2*NDIM + 400 )
-      PARAMETER ( MAXKONT =     NFDIM/2 )
-      PARAMETER ( MAXIND  =       45000 )
-      PARAMETER ( MAXFEIND  =       1500 )
-      PARAMETER ( NDDIM   =          89 )
-      PARAMETER ( MAXHIST =        4000 )
+      INTEGER, PARAMETER :: MAXATOM =           26 
+      INTEGER, PARAMETER :: NDIM    =         2560 
+      INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400 
+      INTEGER, PARAMETER :: MAXKONT =      NFDIM/2 
+      INTEGER, PARAMETER :: MAXKODR =         NDIM 
+      INTEGER, PARAMETER :: MAXIND  =        45000 
+      INTEGER, PARAMETER :: MAXFEIND  =       2500 
+      INTEGER, PARAMETER :: NDDIM   =           89 
+      INTEGER, PARAMETER :: MAXHIST =         4000 
 C***  NUMBER OF ENTRYS STORED IN THE GAMMA HISTORY
-      PARAMETER (MAXGAHIST = 100)
+      INTEGER, PARAMETER :: MAXGAHIST = 100
+
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR (SEE ALSO SUBR. GAUNTFF)
+      INTEGER, PARAMETER :: MAXION = 27 
  
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      PARAMETER ( MAXAUTO = 2850 )
+      INTEGER, PARAMETER :: MAXAUTO = 3200 
       COMMON / COMAUTO / LOWAUTO(MAXAUTO),WAUTO(MAXAUTO)
      $                  ,EAUTO(MAXAUTO),AAUTO(MAXAUTO),IONAUTO(MAXAUTO)
      $                  ,KRUDAUT(MAXAUTO)
@@ -46,7 +50,6 @@
      $ ,MDUMMY(MAXHIST)
       CHARACTER*8 IGAUNT(MAXKONT), KEYCBF(MAXKONT)
       CHARACTER(MAXHIST*8) :: MODHIST
-      CHARACTER BUFFER40*40, BUFFER32*32
       DIMENSION GAHIST(26,MAXGAHIST)
 C***  PREVENT UNNECESSARY OUTPUT FROM SUBR. PRICORR:
       COMMON / COMNEGI / NEGINTL,INEGMIN,INEGMAX,LNEGMIN,LNEGMAX
@@ -55,38 +58,49 @@
       DATA NEGINTL, NEGT, ITWARN / 0, 0, 0 /
       DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
       DIMENSION EDGEK(MAXATOM,MAXATOM)
+      CHARACTER(255) :: HISTENTRY
+      CHARACTER(40) :: BUFFER40
+      CHARACTER(32) :: BUFFER32
       CHARACTER KARTE*80,MODHEAD*100
       CHARACTER LEVEL(NDIM)*10
       CHARACTER*10 ELEMENT(MAXATOM), ARG(5)
       CHARACTER*4 KEYCBB(MAXIND)
-      CHARACTER*2 SYMBOL(MAXATOM)
-      CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
-      LOGICAL NGACC, NOTEMP, NOEXTEMP, NGWEIGHT, BEX4
+      CHARACTER(2), DIMENSION(MAXATOM) :: SYMBOL
+      CHARACTER(1), DIMENSION(NDDIM) :: CKONVER
+      LOGICAL, DIMENSION(MAXATOM) :: TRACEELEM
+      LOGICAL :: NGACC, NOTEMP, NOEXTEMP, NGWEIGHT, BEX4
  
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5     !std
 C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
 
-      COMMON /IRON/ FEDUMMY(NFEREADMAX),
-     >              INDRB(MAXFEIND),INDRF(MAXFEIND), SIGMAFE(INDEXMAX),
-     >              IFRBSTA(MAXFEIND), IFRBEND(MAXFEIND),
-     >              IFENUP(MAXFEIND), IFELOW(MAXFEIND),
-     >              SIGMAINT(MAXFEIND)
+      REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
+      REAL, DIMENSION(INDEXMAX) :: SIGMAFE
+      REAL, DIMENSION(MAXFEIND) :: SIGMAINT
+      INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
+     >                                IFENUP, IFELOW
       LOGICAL :: BFEMODEL
 
+C***  File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+      INTEGER, PARAMETER :: hMODEL = 3      !write to MODEL file
+      INTEGER, PARAMETER :: hHIST = 21      !write to MODHIST file
+      
+      
 C***  Operating system:
       COMMON / COMOS / OPSYS
       CHARACTER*8 OPSYS
 
       CHARACTER TIM1*10, TIM2*10
 
-      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
-        CALL CLOCK(TIM1)
-      ELSE
-ccc not in gfortran         CALL TIME(TIM1)
-      ENDIF
+c      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+c        CALL CLOCK(TIM1)
+c      ELSE
+c        CALL TIME(TIM1)
+c      ENDIF
 
       CALL       DATOM (NDIM,N,LEVEL,NCHARG , WEIGHT,ELEVEL,EION,MAINQN,
      $                  EINST,ALPHA,SEXPO,
@@ -103,7 +117,7 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
  
 C***  READING OF THE MODEL FILE  ---------------------------------------
       CALL OPENMS(3, IDUMMY, IDUMMY, 1, IERR)
@@ -207,13 +221,10 @@
             ENDIF
       IF ( KARTE(:9) .EQ. 'PRINT POP' ) THEN
 C                          =========
-            IF (NPAR .LT. 3) THEN
-               LSPOP = 1
-            ELSE
-               CALL SARGV (KARTE, 3, ARG(3))
-               READ (ARG(3),'(F10.0)') XL
+            DECODE (80,4,KARTE) XL
+    4       FORMAT (9X,F10.0)
                LSPOP=IFIX(XL)
-            ENDIF
+            IF (LSPOP.EQ.0) LSPOP=1
             GOTO 7
       ENDIF
       IF (ARG(1) .EQ. 'EXTRAP' .AND. ARG(2) .EQ. 'NOTEMP') THEN
@@ -297,6 +308,17 @@
       CALL WRITMS (3,TNEW,ND,'T       ',-1, IDUMMY, IERR)
  
 C***  PRINTOUT  -------------------------------------------------------
+
+C     Dummy setting for CKONVER array (mark all points as converged)
+      DO L=1, ND
+        CKONVER(L) = 'C'
+      ENDDO
+C     Dummy setting for TRACEELEM array 
+      DO K=1, NATOM
+        TRACEELEM(K) = .FALSE.
+      ENDDO
+
+
       IF (LSPOP.GT.0)
      $  CALL PRIEX (ND,N,RNE,LEVEL,POPNUM,JOBNUM,MODHEAD,LSPOP,
      $              TNEW,NOTEMP)
@@ -306,18 +328,20 @@
 
 C***  Commented Lines; full call as in STEAL
       CALL PRICORR (POPNEW, POPNUM, LEVEL, N, ND, MODHEAD, LSPOP,
-C*   $              CORMAX, RTCMAX, JOBNUM, REDUCE,
-     $              CORMAX, RTCMAX, JOBNUM, 1.,      
+C*   $              CORMAX, RTCMAX, JOBNUM, REDUCE, CKONVER,
+     $              CORMAX, RTCMAX, JOBNUM, 1., CKONVER,     
 C*   >              GAMMAC, GAMMAL, GAMMAR, GAMMAD,
      >               0.,      0.,      0.,     0., 
 C*   $              T, TNEW, EPSILON, DELTAC, SMPOP,
      $              T, TNEW, 0.,       1.,    0.,  
-C*   $              BUNLU,  DUNLU, DUNLUR, DUNLU2, BTND, TNDCORR,
-     >              .NOT.NOTEMP, 0.,    0.,     0.,   .FALSE.,  0., 
-C*   >              GAHIST, MAXGAHIST, STHLP,
-     >              GAHIST, MAXGAHIST, .FALSE., 
-C*   >              IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP)
-     >              0,                 0              )
+C*   $              BUNLU,  DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, bTDIFFUS, TNDCORR,
+     >              .NOT.NOTEMP, 0.,    0.,    0.,  0.,  .FALSE.,  0., 
+C*   >              HNDCORFAC, GAHIST, MAXGAHIST, STHLP, ICMMODE,
+     >              1., GAHIST, MAXGAHIST, .FALSE., 1, 
+C*   >              IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP,
+     >              0,                 0              ,
+C*   >              TBTAU, TAUINT, NDOUT, NATOM, NOM, TRACEELEM)
+     >                -1.,   -1., NOUT+1, NATOM, NOM, TRACEELEM)
 
       IF (NOTEMP) THEN
         GAHIST(26,1) = 0.
@@ -347,6 +371,7 @@
       IF (CORMAX > 1.E-100) CORMAX=ALOG10(CORMAX)
       IF (BEX4) THEN
         WRITE(UNIT=BUFFER40, FMT=22) JOBNUM, CORMAX
+C        ENCODE (32,22,MODHIST(LAST+1)) JOBNUM,CORMAX
 C***  NOTE : The word Cor. must not be written in capitals in order to 
 C***         distinguish from COR. of the Main Program STEAL
    22   FORMAT ('/',I7,'. EXTRAP4 Cor.=',F8.4)
@@ -382,6 +407,13 @@
       CALL WRITMS (3,MODHIST,MAXHIST,'MODHIST ',-1, IDUMMY, IERR)
       CALL WRITMS (3, GAHIST, 26*MAXGAHIST, 'GAHIST  ',-1, IDUMMY, IERR)
  
+C***  write model history entry into explicit history file
+      CALL GETHISTENTRY(HISTENTRY,JOBNUM,MODHIST,MAXHIST)
+      OPEN (hHIST, FILE='MODHIST', STATUS='UNKNOWN',
+     >              ACTION='READWRITE', POSITION='APPEND')
+      WRITE (hHIST,FMT='(A)') TRIM(ADJUSTL(HISTENTRY))
+      CLOSE(hHIST)      
+ 
    99 CALL CLOSMS (3, IERR)
 
 C***  NEXT JOB: REPEAT-CYCLE if NEWWRC NE 1
diff -bur ./fecheck.f ../../powr-refactor/src/fecheck.f
--- ./fecheck.f	2024-07-28 13:13:22.000000000 +0200
+++ ../../powr-refactor/src/fecheck.f	2023-11-21 10:10:55.285269778 +0100
@@ -7,9 +7,9 @@
 C***  CALLED FROM COLI
 C***********************************************************************
 
-      DIMENSION INDRB(LASTFE), IFRBSTA(LASTFE), IFRBEND(LASTFE)
-      DIMENSION INDFEACT(LASTFE)
-      LOGICAL BFECHECK, BFEWING
+      INTEGER, DIMENSION(LASTFE) :: INDRB, IFRBSTA, IFRBEND, INDFEACT
+      INTEGER :: LASTFE, MAXFEACT
+      LOGICAL :: BFECHECK, BFEWING
 
 C***  SEARCH FOR LOWEST POSSIBLE TRANSITION
 
@@ -27,6 +27,9 @@
 
       XINDLOW  = FLOAT(IFRBSTA(IND))
 
+C**** Cross-check: Is the first transition INDFEACT(1) an active transition?
+C****              If not, set INDFEACT(1) to first active transition!
+C****              If no transition is active, set BFECHECK = .FALSE.
       IF (XINDF .LT. XINDLOW) THEN
 C ***   NO ACTIVE TRANSITION
          BFECHECK = .FALSE.
@@ -48,17 +51,19 @@
 
  20   CONTINUE
 
+C  *** Improved Wing test: all former transitions are checked ***
 C *** TEST IF RED WING OF ANY LINE IS ACTIVE
       IF ((.NOT. BFECHECK) .AND. (IND .GT. 1)) THEN
 C ***   RED WING OF LAST LINE, WHICH HAS BEEN ACTIVE
-         XINDUP = FLOAT(IFRBEND(IND-1))
+         BFEWING = .FALSE.
+         DO INDW=1, IND-1
+           XINDUP = FLOAT(IFRBEND(INDW-1))
          XINDWING = XINDUP + DFEINDR
-         IF (XINDF .LT. XINDWING) THEN
-C ***      WING IS ACTIVE!
+           IF (XINDF < XINDWING) THEN
             BFEWING = .TRUE.
-         ELSE
-            BFEWING = .FALSE.
+             EXIT
          ENDIF
+         ENDDO
       ELSE
 C ***   WING IS ACTIVE, WHEN LINE IS ACTIVE!         
          BFEWING = BFECHECK
@@ -75,8 +80,11 @@
                MAXFEACT = MAXFEACT + 1
                INDFEACT(MAXFEACT) = IND
             ENDIF
+C         ELSE           !these two lines
+C            EXIT        !are taken from Goetz (can be added for speed, since INDEFEACT is sorted by wavelength)
          ENDIF
       ENDDO
 
+      
       RETURN
       END
diff -bur ./fedat.f ../../powr-refactor/src/fedat.f
--- ./fedat.f	2024-07-28 13:13:22.000000000 +0200
+++ ../../powr-refactor/src/fedat.f	2024-07-22 09:27:16.104033925 +0200
@@ -1,6 +1,6 @@
       SUBROUTINE FEDAT (ROUTINE, INDEXMAX, NFEREADMAX, IONLOW, IONTOP,
-     &                  MAXATOM, NDIM, MAXIND, MAXKONT,       
-     &                  NATOM, N, LASTFE, LASTKON, LASTINDAUTO, MAXFEIND, 
+     &                  MAXATOM, NDIM, MAXIND, MAXKONT, NATOM,      
+     &                  N, LASTFE, LASTKON, LASTINDAUTO, MAXFEIND, 
      &                  EINST, SIGMAFE, INDRB, INDRF, IFENUP, 
      &                  IFELOW, INDNUP, INDLOW, KONTNUP, KONTLOW,
      &                  LEVEL, ELEMENT, SYMBOL, ATMASS, STAGE,
@@ -21,63 +21,87 @@
 C ***
 C **********************************************************************
 
+      IMPLICIT NONE
+
 C***  Local dimensions:
 C***  Maximum number of bound-bound transitions within one ion
-      PARAMETER ( NBBMAX  = 400 )
+c      PARAMETER ( NBBMAX  = 400 )
+      INTEGER, PARAMETER :: NBBMAX = 999  !taken from CREATMS (from blanket program)
 C***  NIONMAX must cover the number of Iron Ionization stages in the FEDAT file
-      PARAMETER ( NIONMAX =  25 )
+      INTEGER, PARAMETER :: NIONMAX = 27
 C***  NROMMAX: Roman Numbers encoded: cf. DATA-Statement for ROMNUM 
-      PARAMETER ( NROMMAX = 25)
+      INTEGER, PARAMETER :: NROMMAX = 27
 C***  Local arrays
-      DIMENSION NB(NIONMAX), NTRA(NIONMAX), NTRB(NIONMAX)
-      DIMENSION NX_A(NBBMAX), NX_B(NBBMAX)
-      CHARACTER ROMNUM(NROMMAX)*4, NAMARRAY(2,NBBMAX)*8
-      CHARACTER(LEN=8)  NAME
-      CHARACTER(LEN=24) GENER
-      CHARACTER(LEN=40) IONNAME(NIONMAX)
-      CHARACTER(LEN=3)  ISTR
+      INTEGER, DIMENSION(NIONMAX) :: NB, NTRA, NTRB
+      INTEGER, DIMENSION(NBBMAX) :: NX_A, NX_B
+      CHARACTER(2) :: CIONBUFFER
+      CHARACTER(5), DIMENSION(NROMMAX) :: ROMNUM 
+      CHARACTER(16), DIMENSION(NBBMAX) :: NAMARRAY
+      CHARACTER(16) :: NAMBUFFER
+      CHARACTER(LEN=8) :: NAME
+      CHARACTER(LEN=24) :: GENER
+      CHARACTER(LEN=40) :: IONNAME(NIONMAX)
+      CHARACTER(LEN=3) :: ISTR
 
 C***  Maximum number of superlevels within the same ion
-      PARAMETER ( MAXLEVEL = 100 )
-      CHARACTER(LEN=8) LEVNAMES(MAXLEVEL)
+      INTEGER, PARAMETER :: MAXLEVEL = 100
+      CHARACTER(LEN=8), DIMENSION(MAXLEVEL) :: LEVNAMES
+
+      LOGICAL :: BEXTEND
 
-      LOGICAL BEXTEND
+      INTEGER, INTENT(IN) :: IONLOW, IONTOP, NATOM, NDIM,
+     >                       MAXIND, MAXATOM, MAXKONT, MAXFEIND, 
+     >                       INDEXMAX, NFEREADMAX, LASTINDAUTO
+      INTEGER, INTENT(INOUT) :: N, LASTFE, LASTKON
 
 C***  Formal Parameters
       CHARACTER(LEN=*)  ROUTINE
-      CHARACTER(LEN=2)  SYMBOL(MAXATOM)       
-      CHARACTER(LEN=10) ELEMENT(MAXATOM), LEVEL(NDIM)
-      
-      DIMENSION KODAT(MAXATOM),ATMASS(MAXATOM),STAGE(MAXATOM)
-      DIMENSION NFIRST(MAXATOM),NLAST(MAXATOM)
-      DIMENSION NCHARG(NDIM),EION(NDIM),NOM(NDIM)
-      DIMENSION ELEVEL(NDIM),WEIGHT(NDIM), EINST(NDIM,NDIM)
-      DIMENSION KONTNUP(MAXKONT),KONTLOW(MAXKONT)
+      CHARACTER(LEN=2), DIMENSION(MAXATOM) :: SYMBOL
+      CHARACTER(LEN=10), DIMENSION(MAXATOM) :: ELEMENT
+      CHARACTER(LEN=10), DIMENSION(NDIM) :: LEVEL
+      
+      INTEGER, DIMENSION(MAXATOM) :: KODAT, NFIRST, NLAST
+      REAL, DIMENSION(MAXATOM) :: ATMASS, STAGE
+      INTEGER, DIMENSION(NDIM) :: NCHARG, NOM
+      REAL, DIMENSION(NDIM) :: EION, ELEVEL, WEIGHT
+      REAL, DIMENSION(NDIM,NDIM) :: EINST
+      INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW
 
 C***  The following arrays are ONLY used in STEAL, WRSTART 
 C***  -> not necessary to define these arrays and MAXIND in other calls 
-      DIMENSION INDNUP(MAXIND),INDLOW(MAXIND)
-      CHARACTER(LEN=4)  KEYCBB(MAXIND)
+      INTEGER, DIMENSION(MAXIND) :: INDNUP, INDLOW
+      CHARACTER(LEN=4), DIMENSION(MAXIND) :: KEYCBB
 
 C***  IRON-SPECIFIC ARRAYS; MAXFEIND = MAX. NUMBER OF IRON SUPERLINES
-      DIMENSION INDRB(MAXFEIND), INDRF(MAXFEIND) 
-      DIMENSION IFENUP(MAXFEIND), IFELOW(MAXFEIND)
-      DIMENSION IFRBSTA(MAXFEIND), IFRBEND(MAXFEIND), SIGMAINT(MAXFEIND)
-      DIMENSION SIGMAFE(INDEXMAX) 
-      DIMENSION FEDUMMY(NFEREADMAX) 
-
-C***  C in cm/s
-      DATA CLIGHT /2.99792458E10/
-C***  PI8 = 8*PI
-      DATA PI8 /25.1327412288/
-C***  PI*e^2/m/c in CGS units
-      DATA FSIG /2.6540E-2/
+      INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFENUP, IFELOW,
+     >                                IFRBSTA, IFRBEND
+      REAL, DIMENSION(MAXFEIND) :: SIGMAINT
+      REAL, DIMENSION(INDEXMAX) :: SIGMAFE
+      REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
+      
+      REAL :: SIGMAUL, SIGMALU, SIGMAINTCUR,
+     >        WLOW, XF, XFOLD, DSIGMA, XLAM, XLOGSTEP, DXFE, 
+     >        XLAM0FE, VDOPFE, XBAK, WNUP, XLAMCMIND
+      INTEGER :: INDEX, INDEXS, LOWION, NUPION, I, J, K, NION,
+     >           NDATA, LEVCOUNT, ILAM, NUP, LOW, INDSTA,
+     >           INDEND, INDSELF, IND, IFREQRBSTA, IFREQRBEND,
+     >           NOLD, KONT, IADR, MAXADR, IERR, NTEST, IBAK,
+     >           NREADIN, IERRLEVNAM, KZEROS, KZEROE
+      
+      LOGICAL :: bFEINFO, bFEULSEP, bINTRA
+
+C***  Constants:
+      REAL, PARAMETER :: CLIGHT = 2.99792458E10   !C in cm/s
+      REAL, PARAMETER :: PI8 = 25.1327412288      !PI8 = 8*PI
+      REAL, PARAMETER :: FSIG = 2.6540E-2         !PI*e^2/m/c in CGS units
+      
 C***  Roman Numbers for Level names
-      DATA ROMNUM / 'I...', 'II..', 'III.', 'IV..', 'V...', 
-     >              'VI..', 'VII.', 'VIII', 'IX..', 'X...',
-     >              'XI..', 'XII.', 'XIII', 'XIV.', 'XV..',
-     >              'XVI.', 'XVII', 'XIIX', 'XIX.', 'XX..', 
-     >              'XXI.', 'XXII', '23..', 'XXIV', 'XXV.' /
+      DATA ROMNUM / 'I....', 'II...', 'III..', 'IV...', 'V....', 
+     >              'VI...', 'VII..', 'VIII.', 'IX...', 'X....',
+     >              'XI...', 'XII..', 'XIII.', 'XIV..', 'XV...',
+     >              'XVI..', 'XVII.', 'XVIII', 'XIX..', 'XX...',
+     >              'XXI..', 'XXII.', 'XXIII', 'XXIV.', 'XXV..',
+     >              'XXVI.', 'XXVII' /
 
       CALL OPENMS(21,IADR,MAXADR,1,IERR)
 
@@ -89,6 +113,7 @@
       CALL READMS (21, NION,    1,      'NION    ', IERR)
       IF (NION .GT. NIONMAX .OR. IONTOP .GT. NIONMAX) THEN
          WRITE (0,'(A)') '*** Local dimension NIONMAX insufficient !' 
+         WRITE (0,*) NION, IONTOP, NIONMAX
          STOP            '*** ERROR STOP IN FEDAT *********'
       ENDIF
 
@@ -109,6 +134,7 @@
       IND      = 0
       KONT     = LASTKON
 
+
 C *** READ NUMBER OF SUPERLEVELS PER IONIZATION STAGE
         CALL READMS (21, NB, NION, 'NLEV    ', IERR)
 
@@ -139,6 +165,8 @@
         IF (N+NB(I) .GT. NDIM) THEN
            WRITE (0,'(A)') '*** Dimension NDIM insufficient !' 
            WRITE (0,'(A,I4)') '*** Present value NDIM = ', NDIM
+           WRITE (0,'(A,I4)') '*** Required value = ', N+NB(I)
+           WRITE (0,*)  I, N, NB(I)
            STOP            '*** ERROR STOP IN FEDAT *********'
         ENDIF
 
@@ -180,6 +208,7 @@
            WEIGHT(LEVCOUNT+1) = 1.
         ENDIF
 
+        
 C***  CREATE SUPERLEVEL NAMES, READ CHARGES AND IONIZATION ENERGIES      
         DO J=1,NB(I)
           N = LEVCOUNT+J
@@ -199,11 +228,12 @@
 C***        level names are already prepared in the FEDAT file
             LEVEL(N) = SYMBOL(NATOM) // LEVNAMES(J)
           ELSE
+C***        use default level names if no predefined names are available
             IF (NCHARG(N)+1 .GT. NROMMAX) THEN
-              WRITE (0,'(A)') '*** Roman Number for Ion. stage not known' 
+            WRITE(0,'(A)') '*** Roman Number for Ion. stage not known' 
               STOP            '*** ERROR STOP IN FEDAT *********'
             ENDIF
-            LEVEL(N) = SYMBOL(NATOM) // ' ' // ROMNUM(NCHARG(N)+1) // '.'
+            LEVEL(N)=SYMBOL(NATOM) // ' ' // ROMNUM(NCHARG(N)+1) // '.'
             WRITE (LEVEL(N)(9:10),'(I2)') J
             IF (J .LE. 9) LEVEL(N)(9:9) = '.'
           ENDIF 
@@ -214,6 +244,9 @@
           NLAST(NATOM) = N
         ENDIF
                 
+        NAME = 'A' // IONNAME(I)(2:4) // 'NAM ' 
+        CALL READMS (21, NAMARRAY, 2*NTRA(I), NAME, IERR)
+                
 C**********************************************************************
 C***    STORE RBB TRANSITION-DATA IN ONE-DIMENSIONAL ARRAY >>SIGMAFE<<
 C***    LOOP OVER ALL BOUND-BOUND TRANSITIONS
@@ -223,11 +256,11 @@
           IF ((I .GE. IONTOP).OR.(I .LE. IONLOW)) GOTO 20
 
 C***      READ LEVEL NUMBERS ASSOCIATED WITH TRANSITION          
-          NAME = 'A' // IONNAME(I)(2:4) // 'NAM ' 
-          CALL READMS (21, NAMARRAY, 2*NTRA(I), NAME, IERR)
-          READ (NAMARRAY(1,J)(3:4),'(I2)') LOWION 
+          CIONBUFFER = NAMARRAY(J)(3:4)
+          READ (UNIT=CIONBUFFER,FMT='(I2)') LOWION 
+          CIONBUFFER = NAMARRAY(J)(6:7)
+          READ (UNIT=CIONBUFFER,FMT='(I2)') NUPION
           LOW=LOWION+LEVCOUNT
-          READ (NAMARRAY(1,J)(6:7),'(I2)') NUPION
           NUP=NUPION+LEVCOUNT
 
 C***      OMIT TRANSITION IF LOW=NUP
@@ -241,17 +274,17 @@
           ENDIF     
 
 C***      CREATE POINTER TO STARTING INDEX OF RBB TRANSITION-DATA         
-          INDRB(IND) = INDEX+1
+          INDSTA = INDEX+1
           NDATA = NX_A(J)
           IF (NDATA+2 .GT. NFEREADMAX) THEN
-              WRITE (0,'(A)') '*** Dim. NFEREADMAX insufficient for b-b!' 
+            WRITE(0,'(A)') '*** Dim. NFEREADMAX insufficient for b-b!' 
               WRITE (0,'(A, I10)') 
      >          '*** dimensioned: NFEREADMAX = ', NFEREADMAX
               WRITE (0,'(A, I10)') 
      >          '*** required   : NFEREADMAX = ', NDATA+2
               STOP            '*** ERROR STOP IN FEDAT *********'
           ENDIF
-          INDEND = INDRB(IND)+NDATA
+          INDEND = INDSTA+NDATA
           IF (INDEND .GE. INDEXMAX) THEN 
               WRITE (0,'(A)') '*** Dimension INDEXMAX insufficient !' 
               WRITE (0,'(A, I10)') 
@@ -271,27 +304,46 @@
           CALL READMS (21, FEDUMMY, NDATA+2, NAME, IERR)
 
 C ***   STORE FREQUENCY INDICES
-          IFRBSTA(IND) = - INT(FEDUMMY(2))
-          IFRBEND(IND) = - INT(FEDUMMY(1))
+          IFREQRBSTA = - INT(FEDUMMY(2))
+          IFREQRBEND = - INT(FEDUMMY(1))
 
 C ***   STORE CROSS-SECTIONS IN ARRAY >>SIGMAFE<<          
           XLOGSTEP = ALOG10(1. + VDOPFE*1.E5*DXFE/CLIGHT)
-          SIGMAINT(IND) = 0.
-          WLOW = WEIGHT(LOW)
-          WNUP = WEIGHT(NUP)
-          XLAMCMIND = 1./(ELEVEL(NUP) - ELEVEL(LOW))
+          SIGMAINTCUR = 0.
+          KZEROS = 0
+          KZEROE = 0
           DO K=1,NDATA
 C***        Calculation of Lambda and Nu in cgs
-             ILAM = IFRBSTA(IND) + K - 1
+             ILAM = IFREQRBSTA + K - 1
              XLAM = XLAM0FE*1.E-8 * 10.**(ILAM*XLOGSTEP)
              XF   = CLIGHT / XLAM
 C ***       CROSS-SECTION
              SIGMAFE(INDEX+K) = FEDUMMY(NDATA-K+3)
+C***           Determine zero cross section regions at start and end
+               IF (SIGMAFE(INDEX+K) <= 0.) THEN
+                 IF (KZEROS >= 0) KZEROS = KZEROS + 1
+                 KZEROE = KZEROE + 1
+               ELSE 
+C***             Non-zero cross section found:
+                 IF (K == 1) THEN
+C***               The first entry in the array is already non-zero.
+C***               Therefore stop all further increasements of KZEROS by
+C***               setting the counter to a negative value:
+                   KZEROS = -1
+                 ELSEIF (KZEROS > 0) THEN
+C***               To stop further increasing of KZEROS after the first time
+C***               this has occured, multiply the result with -1.
+                   KZEROS = -1. * KZEROS
+                 ENDIF
+C***             Reset KZEROE since the formet part with zero cross-section
+C***             was definately not at the end of the cross section array.
+                 KZEROE = 0
+               ENDIF
 
 C ***       INTEGRATION OF EINSTEIN-COEFFICIENT AND NORM FOR SIGMA
              IF (K .GT. 1) THEN
                 DSIGMA = (SIGMAFE(INDEX+K)+SIGMAFE(INDEX+K-1))/2.
-                SIGMAINT(IND) = SIGMAINT(IND) + DSIGMA * (XFOLD - XF)
+                 SIGMAINTCUR = SIGMAINTCUR + DSIGMA * (XFOLD - XF)
 ccc the following statement is deactivated in libcr_cl version 16-Feb-1999
 C***           NU^2 - Term is now accounted for
 ccc             XNU = XLAMCMIND/XLAM
@@ -307,18 +359,53 @@
 ccc             XNUOLD= XNU
           ENDDO
 
-          EINST(NUP,LOW) = SIGMAINT(IND) * 
+
+C***      Band-Band transition 
+          INDRB(IND) = INDSTA
+            
+          IFRBSTA(IND) = IFREQRBSTA
+          IFRBEND(IND) = IFREQRBEND
+C***      Remove empty cross sections regions from pointer range
+C***      (leaves only at maximum one zero entry at beginning and end)
+!             IF (ABS(KZEROS) > 0.) THEN
+!               DO K=1, ABS(KZEROS)-1
+!                 IF (SIGMAFE(INDEX+K) > 0.) STOP 'FATAL: KREDUCINGS FAILED!'
+!               ENDDO
+! c              WRITE (0,*) 'STA: ', IFREQRBSTA, KZEROS
+!               IFRBSTA(IND) = IFREQRBSTA + ABS(KZEROS) - 1
+!               INDRB(IND) = INDSTA + ABS(KZEROS) - 1
+!             ENDIF
+!             IF (ABS(KZEROE) > 0.) THEN
+!               DO K=NDATA, NDATA-ABS(KZEROE)+1, -1
+!                 IF (SIGMAFE(INDEX+K) > 0.) STOP 'FATAL: KREDUCINGE FAILED!'
+!               ENDDO
+! c              WRITE (0,*) 'END: ', IFREQRBEND, KZEROE
+!               IFRBEND(IND) = IFREQRBEND - ABS(KZEROE) + 1
+!             ENDIF
+            
+            
+          SIGMAINT(IND) = SIGMAINTCUR                  
+                    
+          XLAMCMIND = 1./(ELEVEL(NUP) - ELEVEL(LOW))
+          WLOW = WEIGHT(LOW)
+          WNUP = WEIGHT(NUP)
+
+          EINST(NUP,LOW) = SIGMAINTCUR * 
      >                     PI8*WLOW/WNUP/(XLAMCMIND*XLAMCMIND)
 
-          INDEX = INDEND
 
+C***      enhance index for next cross section reading     
+          INDEX = INDEND
 
  20    CONTINUE
+ 
  21    CONTINUE
 
 C **********************************************************************
 C *** STORE RBF TRANSITION-DATA IN ARRAY >>EINST<< 
 C *** LOOP OVER ALL BOUND-FREE TRANSITIONS
+        NAME = 'B' // IONNAME(I)(2:4) // 'NAM'
+        CALL READMS (21, NAMARRAY, 2*NTRB(I), NAME, IERR)
 
         DO 30 J=1, NTRB(I)
 
@@ -326,9 +413,7 @@
           IF (I .EQ. IONTOP) GOTO 30
 
 C ***   READ LEVEL NUMBERS ASSOCIATED WITH TRANSITION          
-          NAME = 'B' // IONNAME(I)(2:4) // 'NAM'
-          CALL READMS (21, NAMARRAY, 2*NTRB(I), NAME, IERR)
-          READ (NAMARRAY(1,J)(6:7),'(I2)') LOWION
+          READ (NAMARRAY(J)(6:7),'(I2)') LOWION
           LOW = LOWION + LEVCOUNT
           NUP = LEVCOUNT + NB(I) + 1
 
diff -bur ./fgrid.f ../../powr-refactor/src/fgrid.f
--- ./fgrid.f	2024-07-28 13:13:23.000000000 +0200
+++ ../../powr-refactor/src/fgrid.f	2023-09-27 10:14:15.105755485 +0200
@@ -1,8 +1,9 @@
       SUBROUTINE FGRID (NFDIM, NF, XLAMBDA, FWEIGHT, KEY, NOM, SYMBOL, 
      $                  N, NCHARG, ELEVEL, EION, EINST, NDIM,
-     $                  EDGEK, KODAT, MAXATOM,
+     $                  EDGEK, KODAT, MAXATOM, MAXION,
      $                  INDNUP, INDLOW, LASTIND, KONTNUP, KONTLOW, 
-     >                  LASTKON, OLDFGRID, NF2, XLAMBDA2, VDOP, XLAMBLUE)
+     >                  LASTKON, OLDFGRID, NF2, XLAMBDA2, 
+     >                  VDOP, XLAMBLUE)
  
 C***********************************************************************
 C***  GENERATION OF THE FREQUENCY GRID AND INTEGRATION WEIGHTS
@@ -11,12 +12,14 @@
 C***  XLAMBDA = CORRESPONDING WAVELENGTH POINTS IN ANGSTROEMS
 C***********************************************************************
  
+C***  ATTENTION: The following common block is not complete 
+C                since only VFINAL is used in this routine
       COMMON/VELPAR/ VFINAL,VMIN,BETA,VPAR1,VPAR2,RCON,HSCALE
 
       REAL, DIMENSION(NDIM,NDIM) :: EINST
       REAL, DIMENSION(NFDIM) :: XLAMBDA, XLAMBDA2, FWEIGHT
       REAL, DIMENSION(N) :: ELEVEL, EION
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: EDGEK
       INTEGER, DIMENSION(N) :: NCHARG, NOM
       INTEGER, DIMENSION(LASTIND) :: INDNUP, INDLOW
       INTEGER, DIMENSION(LASTKON) :: KONTNUP, KONTLOW
@@ -26,6 +29,10 @@
       CHARACTER(8) :: NAME, NEDGE, CKEY
       CHARACTER(8), DIMENSION(NFDIM) :: KEY
       CHARACTER(100) :: CFORMAT, MODOLD
+      REAL, INTENT(IN) :: XLAMBLUE
+      
+      REAL :: WINGpos, WINGneg
+      INTEGER :: KOMIT, KLASTK
  
 C***  Constants
       REAL, PARAMETER :: STEBOL = 1.8046E-5     !STEFAN-BOLTZMANN CONSTANT / PI  (ERG/CM**2/S/STERAD/KELVIN**4)
diff -bur ./flag_zerorates.f ../../powr-refactor/src/flag_zerorates.f
--- ./flag_zerorates.f	2024-07-28 13:13:25.000000000 +0200
+++ ../../powr-refactor/src/flag_zerorates.f	2023-09-27 10:14:15.105755485 +0200
@@ -1,4 +1,4 @@
-      SUBROUTINE FLAG_ZERORATES(NFIRNA, NLANA, RATCO, NRANK, 
+      SUBROUTINE FLAG_ZERORATES(NFIRNA, NLANA, RATCO, N, NRANK, 
      >                          IMAXPOP, EN, POPMIN, ZERO_RATES)
 C******************************************************************
 C***  Check if all Rate Coefficients in one column are non-zero
@@ -6,16 +6,24 @@
 C***  and store logical flag ZERO_RATES for later use
 C***  Note: This subroutine is called once per each element
 C***  Called from:
-C***  STEAL -  LINPOP - COMA 
-***   STEAL -  POPZERO - NLTEPOP 
+C***  STEALCL -  LINPOP - COMA - FLAG_ZERORATES
+***   STEALCL -  NLTEPOP - FLAG_ZERORATES
 C******************************************************************
+      IMPLICIT NONE
 
-      DIMENSION RATCO(NRANK,NRANK), EN(NRANK)
-      LOGICAL ZERO_RATES(2)
+      INTEGER, INTENT(IN) :: N, NRANK,
+     >                       NFIRNA, NLANA, IMAXPOP
+      REAL, INTENT(IN) :: POPMIN
 
-C***  Threshold value with hysteresis: 
-C***    only if the estimated popnumber is lower, the level can be flagged
-ccc      POPLIMIT = 0.01 * POPMIN ! version before  4-Mar-2015
+      REAL, DIMENSION(NRANK,NRANK) :: RATCO
+      REAL, DIMENSION(NRANK) :: EN
+      LOGICAL, DIMENSION(N) :: ZERO_RATES
+      CHARACTER(10), DIMENSION(N) :: LEVEL
+      
+      REAL :: TEXC, POPLIMIT, GAINS, ENJ
+      INTEGER :: I, J
+
+C***  Threshold value: if estimated popnumber is lower, the level is flagged
       POPLIMIT = MAX(1.E-20 * POPMIN, 1.E-45)
 
 C***  check colum J
@@ -27,15 +35,8 @@
 C***  For this criterion, the loop over levels must run backwards:
       DO J = NLANA, NFIRNA, -1
 
-C***     Never flag the IMAXPOP level!
-C***     Never flag a level which was strongly populated last iteration
-           IF (J .EQ. IMAXPOP .OR. EN(J) .GT. 1000*POPMIN) THEN
-              ZERO_RATES(J) = .FALSE.
-              CYCLE
-           ENDIF
-
 C***     Flag if diagonal element too small, else divison below will fail!
-         IF (EN(J) .LT. POPMIN .AND. ABS(RATCO(J,J)) .LT. 1.E-200) THEN
+         IF (ABS(RATCO(J,J)) .LT. 1.E-200) THEN
             ZERO_RATES(J) = .TRUE.
             CYCLE
          ENDIF
@@ -44,8 +45,9 @@
          GAINS = .0
          DO I = NFIRNA, NLANA
             IF (I .EQ. J) CYCLE
-            IF (EN(I) .GT. 1.1*POPMIN) 
-     >         GAINS = GAINS + EN(I) * RATCO(I,J)
+            IF (EN(I) > 1.1 * POPMIN) THEN
+              GAINS = GAINS + EN(I) * RATCO(I,J)
+            ENDIF
          ENDDO
 
 C***     expected popnumber of level J
@@ -58,12 +60,19 @@
          ZERO_RATES(J) = ENJ .LT. POPLIMIT
      >       .OR. (EN(J) .LE. 1.1*POPMIN .AND. ENJ .LE. 100.*POPLIMIT)
 
-ccc version before  4-Mar-2015
-ccc     >          .OR. (EN(J) .LE. 1.1*POPMIN .AND. ENJ .LE. 1.1*POPMIN)
+C***     Never flag the IMAXPOP level!
+C***     Never flag a level which was strongly populated last iteration
+           IF (J == IMAXPOP .OR. EN(J) > 1000*POPMIN) THEN
+              ZERO_RATES(J) = .FALSE.
+              CYCLE
+           ENDIF
 
 C***     This version: Only the highest levels can be flagged
          IF (J .EQ. NLANA) CYCLE
-         IF (.NOT. ZERO_RATES(J+1) ) ZERO_RATES(J)=.FALSE. 
+         
+        IF (.NOT. ZERO_RATES(J+1) ) THEN
+          ZERO_RATES(J)=.FALSE. 
+        ENDIF
 
       ENDDO
 
Only in ../../powr-refactor/src/: formal.exe
Only in ../../powr-refactor/src/: formal.exe.opt
diff -bur ./formal.f ../../powr-refactor/src/formal.f
--- ./formal.f	2024-07-28 13:13:26.000000000 +0200
+++ ../../powr-refactor/src/formal.f	2023-09-27 10:14:15.105755485 +0200
@@ -6,18 +6,19 @@
 C*******************************************************************************
 
       IMPLICIT NONE
-      character onechar*1
+      CHARACTER(1) :: onechar
+ 
+C***  DEFINE ARRAY DIMENSIONS
 
 C***  IRON: ADD GENERIC ION TO MAXATOM
       INTEGER, PARAMETER :: MAXATOM =          26 
 
       INTEGER, PARAMETER :: MAXLAP  =           15000
-      INTEGER, PARAMETER :: MAXNSUBLINE  =     15000
-      INTEGER, PARAMETER :: MAXNSUBLEVEL =      5000
-      INTEGER, PARAMETER :: MAXIND  = 45000 + MAXNSUBLINE
+      INTEGER, PARAMETER :: MAXSUBL =           15000
+      INTEGER, PARAMETER :: MAXIND  = 45000 + MAXSUBL
       INTEGER, PARAMETER :: MAXFEIND  =       1500 
-C***  NDIM = Number-of-original-levels + MAXNSUBLevel 
-      INTEGER, PARAMETER :: NDIM    =  2560 + MAXNSUBLEVEL
+C***  NDIM = Number-of-original-levels + MAXSUBLevels (without 2*)
+      INTEGER, PARAMETER :: NDIM    =  1560 + MAXSUBL
       INTEGER, PARAMETER :: NFLDIM  =          300000   
       INTEGER, PARAMETER :: NFODIM  =          250000   
       INTEGER, PARAMETER :: MAXMOD  =               2
@@ -37,8 +38,8 @@
       
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5    !vd20
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5    !vd20
 C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5    !xxl
       
 C***  ARRAYS FOR TREATMENT OF LINE OVERLAPS:
@@ -50,7 +51,7 @@
       REAL, DIMENSION(MAXLAP,NDDIM,MAXMOD) :: AVOIGT, GRIEMPAR
 
 C***  ARRAYS FOR MULTIPLET HANDLING:
-      INTEGER, DIMENSION(MAXNSUBLINE) :: NSUBLOW, NSUBNUP
+      INTEGER, DIMENSION(MAXSUBL) :: NSUBLOW, NSUBNUP
 
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
       INTEGER, PARAMETER :: MAXAUTO = 2850
@@ -80,7 +81,7 @@
       REAL, DIMENSION(NDDIM) :: RADIUS_MERGED 
       REAL, DIMENSION(NDDIM,MAXMOD) :: VDU_ORIG, 
      >               T_ORIG, RNE_ORIG, ENTOT_ORIG
-      REAL, DIMENSION(MAXMOD) :: RCON, XMDOT
+      REAL, DIMENSION(MAXMOD) :: RCON, XMDOT, POPMIN
       REAL, DIMENSION(MAXATOM,MAXMOD) :: ABXYZ
       REAL, DIMENSION(NDDIM,NFDIM,MAXMOD) :: XJC
       REAL, DIMENSION(NDDIM,NPDIM) :: U, UK
@@ -107,8 +108,7 @@
       REAL, DIMENSION(NDDIM,NPDIM,MAXMOD) :: ZGRID, ZGRID_ORIG
       REAL, DIMENSION(NDDIM,NPDIM) :: ZGRID_MERGED
 
-      REAL, DIMENSION(NDDIM,NDIM,MAXMOD) :: POPNUM, POPNUM_ORIG, 
-     >                                       POPLTE
+      REAL, DIMENSION(NDDIM,NDIM,MAXMOD) :: POPNUM, POPNUM_ORIG
       REAL, DIMENSION(MAXKONT) :: ALPHA, SEXPO, 
      >                            ADDCON1, ADDCON2, ADDCON3
       INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW 
@@ -132,7 +132,7 @@
 
 C***  X-RAY DATA
       REAL, DIMENSION(MAXXDAT) :: XDATA
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
 
 C***  Density Contrast
       REAL, DIMENSION(NDDIM,MAXMOD) :: DENSCON, FILLFAC 
@@ -191,6 +191,7 @@
 C***  VARIABLES READ BY FORMOSA
       INTEGER, DIMENSION(MAXMOD) :: ND, NP, NF, JOBNUM
       REAL,    DIMENSION(MAXMOD) :: RSTAR, VDOP_MODEL, TEFF
+      REAL, DIMENSION(NDDIM, MAXMOD) :: VMIC_MODEL
 
 C***  FOR depth-dependent VDOP:
       REAL :: VMICFRAC_DEFAULT, VDOP, VDOP_FIRSTMOD
@@ -220,7 +221,7 @@
       REAL BCOREL, DBDRL
 
 C***  Intersection points with secondmodel domain
-      REAL, DIMENSION(4, NPDIM, NPHIMAX) :: ZINTER
+      REAL, DIMENSION(2, NPDIM, NPHIMAX) :: ZINTER
 
 C***  To Store Feautrier Matrices ST(94*95,89)
       REAL, DIMENSION((NPDIM+1)*NPDIM,NDDIM) :: ST
@@ -257,8 +258,7 @@
      >        FREMAX, FREMIN, DUMMY, XCMFRED, XCMFBLUE, DXCMF, FNUEC,
      >        XLAMREF, DXOBS, FINCRI, BEGLAM, XOBS0, XO, PJPJ, 
      >        PWEIGHT, XLAM2, DISMO, FACLOG, FAC, CEMINT, EMINT, 
-     >        POPMIN, ATMEAN, XMUL, AMACHL, TAUMINBROAD, PI4, STEBOL,
-     >        XLUM1, XLUM2, XLOGL_COMBINED, THETA, WMOD1, WMOD2, XLSUN
+     >        ATMEAN, XMUL, AMACHL, TAUMINBROAD
       INTEGER LSOPA, LSDWL, LSPRO, IFIRST, IERR, IDUMMY,
      >        LPHISTA, LPHIEND, IMOD, JPFIRST, JPLAST, KANAL1, LINE,
      >        LASTIND, LASTFE, KWORDS, K,
@@ -297,11 +297,6 @@
 C***  X-UNITS OF PLOT IN ANGSTROEM (ALTERNATIVELY: MICROMETER)
       DATA XUNIT / 'ANGSTROEM ' /
 
-C***  STEBOL = STEFAN-BOLTZMANN CONSTANT (CGS-UNITS)
-      DATA STEBOL / 5.6705E-5 /
-      DATA PI4 / 12.56637062 /
-      DATA XLSUN / 3.85E33 /  !Solar Luminosity [erg/s]
-
 C***  Link data to identify program version
       CHARACTER(30) :: LINK_DATE
       CHARACTER(10) :: LINK_USER
@@ -322,6 +317,7 @@
       CALL INSTALL
 ccc not in gfortran      CALL TIME(TIM1)
 
+C***  XN = NUMBER OF INTEGRATION INTERVALS ACROSS THE SCATTERING ZONE (REAL)
 C***  TAUMAX = MAXIMUM OPTICAL DEPTH WHERE INTEGRATION IS TRUNCATED
 C***  XMAX   = COMOVING-FRAME BANDWIDTH OF THE SCATTERING ZONE
 C***  DXMAX  = MAXIMUM CMF FREQUENCY STEP IN THE SCATTERING ZONE
@@ -402,12 +398,14 @@
      >          ENTOT(1,IMOD), RNE(1,IMOD), ABXYZ(1,IMOD), NATOM, 
      >          T(1,IMOD), VELO(1,IMOD), NF(IMOD),
      >          XLAMBDA(1,IMOD), GRADI(1,IMOD),
-     >          POPNUM_ORIG(1,1,IMOD), RSTAR(IMOD), VDOP_MODEL(IMOD), 
+     >          POPNUM_ORIG(1,1,IMOD), 
+     >          RSTAR(IMOD), VDOP_MODEL(IMOD), VMIC_MODEL(1,IMOD),
      >          JOBNUM(IMOD), N, NDDIM, NPDIM, NFDIM, 
      >          MODHEAD(IMOD), TEFF(IMOD),
      >          MAXXDAT, XDATA, XJC(1,1,IMOD), IMOD, 
      >          DENSCON(1,IMOD), FILLFAC(1,IMOD), TAURCONT(1,IMOD),
-     >          ZERO_RATES(1,1,IMOD), RCON(IMOD), NDIM, XMDOT(IMOD) )
+     >          POPMIN(IMOD), ZERO_RATES(1,1,IMOD), RCON(IMOD), NDIM, 
+     >          XMDOT(IMOD) )
 
       VMAX = VELO(1,1)
       RMAX = RADIUS(1,1)
@@ -420,7 +418,7 @@
       ENDDO
 
       CALL POPMIN_NULLING (ZERO_RATES(1,1,IMOD), POPNUM(1,1,IMOD), 
-     >                     ND(IMOD), N)
+     >                     POPMIN(IMOD), ND(IMOD), N)
 
 C***  The no. of core-intersecting impact parameters might be modified 
 C***  in subr. ROTATION_PREP; 
@@ -552,7 +550,7 @@
 C***  VDOP_STRUCT must be REPEATED FOR THE SECOND MODE (different T)
       IMOD = 1
       CALL VDOP_STRUCT (BDD_VDOP, DD_VDOP_LINE, 
-     >   DD_VDOP(1,1,IMOD), VDOP, VELO(1,IMOD), 
+     >   DD_VDOP(1,1,IMOD), VDOP, VMIC_MODEL(1,IMOD), VELO(1,IMOD), 
      >   T(1,IMOD), ND(IMOD), NDDIM, NATOM, MAXATOM,  
      >   DD_VDOPDU(1,1,IMOD), 
      >   VMICFRAC_DEFAULT, ATMASS, XMAX, XMAXMIN,
@@ -598,12 +596,14 @@
      >          ENTOT(1,IMOD), RNE(1,IMOD), ABXYZ(1,IMOD), NATOM, 
      >          T(1,IMOD), VELO(1,IMOD), NF(IMOD),
      >          XLAMBDA(1,IMOD), GRADI(1,IMOD),
-     >          POPNUM_ORIG(1,1,IMOD), RSTAR(IMOD), VDOP_MODEL(IMOD), 
+     >          POPNUM_ORIG(1,1,IMOD),
+     >          RSTAR(IMOD), VDOP_MODEL(IMOD), VMIC_MODEL(1, IMOD),
      >          JOBNUM(IMOD), N, NDDIM, NPDIM, NFDIM, 
      >          MODHEAD(IMOD), TEFF(IMOD),
      >          MAXXDAT, XDATA, XJC(1,1,IMOD), IMOD,
      >          DENSCON(1,IMOD), FILLFAC(1,IMOD), TAURCONT(1,IMOD),
-     >          ZERO_RATES(1,1,IMOD), RCON(IMOD), NDIM, XMDOT(IMOD) )
+     >          POPMIN(IMOD), ZERO_RATES(1,1,IMOD), RCON(IMOD), NDIM,
+     >          XMDOT(IMOD) )
 
         VMAX = MAX (VELO(1,1),VELO(1,2))
 
@@ -613,10 +613,10 @@
         ENDDO
 
         CALL POPMIN_NULLING (ZERO_RATES(1,1,IMOD), POPNUM(1,1,IMOD), 
-     >                       ND(IMOD), N)
+     >                       POPMIN(IMOD), ND(IMOD), N)
 
 C***    Printout of Model Parameters (second model)
-        WRITE (*,'(/,2A)') 'SECOND MODEL READ FROM ', 
+        WRITE (*,'(2A)') 'SECOND MODEL READ FROM ', 
      >      SECONDMODEL_PATH(:IDX(SECONDMODEL_PATH))
         WRITE (*,'(2A)') 'MODHEAD=', MODHEAD(IMOD)
         CALL PRI_PAR (TEFF(IMOD), RSTAR(IMOD), 
@@ -626,7 +626,7 @@
 C***    This is repeated here for the SECOND MODEL (different T(r)!)
         VDOP_FIRSTMOD = VDOP
         CALL VDOP_STRUCT (BDD_VDOP, DD_VDOP_LINE, 
-     >   DD_VDOP(1,1,IMOD), VDOP, VELO(1,IMOD), 
+     >   DD_VDOP(1,1,IMOD), VDOP, VMIC_MODEL(1,IMOD), VELO(1,IMOD), 
      >   T(1,IMOD), ND(IMOD), NDDIM, NATOM, MAXATOM,  
      >   DD_VDOPDU(1,1,IMOD), 
      >   VMICFRAC_DEFAULT, ATMASS, XMAX, XMAXMIN,
@@ -685,7 +685,7 @@
      >                XLAM, NBLINE, MAXLAP, MAXIND, MAXATOM, 
      >                LEVEL, WEIGHT, EINST, NDIM, POPNUM,
      >                T, ND, NOM, NCHARG, EION, ENTOT, RNE,
-     >                MAXNSUBLEVEL, MAXNSUBLINE, NSUBLOW, NSUBNUP, BROAD, 
+     >                MAXSUBL, NSUBLOW, NSUBNUP, BROAD, 
      >                LINPRO, AVOIGT, NMOD, NDDIM, MAXMOD, DENSCON, 
      >                MAINQN, MULTIIND, 
      >                NMULTI, DD_VDOP, NATOM,
@@ -976,21 +976,7 @@
          CALL SECONDMODEL_PREP (ZINTER, NPHI, PGRID_MERGED, NP_MERGED, 
      >        NPDIM, NPHIMAX, PHIARR, PHIWEIGHT, PHI_VEC, 
      >        SECONDMODEL_LINE, 
-     >        JPFIRST, JPLAST, LPHISTA_ORIG, LPHIEND_ORIG, THETA)
-
-C***    Calculate and print combined luminosity (CONE only)
-        IF (THETA .GT. .0) THEN 
-           XLUM1 = PI4 * STEBOL * RSTAR(1)**2 * TEFF(1)**4 / XLSUN
-           XLUM2 = PI4 * STEBOL * RSTAR(2)**2 * TEFF(2)**4 / XLSUN
-           WMOD2 = COS(THETA)
-           WMOD1 = 1. - WMOD2
-           XLOGL_COMBINED = ALOG10(WMOD1*XLUM1+WMOD2*XLUM2)
-           WRITE (6,'(A,F7.3)') 
-     >      'Combined luminosity of both models: log L =', XLOGL_COMBINED
-           WRITE (6,'(A,F7.3,A,F7.3)') 
-     >      'as weighted mean from log L1 =', ALOG10(XLUM1), 
-     >      ' and log L2 =', ALOG10(XLUM2)
-        ENDIF
+     >        JPFIRST, JPLAST, LPHISTA_ORIG, LPHIEND_ORIG)
 
 C***  Test output in case of a single ray
          IF (JPFIRST == JPLAST .AND. LPHISTA_ORIG == LPHIEND_ORIG) THEN
diff -bur ./formosa.f ../../powr-refactor/src/formosa.f
--- ./formosa.f	2024-07-28 13:13:27.000000000 +0200
+++ ../../powr-refactor/src/formosa.f	2023-09-27 10:14:15.105755485 +0200
@@ -1,8 +1,10 @@
       SUBROUTINE FORMOSA (ND, R, NP, P, Z, ENTOT, RNE, ABXYZ, NATOM, 
-     >                 T,VELO,NF,XLAMBDA,GRADI,
-     >        POPNUM, RSTAR, VDOP, JOBNUM, N, NDDIM, NPDIM, NFDIM,
-     >        MODHEAD,TEFF,MAXXDAT,XDATA, XJC, IMOD, 
-     >        DENSCON, FILLFAC, TAURCONT, ZERO_RATES, RCON, NDIM, XMDOT)
+     >                    T, VELO, NF, XLAMBDA, GRADI,
+     >                    POPNUM, RSTAR, VDOP, VMIC,
+     >                    JOBNUM, N, NDDIM, NPDIM, NFDIM,
+     >                    MODHEAD, TEFF, MAXXDAT, XDATA, XJC, IMOD, 
+     >                    DENSCON, FILLFAC, TAURCONT, POPMIN, 
+     >                    ZERO_RATES, RCON, NDIM, XMDOT)
 C***********************************************************************
 C***  CALLED FROM FORMAL, READS THE MODEL FILE
 C***********************************************************************
@@ -10,10 +12,18 @@
       DIMENSION XDATA(MAXXDAT), ABXYZ(NATOM)
       DIMENSION XJC(2),EDDI(2),xlambda(2)
       CHARACTER*8 NAME, MODHEAD*(*)
-      DIMENSION DENSCON(ND), FILLFAC(ND), TAURCONT(ND)
+      DIMENSION DENSCON(ND), FILLFAC(ND), TAURCONT(ND), VMIC(ND)
       LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES
       REAL :: RCON
 
+C***  Local arrays:      
+      INTEGER, PARAMETER :: NDMAX = 200
+      REAL, DIMENSION(NDMAX) :: VTURB
+           
+C***  File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+           
       M = IMOD - 1
 
       CALL OPENMS(3+M, IDUMMY, IDUMMY, 1, IERR)
@@ -22,6 +32,11 @@
             CALL REMARK ('TOO MANY DEPTH POINTS')
             STOP 'ERROR'
             ENDIF
+      IF (ND > NDMAX) THEN
+          WRITE (hCPR,'(A)') 'FORMOSA: FATAL ERROR ******'
+          WRITE (hCPR,'(A)') 'FORMOSA: LOCAL DIMENSION FOR VTURB INSUFFICIENT'
+          STOP 'ERROR IN FORMOSA'
+      ENDIF
       CALL READMS (3+M, R,ND,         'R       ', IERR)
       CALL READMS (3+M, NP,1,         'NP      ', IERR)
       IF (NP.GT.NPDIM) THEN
@@ -32,6 +47,7 @@
       CALL READMS (3+M, Z,ND*NP,      'Z       ', IERR)
       CALL READMS(3+M, ENTOT,ND,      'ENTOT   ', IERR)
       CALL READMS(3+M, TAURCONT,ND,   'TAURCONT', IERR)
+      CALL READMS(3+M, POPMIN,1,      'POPMIN  ', IERR)
       DENSCON(1:ND) = 0.0
       CALL READMS(3+M,DENSCON,ND, 'DENSCON ', IERR)
       IF (IERR .EQ. -10) DENSCON(1:ND) = 1.
@@ -66,6 +82,25 @@
       CALL READMS (3+M, TEFF,1,       'TEFF    ', IERR)
       CALL READMS (3+M, XMDOT,1,      'XMDOT   ', IERR)
 
+C***  Read microturbulence vector from main iteration      
+      CALL READMS (3,VMIC, ND,  'VMIC    ', IERR)
+      IF (IERR == -10) THEN
+C*      old MODEL file => only one VTURB value 
+        CALL READMS(3,VTURB(ND),1, 'VTURB   ', IERR)
+C*      very old MODEL file => neither VMIC nor VTURB        
+        IF (IERR == -10) VTURB(ND) = -99.
+        DO L=1, ND
+C*        convert VTURB values to VMIC 
+          IF (L /= ND) VTURB(L) = VTURB(ND)
+          VMIC(L) = VTURB(L) * SQRT(2.)
+        ENDDO
+      ELSE
+C*      Indicate non-existing VMIC      
+        DO L=1, ND
+          VMIC(L) = -99.
+        ENDDO
+      ENDIF
+      
 C***  Flags for the POPMIN levels
       CALL READMS (3+M,ZERO_RATES,  N*ND, 'ZERO_RAT', IERR)
 C*    Default if variable does not exist yet
diff -bur ./frequint.f ../../powr-refactor/src/frequint.f
--- ./frequint.f	2024-07-28 13:13:27.000000000 +0200
+++ ../../powr-refactor/src/frequint.f	2024-07-22 09:27:16.104033925 +0200
@@ -1,27 +1,34 @@
       SUBROUTINE FREQUINT (K, FWEIGHTL, XLAMK, XLAMKOLD,    
-     >                   XLAMBDA, 
+     >                   XLAMBDA, DXMAX, VELO, GRADI,
      >                   XJL, XJLOLD, XHL, XHLOLD, 
-     >                   OPAKOLD, NF, ND, NDDIM,
+     >                   OPAKOLD, NF, ND, NDDIM, NATOM,
      >                   KONTACT, KONTAUP, DFKONT, LIND, PWEIGHT, 
      >                   MAXLIN, INDFEACT, SIGMAACT, MAXFEACT, LASTFE,
      >                   OPAK, ETAK, OPAFEI, ETAFEI, IFENUP, IFELOW,
-     >                   DJDS, DJDO, DJDS_OLD, DJDO_OLD,
+     >                   DJDS, DJDS_OLD, DJDSraw, 
+     >                   bALOTri, DJDSU, DJDSL,
      >                   WEIGHT, N, POPNUM, XKLOLD,XNLOLD,
      >                   OPAKNOTH, ETAKNOTH, OPAKNOTHO, ETAKNOTHO,
-     >                   EDDIFO, EDDIGO, RADIUS, BCOLIRAY,
+     >                   EDDIFO, EDDIGO, EPSGO, RADIUS, BCOLIRAY,
      >                   ETANOTH, OPA, THOMSON, T, ETAKOLD,
      >                   QLFOLD, QLHOLD, OPAKHOLD,
      >                   EDDIHOUTOLD, EDDIHINOLD, XHID,
      >                   FWEIGHT, OPAO, THOMSONO,
+     >                   OPAKOLDELEM, OPACOLDELEM, ETAKOLDELEM, 
+     >                   ETACOLDELEM, OPAKOLDION, OPACOLDION, 
+     >                   ETAKOLDION, ETACOLDION, OPAFE,
 C***  Temporary vectors
-     >                   SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW, SC, SCO, 
+     >                   SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW, 
+     >                   SUMOPA, SUMOPAW, SUMETA, SUMETAW, SC, SCO, 
 C***             OUTPUT:
-     >                   XJCINT, FWTEST, XJLMEAN, XJFEMEAN,
-     >                   HTOTL, HTOTND, HTOTNDCOR,
-     >                   ARAD, ACONT, ATHOM,
-     >                   XJTOTL, XKTOTL, XNTOTL, WFELOW, WFENUP, FTCOLI,
+     >                   XJCINT, FWTEST, XJLMEAN, XJFEMEAN, XLAMAPPMEAN, HTOTL,
+     >                   HTOTMINUSND, HTOTND, HTOTNDCOR,
+     >                   HTOTNDS, ARAD, ACONT, ATHOM, ARADELEM, 
+     >                   ACONTELEM, ARADION, ACONTION,
+     >                   iIgnoreK, XJTOTL, XKTOTL, XNTOTL, 
+     >                   WFELOW, WFENUP, FTCOLI, FTCOLIB,
      >                   DSDFELOW, DSDFENUP, WJC, WJC_MIN, 
-     >                   DSDSC, DJDSC, DJDSCOLD,
+     >                   DSDSC, DJDSC, DJDSCOLD, OPAKINT, ETAKINT,
      >                   DBDTINT, DBDTOPAINT, DBDTINT_M, DBDTOPAINT_M,
 C***       Unsoeld-Lucy:
      >                   OPASMEAN, OPASMEANTC, SMEAN, QFJMEAN, OPAJMEAN,
@@ -30,11 +37,16 @@
      >                   RADIUS2, OPC, 
      >                   FERATUL, FERATLU, ELEVEL, 
      >                   EMCOLI, FTFE, IVERS_FE_EXPFAC, LPLOT_WCHARM, 
-     >                   GAMMACOLI, OPAROSS, OPALAMBDAMEAN, 
+     >                   GAMMACOLI, OPAROSS, OPAROSSCONT, OPALAMBDAMEAN, 
      >                   GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2, TEFF,
 C*** die folgenden SKALAREN Parameter werden ausgereicht, um den
 C*** Compiler-Bug seit Compaq Tru64 UNIX V5.0A (Ende 2000) zu umgehen
-     >                   XNUEK, XNUEKOLD, XNUEKOLDOLD)
+     >                   XNUEK, XNUEKOLD, XNUEKOLDOLD, VDOPUNIT,
+     >                   IFRBSTA, IFRBEND, VDOPFE, DXFE, XLAM0FE, 
+     >                   NCHARG, MAXION, POPMIN, 
+     >                   TAULAST, XHLOLDTEST, HTOTLTEST, iHTOTCUT, 
+     >                   HTOTCUT, bOSKIPLAST, XLAMLASTOSKIP, XHBFSKIP, 
+     >                   LPRDH, bDEBUG, CUTOPAMEANTHRES)
 C***  CLIGHT = SPEED OF LIGHT IN ANGSTROEM/SECOND
       DATA CLIGHT / 2.99792458E18 /
       DATA PI8 /25.1327412288 /
@@ -45,54 +57,93 @@
 
       DATA WJMAX / 0.9999999999 /
 
-      DIMENSION XLAMBDA(NF),XJL(ND),XJLOLD(ND),XHL(ND),XHLOLD(ND)
-      DIMENSION OPAKOLD(ND), ETAKOLD(ND)
-      DIMENSION XKLOLD(ND),XNLOLD(ND)
-      DIMENSION LIND(MAXLIN), PWEIGHT(MAXLIN)
-      DIMENSION INDFEACT(MAXFEACT), SIGMAACT(MAXFEACT)
-      DIMENSION RADIUS(ND), OPAKNOTHO(ND), ETAKNOTHO(ND)
-
-      DIMENSION XJCINT(ND,NF), FWTEST(NF)
-      DIMENSION HTOTL(ND), XJTOTL(ND), XKTOTL(ND), XNTOTL(ND)
-      DIMENSION ARAD(ND), ACONT(ND), ATHOM(ND)
-      DIMENSION XJFEMEAN(ND, LASTFE), XJLMEAN(NDDIM,MAXLIN)
-
-      DIMENSION OPAK(ND), ETAK(ND)
-      DIMENSION OPAKNOTH(ND), ETAKNOTH(ND)
-      DIMENSION OPAFEI(ND,LASTFE), ETAFEI(ND,LASTFE)
-      DIMENSION WFELOW(ND,LASTFE), WFENUP(ND,LASTFE)
-      DIMENSION DSDFELOW(ND,LASTFE), DSDFENUP(ND,LASTFE)
-      DIMENSION DSDETA(ND), DSDOPA(ND)
-      DIMENSION IFENUP(LASTFE), IFELOW(LASTFE)
-      DIMENSION WEIGHT(N), POPNUM(ND,N), DJDS(ND), DJDO(ND), FTCOLI(ND)
-      DIMENSION SC(ND), SCO(ND)
-
-      DIMENSION DJDS_OLD(ND), DJDO_OLD(ND)
-      DIMENSION WJC(ND,NF), DSDSC(ND), DJDSC(ND), DJDSCOLD(ND)
-      DIMENSION WJC_MIN(ND,NF)
-      DIMENSION ETANOTH(ND), OPA(ND), THOMSON(ND), T(ND)
-      DIMENSION OPAO(ND), THOMSONO(ND)      
-      DIMENSION RADIUS2(ND)
-      DIMENSION FWEIGHT(NF), EMCOLI(NF),  FTFE(ND,LASTFE)
+      REAL, PARAMETER :: PI4 = 12.5663706144    !PI4 = 4*PI
+      REAL, PARAMETER :: WPI =  1.772454        !WPI = SQRT(PI)
+      REAL, PARAMETER :: STEBOL = 5.6705E-5     !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS)
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5  !Stephan-Boltzmann constant (CGS) / Pi
+      REAL, PARAMETER :: CLIGHTKM = 2.9979E5    !CLIGHT = SPEED OF LIGHT IN KILOMETER/SECOND
+      
+      REAL, PARAMETER :: EXPMAX = 500.
+
+      INTEGER, INTENT(IN) :: ND, NDDIM, N, NF, MAXLIN, MAXFEACT, LASTFE,
+     >                       NATOM, LPRDH
+      REAL, INTENT(IN) :: TEFF
+      
+      REAL, DIMENSION(ND) :: RADIUS, RADIUS2, XJL, XJLOLD, XHL, XHLOLD,
+     >                       XKLOLD, XNLOLD, HTOTL, XJTOTL, XKTOTL, 
+     >                       XNTOTL, ARAD, ACONT, ATHOM, VELO, GRADI,
+     >                       OPAKOLD, ETAKOLD, OPAKFEOLD, OPAFE,
+     >                       OPAROSSCONT, T, OPARFLUX, OPARCFLUX,
+     >                       OPAK, ETAK, OPAKNOTH, ETAKNOTH, ETANOTH,
+     >                       OPA, THOMSON, OPAO, THOMSONO, OPAKNOTHO,
+     >                       ETAKNOTHO, DSDETA, DSDOPA, DJDS, DJDO,
+     >                       DJDS_OLD, DJDO_OLD, DSDSC, DJDSC, DJDSCOLD,
+     >                       FTCOLI, SC, SCO, TAULAST,
+     >                       OPAKNOFENOTHO, ETAKNOFENOTHO, FTCOLIB,
+     >                       OPAKFEFTOLD, ETAKFEFTOLD, OPACTOT, OPALTOT,
+     >                       XHLOLDTEST, HTOTLTEST, HTOTCUT, XHBFSKIP,
+     >                       XLAMLASTOSKIP, DJDSraw
+      INTEGER, DIMENSION(MAXLIN) :: LIND
+      REAL, DIMENSION(NDDIM, MAXLIN) :: PWEIGHT, OPAL
+      INTEGER, DIMENSION(MAXFEACT) :: INDFEACT
+      REAL, DIMENSION(MAXFEACT) :: SIGMAACT
+
+      REAL, DIMENSION(ND, NF) :: XJCINT, OPAKINT, ETAKINT, WJC, WJC_MIN
+      REAL, DIMENSION(NF) :: XLAMBDA, FWTEST, FWEIGHT, EMCOLI
+      INTEGER, DIMENSION(ND) :: iIgnoreK
+      REAL, DIMENSION(ND, LASTFE) :: XJFEMEAN
+      REAL, DIMENSION(NDDIM,MAXLIN) :: XJLMEAN, XLAMAPPMEAN,
+     >                                 XLAMAPPUMEAN, XLAMAPPLMEAN
+
+      INTEGER, DIMENSION(LASTFE) :: IFENUP, IFELOW
+      REAL, DIMENSION(ND,LASTFE) :: OPAFEI, ETAFEI, WFELOW, WFENUP,
+     >                              DSDFELOW, DSDFENUP, FTFE
+      REAL, DIMENSION(N) :: WEIGHT
+      REAL, DIMENSION(ND,N) :: POPNUM
+
+      REAL, DIMENSION(NATOM, ND) :: OPAKELEM, OPAKOLDELEM,
+     >                              OPACELEM, OPACOLDELEM,
+     >                              ETAKELEM, ETAKOLDELEM,
+     >                              ETACELEM, ETACOLDELEM,
+     >                              OPAROSSELEM, OPATOTELEM
+      REAL, DIMENSION(ND, NATOM, MAXION) :: OPAKION, OPAKOLDION,
+     >                                      OPACION, OPACOLDION,
+     >                                      ETAKION, ETAKOLDION,
+     >                                      ETACION, ETACOLDION
+      REAL, DIMENSION(NATOM, ND-1) :: ARADELEM, ACONTELEM  
+      REAL, DIMENSION(ND-1, NATOM, MAXION) :: ARADION, ACONTION
 
 C***  Unsoeld-Lucy
-      DIMENSION OPASMEAN(ND), SMEAN(ND), QFJMEAN(ND)
+      DIMENSION OPASMEAN(ND), SMEAN(ND), QFJMEAN(ND), ALAMBDAMEAN(ND)
       DIMENSION OPAJMEAN(ND), OPAPMEAN(ND)
-      DIMENSION QOPAHMEAN(ND), HMEAN(ND)
+      REAL, DIMENSION(ND) :: QOPAHMEAN, QOPAHMEANL, HMEAN
       DIMENSION OPASMEANTC(ND), OPAJMEANTC(ND) 
+      LOGICAL, DIMENSION(ND) :: bOSKIPLAST
 
       DIMENSION QLFOLD(ND), QLHOLD(ND), OPAKHOLD(ND)
-      DIMENSION EDDIFO(ND), EDDIGO(ND)
+      DIMENSION EDDIFO(ND), EDDIGO(ND), EPSGO(ND)
       LOGICAL BCOLIRAY, BNEWINTERVAL, BNEWINTERVALOLD, BEMPTY
-      DIMENSION SUMJ(ND), SUMJW(ND), SUMDJDSC(ND), SUMDJDSCW(ND)      
+      REAL, DIMENSION(ND) :: SUMJ, SUMJW, SUMDJDSC, SUMDJDSCW, 
+     >                       SUMOPA, SUMOPAW, SUMETA, SUMETAW      
       CHARACTER(LEN=8) OPC
-      DIMENSION FERATLU(LASTFE,ND), FERATUL(LASTFE,ND)
+      REAL, DIMENSION(LASTFE,ND) :: FERATLU, FERATUL
       DIMENSION ELEVEL(LASTFE)
 C***  ALI Acceleration terms
-      DIMENSION OPAROSS(ND), OPALAMBDAMEAN(ND)
+      REAL, DIMENSION(ND) :: OPAROSS, OPALAMBDAMEAN
+
+      INTEGER, INTENT(IN) :: iHTOTCUT, IVERS_FE_EXPFAC
+      LOGICAL :: BWCELAB, BCUTOFF, BCUTOFF2, bALOTri,
+     >           bIgnoreK, bOSKIP, bDEBUG, bKSKIPMEAN
+      DIMENSION IFRBSTA(LASTFE), IFRBEND(LASTFE)
+      REAL :: VDOPFE, DXFE, XLAM0FE, bInBand, TL, XHLUSE, 
+     >        HTOTMINUSND, HTOTND, HTOTNDCOR, XHI, XHID, 
+     >        EDDIHINTOLD, HTOTNDS, HCURL, AF, CF,
+     >        DELTAHNUE, VDR, DHMECH, TCUT, XHLCUT, DXMAX,
+     >        CUTOPAMEANTHRES
+
+      INTEGER, DIMENSION(N) :: NCHARG
+
 
-      LOGICAL :: BWCELAB, BCUTOFF, BCUTOFF2
-      REAL :: HTOTND, XHID, EDDIHINOLD, HTOTNDCOR
 
       SAVE 
 
@@ -116,6 +167,9 @@
       DJDS = MIN(DJDS, WJMAX)
       DJDS = MAX(DJDS, 0.)
 
+C***  store undamped DJDS       
+      DJDSraw = DJDS
+      
 C***  DJDS -> TAU
       DJDS = -LOG(1.-DJDS)
 C***  DJDS -> TAU/GAMMA
@@ -131,7 +185,32 @@
       DO NL=1, MAXLIN
         IF (LIND(NL) .EQ. 0) CYCLE
         DO L=1, ND
-           XJLMEAN(L,NL) = XJLMEAN(L,NL) + XJL(L)*PWEIGHT(NL)
+C***       Note: The factor FWEIGHTL was missing here since we divide
+C***             by the integrated PWEIGHTs afterwards and can assume
+C***             that FWEIGHTL is roughly constant over a line
+C***             This has now been add, but its effect is minor
+           XJLMEAN(L,NL) = XJLMEAN(L,NL) + XJL(L)*PWEIGHT(L,NL)*FWEIGHTL
+C***       Freq.-integrated LAMBDASTAR operator for current line NL
+C***       The ALO at the current frequency is weighted with the
+C***       contribution of the considered line opacity (excluding iron) 
+C***       (at the current freq.) over the sum of all line and true cont. contrib.
+           OPALFRAC = (OPAK(L) - OPAFE(L) - OPA(L)) /OPAKNOTH(L)
+           XLAMAPPMEAN(L,NL) = XLAMAPPMEAN(L,NL) 
+     >       + DJDS(L) * OPALFRAC * PWEIGHT(L,NL)*FWEIGHTL
+           IF (bALOTri) THEN
+             IF (L < ND) THEN
+               OPALFRAC = (OPAK(L+1) - OPAFE(L+1) - OPA(L+1)) 
+     >           /OPAKNOTH(L+1)
+               XLAMAPPUMEAN(L,NL) = XLAMAPPUMEAN(L,NL) 
+     >           + DJDSU(L) * OPALFRAC * PWEIGHT(L,NL)*FWEIGHTL
+             ENDIF
+             IF (L > 1) THEN
+               OPALFRAC = (OPAK(L-1) - OPAFE(L-1) - OPA(L-1)) 
+     >           /OPAKNOTH(L-1)
+               XLAMAPPLMEAN(L,NL) = XLAMAPPLMEAN(L,NL) 
+     >           + DJDSL(L) * OPALFRAC * PWEIGHT(L,NL)*FWEIGHTL
+             ENDIF
+           ENDIF
         ENDDO
       ENDDO
 
@@ -156,13 +235,20 @@
          NUP = IFENUP(IND)
          LOW = IFELOW(IND)
          IF (LOW .EQ. NUP) CYCLE
+
          WLU = WEIGHT(LOW)/WEIGHT(NUP)
          WAV0 = ELEVEL(NUP) - ELEVEL(LOW)
          XLAM0CM = 1. / WAV0
 
+         IF (SIGMA <= 0.) CYCLE
+         
          DO L=1, ND
-C***       INTEGRATION OF XJFEMEAN
-            XJFEMEAN(L,IND) =XJFEMEAN(L,IND) + XJL(L) * FWEIGHTL * SIGMA
+           POPNUP = POPNUM(L,NUP)
+           POPLOW = POPNUM(L,LOW)
+
+C***       Integration of XJFEMEAN (now with superlvl freq. weighting)
+           XJFEMEAN(L,IND) = XJFEMEAN(L,IND)
+     >                         + WAV0/WAVK * XJL(L) * FWEIGHTL * SIGMA
 
 C***       CORRECTION FOR ENERGY EQUATION
             FTFE(L,IND) = FTFE(L,IND)
@@ -183,30 +269,37 @@
               STOP '*** FATAL INTERNAL ERROR 1 in subr. FREQUINT'
             ENDIF
 
-C*** This version XLAMKCM --> XLAM0CM in the next 2 eqns.
+C*** wrh version XLAMKCM --> XLAM0CM in the next 2 eqns. (DRATLU, DRATUL)
             DRATLU =  
-     >          PI8/C2 * XJLPLAIN * XLAM0CM * SIGMA * FWEIGHTL 
+     >          PI8/C2 * XJLPLAIN * XLAMKCM * SIGMA * FWEIGHTL 
             DRATUL =  
      >          WLUEXP * PI8/C2 * 
-     >          (C2 * WAVK3 + XJLPLAIN) * XLAM0CM * SIGMA * FWEIGHTL
+     >          (C2 * WAVK3 + XJLPLAIN) * XLAMKCM * SIGMA * FWEIGHTL
+     
+C***        Prevent using rates where DEPARTURE coefficients are wrong due to POPMIN            
+c            IF (POPLOW < POPMIN) THEN
+c              DRATLU = 0.
+c              DRATUL = 0.
+c            ELSEIF (POPNUP < POPMIN) THEN
+C***          Do not add any contributions from levels which could be switched off
+c              DRATUL = 0.
+c            ENDIF
 
             FERATLU(IND,L) = FERATLU(IND,L) + DRATLU
             FERATUL(IND,L) = FERATUL(IND,L) + DRATUL
 
 C***       CALCULATION OF ACTUAL DERIVATIVES OF S
 
-            POPNUP = POPNUM(L,NUP)
-            POPLOW = POPNUM(L,LOW)
-
 C***       DERIV. OF ETAI
-            IF (OPAFEI(L,IND) .GT. 0. .AND. POPNUP .NE. .0) THEN
+            IF ((OPAFEI(L,IND) .GT. 0.) .AND. (POPNUP > 0.)) THEN
                DETAIDNUP = ETAFEI(L,IND) / POPNUP
             ELSE
                DETAIDNUP = 0.
             ENDIF
 
 C***       DERIV. OF OPAI
-            IF (OPAFEI(L,IND) .GT. 0. .AND. POPLOW .NE. .0) THEN
+            IF ((OPAFEI(L,IND) .GT. 0.)
+     >                 .AND. (POPLOW > 0. .OR. POPNUP > 0.)) THEN
                OPANULL  = OPAFEI(L,IND) / (POPLOW - WLUEXP*POPNUP)
             ELSE
                OPANULL = 0.
@@ -264,6 +357,10 @@
             SUMJW    (L) = .0
             SUMDJDSC (L) = .0
             SUMDJDSCW(L) = .0
+            SUMOPA   (L) = .0
+            SUMOPAW  (L) = .0
+            SUMETA   (L) = .0
+            SUMETAW  (L) = .0
          ENDDO
          SUMEMF = 0.
          SUMEMFW= 0.
@@ -324,11 +421,6 @@
          FWNUEKOLD   = (XNUELEFT + XNUEKOLD + XNUERIGHT) *
      >                 (XNUELEFT-XNUERIGHT) / 6.        
 
-C***       Test Output for the current Problems with Compaq Fortran
-C           IF ((K .GT. 60900) .AND. (K .LT. 61100)) THEN
-C              WRITE(0,*) FWNUEKOLD, XNUELEFT, XNUERIGHT, XNUEKOLD
-C           ENDIF
-
       ENDIF
 
 C***  Determine minimum of 1.-EXP(-TAU), if requested
@@ -369,6 +461,13 @@
             SUMJ (L)  = SUMJ (L) + XJLOLD(L) * FWKOLD
 C***        The same is done after multiplication with the testfunction NUE
             SUMJW(L)  = SUMJW(L) + XJLOLD(L) * FWNUEKOLD
+            !the line above can sometimes lead to a (floating invalid) COLI crash (why?)
+
+C***        Average opacity and emissivity for the coarse grid            
+            SUMOPA(L) = SUMOPA(L) + OPAKOLD(L) * FWKOLD
+            SUMOPAW(L) = SUMOPAW(L) + OPAKOLD(L) * FWNUEKOLD
+            SUMETA(L) = SUMETA(L) + ETAKOLD(L) * FWKOLD
+            SUMETAW(L) = SUMETAW(L) + ETAKOLD(L) * FWNUEKOLD
 
 C***        Old Dioagonal Weight for Continuum is saved
             DJDSCOLD(L) = DJDSC(L)
@@ -495,6 +594,14 @@
      >                          + DJDSCSPECIAL * FWSPECIAL
             ENDIF
 
+            OPASPECIAL = QSPECIAL2 * OPAKOLD(L) + QSPECIAL * OPAK(L)
+            SUMOPA (L)  = SUMOPA (L) + OPASPECIAL * FWSPECIAL
+            SUMOPAW(L)  = SUMOPAW(L) + OPASPECIAL * FWNUESPECIAL
+            
+            ETASPECIAL = QSPECIAL2 * ETAKOLD(L) + QSPECIAL * ETAK(L)
+            SUMETA (L)  = SUMETA (L) + ETASPECIAL * FWSPECIAL
+            SUMETAW(L)  = SUMETAW(L) + ETASPECIAL * FWNUESPECIAL
+            
          ENDDO
 
          XHSPECIAL = QSPECIAL2 * XHLOLD(1) + QSPECIAL * XHL(1)
@@ -514,10 +621,12 @@
 
          FW1 = 0.5 * (XNUE1 - XNUE2)         
          FW2 = FW1
-         IF (KCONT .EQ. 1) THEN 
+         IF (KCONT == 1) THEN 
             FP = 1.
             DO L=1, ND
                XJCINT(L,1) = 0.
+               OPAKINT(L,1) = 0.
+               ETAKINT(L,1) = 0.
             ENDDO 
             EMCOLI(1) = 0.
          ELSE
@@ -548,7 +657,22 @@
 C***       ******************************************************
             ENDIF
 
+            OPAKINT(L,KONT+1) = 
+     >               ( FWNUE1 * SUMOPA(L) - FW1 * SUMOPAW(L) ) / 
+     >               ( FW2 * FWNUE1 - FW1 * FWNUE2)
+            OPAKINT(L,KCONT) = FQ * OPAKINT(L,KCONT) + FP * 
+     >               ( FWNUE2 * SUMOPA(L) - FW2 * SUMOPAW(L))/ 
+     >               (FW1 * FWNUE2 - FW2 * FWNUE1)
+
+            ETAKINT(L,KONT+1) = 
+     >               ( FWNUE1 * SUMETA(L) - FW1 * SUMETAW(L) ) / 
+     >               ( FW2 * FWNUE1 - FW1 * FWNUE2)
+            ETAKINT(L,KCONT) = FQ * ETAKINT(L,KCONT) + FP * 
+     >               ( FWNUE2 * SUMETA(L) - FW2 * SUMETAW(L))/ 
+     >               (FW1 * FWNUE2 - FW2 * FWNUE1)
+     
          ENDDO
+         
          EMCOLI(KCONT+1) = 4.*
      >               ( FWNUE1 * SUMEMF - FW1 * SUMEMFW ) /
      >               ( FW2 * FWNUE1 - FW1 * FWNUE2)
@@ -611,51 +735,105 @@
 C**********************************************************************
 C***  INTEGRATE TOTAL FLUX AND RADIATIVE FORCE
 C**********************************************************************
-      IF (K .EQ. 0) THEN
+C      IF (K .EQ. 0) THEN
+      IF (K == 1) THEN
          FWMID = 0.5 * (XNUEKOLD - XNUEK)
       ELSE
          FWMID = 0.5 * (XNUEKOLDOLD - XNUEK)
       ENDIF
+      IF (FWMID < 0) THEN
+        WRITE (0,*) "K= ",K," FWMID = ", FWMID
+      ENDIF
+      DND = 0.5 * (XNUEKOLD + XNUEK) * VDOPUNIT / CLIGHTKM
+      
+cc      WRITE (0,*) 'FW(K)', K, FWEIGHTL, FWMID
+C***  TEST: Use COLI FWEIGHTL instead of FWMID
+      FWMID = FWEIGHTL
 
       DO L=1, ND
-         IF (XJLOLD(L) .GT. 1.E-15)
-     >   XJTOTL(L) = XJTOTL(L) + XJLOLD(L)*FWMID
+         IF (XJLOLD(L) .GT. 1.E-15) THEN
+            XJTOTL(L) = XJTOTL(L) + XJLOLD(L)*FWMID
+            bIgnoreK = .FALSE.
+         ELSE
+            bIgnoreK = .TRUE.
+            iIgnoreK(L) = iIgnoreK(L) + 1
+         ENDIF
          IF (BCOLIRAY) THEN
               XKTOTL(L) = XKTOTL(L) + XKLOLD(L)*FWMID
-         ELSE
+         ELSEIF (XJLOLD(L) .GT. 1.E-15) THEN
+            !TEST: use only from 1.E-15
               XKTOTL(L) = XKTOTL(L) + XJLOLD(L)*EDDIFO(L)*FWMID
          ENDIF
 
+         IF (L == 1) THEN
+           HTOTOUTMINUS = HTOTOUTMINUS 
+     >           + (EDDIHOUTOLD - EDDIHOUTOP) * XJLOLD(L) * FWMID
+         ENDIF
+         
+         
          IF (L == ND) THEN
            IF (K > 0) THEN
 C***         Calculate Eddington Flux at inner boundary 
 C***          via frequency integration of
 C***         HTOTND: H_nu,ND = H_nu,diff + B_nu/2 - h_nu,in * J_nu,ND
+C***         Also: Special H- for inner boundary, maybe from Kudritzki (1973, PhD Thesis)    
+             HTOTMINUSND = HTOTMINUSND + EDDIHINMOLD*XJLOLD(L) * FWMID
+             HTOTNDS = HTOTNDS + EDDIHINTOLD*XJLOLD(L) * FWMID
              HTOTND = HTOTND + ( XHID  + 
      >          BNUE(XLAMKOLD,T(ND))/2.- EDDIHINOLD*XJLOLD(L)) * FWMID
-C***         HTOTNDCOR: frequency integration without the diffusion term H_nu,diff
-C***              (i.e. of the terms accounting for LTE/diffusion deviations)
              HTOTNDCOR = HTOTNDCOR + 
      >         (BNUE(XLAMKOLD,T(ND))/2.- EDDIHINOLD*XJLOLD(L)) * FWMID
            ENDIF
-           
            CYCLE
          ENDIF
 
-C***    Radiation Pressure
+C***     Option HTOTCUT = tkae only positive part of XHLOLD(L)
+         IF (iHTOTCUT > 0) THEN
+           XHLUSE = MAX(XHLOLD(L), 0.)
+         ELSE
+           XHLUSE = XHLOLD(L)
+         ENDIF
+
+C***    Radiation Pressure (total and per element)
          ARAD(L) = ARAD(L)
-     >               + 0.5*(OPAKOLD(L)+OPAKOLD(L+1))*XHLOLD(L)*FWMID
+     >               + 0.5*(OPAKOLD(L)+OPAKOLD(L+1))*XHLUSE*FWMID
+
 C+C***    Contributions of the Continuum
          OPTH = 0.5 * (OPAO(L)*THOMSONO(L) + OPAO(L+1)*THOMSONO(L+1))
          OPAC = 0.5 * (OPAO(L) + OPAO(L+1))
-         ACONT(L) = ACONT(L) + OPAC*XHLOLD(L)*FWMID
-         ATHOM(L) = ATHOM(L) + OPTH*XHLOLD(L)*FWMID
+         DO NA=1, NATOM
+           ARADELEM(NA,L) = ARADELEM(NA,L) + 0.5 *
+     >        (OPAKOLDELEM(NA,L)+OPAKOLDELEM(NA,L+1))*XHLUSE*FWMID      
+           ACONTELEM(NA,L) = ACONTELEM(NA,L) + 0.5 *
+     >        (OPACOLDELEM(NA,L)+OPACOLDELEM(NA,L+1))*XHLUSE*FWMID      
+           DO ION=1, MAXION
+             OPAFULLION = 
+     >          0.5 * ( OPAKOLDION(L,NA,ION) + OPAKOLDION(L+1,NA,ION) )
+             ARADION(L,NA,ION) = ARADION(L,NA,ION) 
+     >                                + OPAFULLION * XHLUSE * FWMID
+             OPACONTION =
+     >          0.5 * ( OPACOLDION(L,NA,ION) + OPACOLDION(L+1,NA,ION) )
+             ACONTION(L,NA,ION) = ACONTION(L,NA,ION)
+     >                                + OPACONTION * XHLUSE * FWMID        
+           ENDDO
+         ENDDO
+         ACONT(L) = ACONT(L) + OPAC*XHLUSE*FWMID
+         ATHOM(L) = ATHOM(L) + OPTH*XHLUSE*FWMID
+
+         IF (iHTOTCUT <= 1) THEN
+           XHLUSE = XHLOLD(L)
+         ENDIF
 
-         HTOTL(L) = HTOTL(L) + XHLOLD(L)*FWMID
+         HTOTL(L) = HTOTL(L) + XHLUSE*FWMID
+         HTOTLTEST(L) = HTOTLTEST(L) + XHLOLDTEST(L)*FWMID
          IF (BCOLIRAY) THEN
               XNTOTL(L) = XNTOTL(L) + XNLOLD(L)*FWMID
          ELSE
-              XNTOTL(L) = XNTOTL(L) + XHLOLD(L)*EDDIGO(L)*FWMID
+C***       fixed calculation bug with eddimix: add J-contrib for eps > 0 
+C***       To date, the stored NTOT in model is not used further in the code -- ansander, Aug 2023
+              XJLUSE = 0.5 * (XJLOLD(L) + XJLOLD(L+1))
+              XNTOTL(L) = XNTOTL(L) + XHLUSE*EDDIGO(L)*FWMID
+     >                     + EDDIGO(L)*EPSGO(L)*XJLUSE*FWMID 
          ENDIF
 
       END DO
@@ -664,6 +842,12 @@
       DBDT   = DBNUEDT(XLAMKOLD, T(ND))
       DBDTINT    = DBDTINT    + DBDT*FWMID
       DBDTOPAINT = DBDTOPAINT + DBDT*FWMID/OPAKOLD(ND)
+C***  ND-1/2:
+      TMID   = 0.5 * (T(ND) + T(ND-1))
+      OPAKMID = 0.5 * (OPAKOLD(ND) + OPAKOLD(ND-1))
+      DBDT_M   = DBNUEDT(XLAMKOLD, TMID)
+      DBDTINT_M    = DBDTINT    + DBDT*FWMID
+      DBDTOPAINT_M = DBDTOPAINT + DBDT*FWMID/OPAKMID
 C- ***********************
 
 
@@ -689,46 +873,152 @@
 C***   Rosseland Opacity
        DBDT       = DBNUEDT(XLAMKOLD, T(L))
        OPAROSS(L) = OPAROSS(L) + DBDT * FWMID / OPAKOLD(L)
+       OPAROSSCONT(L) = OPAROSSCONT(L) + DBDT * FWMID / OPAO(L)
+       DO NA=1, NATOM
+         IF (OPAKOLDELEM(NA,L) /= 0.) THEN
+           OPAROSSELEM(NA, L) = OPAROSSELEM(NA, L) + DBDT * FWMID / 
+     >                                OPAKOLDELEM(NA, L)      
+         ENDIF
+         OPATOTELEM(NA,L) = OPATOTELEM(NA,L) + OPAKOLDELEM(NA,L)*FWMID
+       ENDDO
+       
+C***   simple frequency-integrated opacity       
+       OPACTOT(L) = OPACTOT(L) + OPAO(L) * FWMID
+       OPALTOT(L) = OPALTOT(L) + OPAKOLD(L) * FWMID
+
+C***   Determine current pure line opacity       
+       OPALOL = OPAKOLD(L) - OPAFE(L) - OPAO(L)
 
        IF (BCUTOFF2 .AND.
      >    OPAKNOTHO(L) * (RADIUS(L)-1.) .GT. UNLU_TAUMAX2) GOTO 45
           IF (XJLOLD(L) .LT. 1.E-50) GOTO 45
        FTCOLI(L) = FTCOLI(L)
      >  + (ETAKNOTHO(L) - OPAKNOTHO(L)*XJLOLD(L)/RADIUS2(L)) * FWMID
+       FTCOLIB(L) = FTCOLIB(L) + OPAKNOTHO(L)*
+     >  ( XJLOLD(L)/RADIUS2(L) - BNUE(XLAMKOLD,T(L)) )*FWMID
  45    continue
 
+
+C***    For temperature corrections: Cut strong lines from flux integral:
+        TCUT = MAX(TEFF, T(L))
+c        IF (XHLOLD(L) > 0.5 * XJLOLD(L)) THEN
+        IF (T(L) < TEFF) THEN
+          XHLCUT = MIN(XHLOLD(L), 0.5 * BNUE(XLAMKOLD, TCUT))
+        ELSE 
+          XHLCUT = XHLOLD(L)
+        ENDIF
+        HTOTCUT(L) = HTOTCUT(L) + XHLCUT * FWMID
+
+ 
+ 
+c       bOSKIP = (BCUTOFF .AND.
+c     >    (OPAKNOTHO(L) * (RADIUS(L)-1.) .GT. UNLU_TAUMAX))
+       bOSKIP = (BCUTOFF .AND.
+     >    (OPALOL * (RADIUS(L)-1.) .GT. UNLU_TAUMAX))
+       IF (bOSKIP) XLAMLASTOSKIP(L) = XLAMK
+ 
 C***  CUT OFF VERY LARGE OPTICAL DEPTHS ("detailed balance") 
+c       IF (BCUTOFF .AND.
+c     >    (OPAKNOTHO(L) * (RADIUS(L)-1.) .GT. UNLU_TAUMAX)) GOTO 44
        IF (BCUTOFF .AND.
-     >    (OPAKNOTHO(L) * (RADIUS(L)-1.) .GT. UNLU_TAUMAX)) GOTO 44
+     >    (OPALOL * (RADIUS(L)-1.) .GT. UNLU_TAUMAX)) GOTO 44
 C***  Special treatment for negative 'true' Opacity
 C***   (Ist dieser Fallback schlau oder eher problematisch?)
-c            => greift meist nur aussen!
-       IF (OPAKNOTHO(L) .LE. 1.E-30) THEN
+       bKSKIPMEAN = .FALSE.
+       IF (OPAKNOTHO(L) <= 1.E-30) THEN
+         bKSKIPMEAN = .TRUE.
+       ELSE
+         SMEAN(L) = SMEAN(L) + ETAKOLD(L)/OPAKOLD(L) * FWMID
+         IF (ABS(ETAKOLD(L)) > 0.) THEN
+C***       CUTOPAMEANTHRES is set via CARDS option OPAMEANTHRES
+C***        recommended values between 1.E-5 and 1.E-3
+C***        Setting too high values can lead to a crash in STEAL
+C***        due to OPASMEAN being zero at one or more depth points
+           IF (ABS(OPAKOLD(L)/ETAKOLD(L)*XJLOLD(L) - 1.)
+     >           < CUTOPAMEANTHRES) 
+     >       bKSKIPMEAN = .TRUE.             
+         ENDIF
+       ENDIF
+
+       IF (.NOT. bKSKIPMEAN) THEN
            OPAJMEAN(L) = OPAJMEAN(L) + OPAKOLD(L)*XJLOLD(L)      * FWMID
            OPASMEAN(L) = OPASMEAN(L) + ETAKOLD(L)                * FWMID
            OPAPMEAN(L) = OPAPMEAN(L) 
      >                          + OPAKOLD(L)*BNUE(XLAMKOLD,T(L)) * FWMID
-           SMEAN(L)    = SMEAN(L)    + ETAKOLD(L)/OPAKOLD(L)     * FWMID
-       ELSE
-          OPAJMEAN(L) = OPAJMEAN(L) + OPAKNOTHO(L)*XJLOLD(L)    * FWMID
-          OPASMEAN(L) = OPASMEAN(L) + ETAKNOTHO(L)              * FWMID
-          OPAPMEAN(L) = OPAPMEAN(L) 
-     >                       + OPAKNOTHO(L)*BNUE(XLAMKOLD,T(L)) * FWMID
-          SMEAN(L)    = SMEAN(L)    + ETAKNOTHO(L)/OPAKNOTHO(L) * FWMID
        ENDIF
 
+ccc OLD BRANCH:
+c       IF (bKSKIPMEAN) THEN
+c          SMEAN(L)    = SMEAN(L)    + ETAKOLD(L)/OPAKOLD(L)     * FWMID
+c          OPAJMEAN(L) = OPAJMEAN(L) + OPAKOLD(L)*XJLOLD(L)      * FWMID
+c          OPASMEAN(L) = OPASMEAN(L) + ETAKOLD(L)                * FWMID
+c          OPAPMEAN(L) = OPAPMEAN(L) 
+c      >                        + OPAKOLD(L)*BNUE(XLAMKOLD,T(L)) * FWMID
+c       ELSE
+c          SMEAN(L)    = SMEAN(L)    + ETAKNOTHO(L)/OPAKNOTHO(L) * FWMID
+c          OPAJMEAN(L) = OPAJMEAN(L) + OPAKNOTHO(L)*XJLOLD(L)    * FWMID
+c          OPASMEAN(L) = OPASMEAN(L) + ETAKNOTHO(L)              * FWMID
+c          OPAPMEAN(L) = OPAPMEAN(L) 
+c     >                       + OPAKNOTHO(L)*BNUE(XLAMKOLD,T(L)) * FWMID
+c       ENDIF
+
+C***    Skipping huge lines test       
+        IF (.NOT. bOSKIP .AND. XLAMLASTOSKIP(L) > 0.) THEN
+          bOSKIP = (XLAMK < XLAMLASTOSKIP(L)
+     >                      * (1.+2.*VELO(1)*VDOPUNIT/CLIGHTKM))
+        ENDIF
+
+       
+        
+C***    Calculation of flux intgegral without strong lines 
+C***    (can be used in STEAL->TEMPCORR)
+        IF (.NOT. bOSKIP) THEN
+          IF (bOSKIPLAST(L)) THEN
+C***        The last point was skipped, but now we are back to normal
+C***         => account for missing integral part by linear
+C***             interpolation over the parts where lines have been cut out
+c            HTOTCUT(L) = HTOTCUT(L) 
+c     >           + 0.5 * (XHLOLD(L) + XHBFSKIP(L)) * (FWSKIP + FWMID)
+          ELSE
+C***        Neither the current nor the last point was skipped          
+c            HTOTCUT(L) = HTOTCUT(L) + XHLOLD(L) * FWMID
+          ENDIF
+C***      Reset all variables that store stuff for future skips:          
+          XHBFSKIP(L) = XHLOLD(L)
+          FWSKIP = 0.
+        ELSE
+C***      The current point        
+C***      Add up frequency weights of all skipped points:        
+          FWSKIP = FWSKIP + FWMID
+        ENDIF               
+C***    Store current "skip" status for next frequency point        
+        bOSKIPLAST(L) = bOSKIP
+       
+C***    Account for PRINT DELTAH (debug/demonstration) option:
+        IF (L > 0 .AND. L < ND .AND. L == LPRDH .AND. .NOT. bOSKIP) THEN
+           VDR = VELO(L+1) / RADIUS(L+1)
+           DELTAHNUE = 0.25 * BNUE(XLAMKOLD, TEFF) 
+           DHMECH = 0.
+           IF (L < ND-1) THEN
+             DHMECH =  - ((GRADI(L+1)-VDR)*XKLOLD(L+1)+VDR*XJLOLD(L+1)) 
+     >                    * VDOPUNIT / CLIGHTKM      
+     >                    *  0.5 * (RADIUS(L)-RADIUS(L+2))
+             DELTAHNUE = DELTAHNUE + DHMECH
+           ENDIF
+           DELTAHNUE = DELTAHNUE - XHLOLD(L)         
+           
+           WRITE (140, '(G20.10,9(2X,G20.10))')
+     >                            XLAMKOLD, DELTAHNUE, DHMECH, XNUEK,
+     >                            XJLOLD(L), XHLOLD(L), 
+     >                      OPAKOLD(L), OPAO(L), 
+     >                      BNUE(XLAMKOLD, TEFF), BNUE(XLAMKOLD, T(L))
+        ENDIF
+       
+       
 C***    Option for ALI-like amplification of the temperature correction 
 C***      of the "first term" in the Unsoeld-Lucy procedure
 C***      De-activated if GAMMAT=0.
         IF (GAMMAT .NE. .0) THEN
-c            IF (L .EQ. 1) THEN
-c               DR = 0.
-c            ELSE IF (L .EQ. ND) THEN
-c               DR = 0.
-c            ELSE
-c               DR = AMIN1( RADIUS(L) - RADIUS(ND), 
-c     >                     RADIUS(1) - RADIUS(L))
-c            ENDIF
 
 C***  A more sophisticated estimate of TAU = Delta Tau to nearest border:
 C***  Assume that the opacity dilutes with r**(-2). Integration yields:
@@ -742,6 +1032,13 @@
             ELSE
                ALONUE = 0.
             ENDIF
+ccc  TEST!!!
+c            ALONUE = DJDS(L)
+            ALONUE = DJDSraw(L)
+C***        Damp with GAMMAT instead of GAMMACOLI            
+            ALONUE = -LOG(1.-ALONUE)
+            ALONUE = ALONUE / GAMMAT
+            ALONUE = 1.-EXP(-ALONUE)
 
             OPALAMBDAMEAN(L) = OPALAMBDAMEAN(L) + 
      >                        ETAKNOTHO(L) * ALONUE * FWMID
@@ -786,14 +1083,19 @@
 ccc    ausgerechnet wird, die *volle* Opazitaet (incl. Thomson) hin:
 ccc        wrh  7-Dec-2005 11:56:43
 ccc    Also seine Empfehlung: Ersetze das folgende Statement
-        QOPAHMEAN(L) = QOPAHMEAN(L) +
-     >       QLHOLD(L) * OPATRUE * XHLOLD(L) * FWMID
-ccc    durch:
-cc        OPAFULL    =  0.5 * (OPAKOLD(L) + OPAKOLD(L+1)) 
 cc        QOPAHMEAN(L) = QOPAHMEAN(L) +
-cc     >       QLHOLD(L) * OPAFULL * XHLOLD(L) * FWMID
+cc     >       QLHOLD(L) * OPATRUE * XHLOLD(L) * FWMID
+ccc    durch:
+        OPAFULL    =  0.5 * (OPAKOLD(L) + OPAKOLD(L+1)) 
+        IF (.NOT. bKSKIPMEAN) THEN
+          QOPAHMEAN(L) = QOPAHMEAN(L) +
+     >       QLHOLD(L) * OPAFULL * XHLOLD(L) * FWMID
 
+C***      HMEAN = HTOTL without optically very think frequences
+C***           (same as excluded from mean opacities)
         HMEAN(L)= HMEAN(L) + XHLOLD(L) * FWMID
+        ENDIF
+        
 
  46     CONTINUE
 
diff -bur ./frequnorm.f ../../powr-refactor/src/frequnorm.f
--- ./frequnorm.f	2024-07-28 13:13:27.000000000 +0200
+++ ../../powr-refactor/src/frequnorm.f	2023-11-21 10:10:55.289269787 +0100
@@ -1,12 +1,14 @@
-      SUBROUTINE FREQUNORM (ND, OPASMEAN, OPASMEANTC, SMEAN, QFJMEAN, 
-     >                  XJTOTL, OPAJMEAN, OPAJMEANTC, OPAPMEAN, 
+      SUBROUTINE FREQUNORM (ND, MAXION, OPASMEAN, OPASMEANTC, SMEAN, 
+     >                  QFJMEAN, XJTOTL, OPAJMEAN, OPAJMEANTC, OPAPMEAN, 
      >                  QOPAHMEAN, HMEAN, EDDIHOUTJMEAN, 
      >                  RADIUS, RSTAR, DENSCON, 
-     >                  FTCOLI, WJC, WJC_MIN, 
+     >                  FTCOLI, FTCOLIB, WJC, WJC_MIN, 
      >                  FWTEST, NF, OPC, FTFE, LASTFE, 
      >                  LPLOT_WCHARM, XLAMBDA, OPAROSS, OPALAMBDAMEAN, 
      >                  ARAD, ACONT, ATHOM, ENTOT, ABXYZ, ATMASS, NATOM,
-     >                  T, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2, TAUROSS)
+     >                  T, GAMMAT, UNLU_TAUMAX, UNLU_TAUMAX2, TAUROSS,
+     >                  ARADELEM, ACONTELEM, ARADION, ACONTION,
+     >                  OPAROSSCONT, OPAROSSELEM, OPATOTELEM)
 C*************************************************************
 C***  Some quantities which were intergrated in FREQUINT are
 C***    now normalized etc. 
@@ -14,24 +16,32 @@
 
       IMPLICIT NONE
 
-      INTEGER, INTENT(IN) :: ND, NF, NATOM, LASTFE
+      INTEGER, INTENT(IN) :: ND, NF, NATOM, MAXION, LASTFE
 
       REAL, DIMENSION(NATOM), INTENT(IN) :: ABXYZ, ATMASS
       REAL, DIMENSION(ND), INTENT(IN) :: ENTOT
       REAL, DIMENSION(ND), INTENT(OUT) :: TAUROSS
-      REAL, DIMENSION(ND), INTENT(INOUT) :: ARAD, ACONT, ATHOM
+      REAL, DIMENSION(ND), INTENT(INOUT) :: ARAD, ACONT, ATHOM,
+     >                                      OPAROSSCONT
+      REAL, DIMENSION(NATOM, ND), INTENT(INOUT) :: OPAROSSELEM, 
+     >                                             OPATOTELEM
+      REAL, DIMENSION(NATOM, ND-1), INTENT(INOUT) :: ARADELEM, 
+     >                                               ACONTELEM
+      REAL, DIMENSION(ND-1, NATOM, MAXION), INTENT(INOUT) :: ARADION, 
+     >                                                       ACONTION
+     
 
       REAL, DIMENSION(ND) :: OPASMEAN, SMEAN, QFJMEAN,
      >                       XJTOTL, OPAJMEAN, QOPAHMEAN,
      >                       OPASMEANTC, OPAJMEANTC, OPAPMEAN,
      >                       OPAROSS, OPALAMBDAMEAN, T,
-     >                       FTCOLI, RADIUS, HMEAN
+     >                       FTCOLI, FTCOLIB, RADIUS, HMEAN
       CHARACTER(8) :: OPC
       REAL, DIMENSION(ND,NF) :: WJC, WJC_MIN
       REAL, DIMENSION(ND,LASTFE) :: FTFE
       REAL, DIMENSION(NF) :: FWTEST, XLAMBDA
       
-      INTEGER :: K, KK, L, NA, INDFE, LPLOT_WCHARM
+      INTEGER :: K, KK, L, NA, ION, INDFE, LPLOT_WCHARM
       REAL :: ATMEAN, UNLU_TAUMAX, UNLU_TAUMAX2, TACCELERATE,
      >        TACCELERATE2, SDURCHB, FDAMP, ETAUROSS, GAMMAT,
      >        RSTAR, RINT, RL2, EWTOT, CC, EDDIHOUTJMEAN, FCOR,
@@ -40,6 +50,10 @@
 C***  tiefenabh. clumping nach goetz
       REAL, DIMENSION(ND) :: DENSCON
 
+      !File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)      
+      
 C***  Maximum Value for Scharmer Weight: 1 - 1.E-10
 C***  corresponding to a maximum optical depth of ca. tau = 1E10 
       REAL, PARAMETER :: WJCMAX = 0.9999999999 
@@ -66,11 +80,20 @@
         OPAJMEANTC(L) = DENSCON(L) * OPAJMEANTC(L) / (XJTOTL(L) * RSTAR)
         OPAPMEAN  (L) = DENSCON(L) * OPAPMEAN  (L) / (BTOTL * RSTAR)
         FTCOLI    (L) = DENSCON(L) * FTCOLI(L)
+        FTCOLIB   (L) = DENSCON(L) * FTCOLIB(L)
         DO INDFE=1, LASTFE
            FTFE(L,INDFE) = DENSCON(L) * FTFE(L,INDFE)
         ENDDO
 
         OPAROSS(L) = 4.*STEBOL*T(L)*T(L)*T(L) / OPAROSS(L) 
+        OPAROSSCONT(L) = 4.*STEBOL*T(L)*T(L)*T(L) / OPAROSSCONT(L) 
+        DO NA=1, NATOM
+          IF (OPAROSSELEM(NA,L) /= 0.) THEN
+            OPAROSSELEM(NA,L) = 4.*STEBOL*T(L)*T(L)*T(L) 
+     >                                        / OPAROSSELEM(NA,L) 
+          ENDIF
+          OPATOTELEM(NA,L) = OPATOTELEM(NA,L) / RSTAR 
+        ENDDO
 
         IF (L == ND) CYCLE
 
@@ -80,6 +103,18 @@
         ARAD(L)  = PI4 * ARAD(L)  / (RSTAR*CLIGHT*RINT*RINT*EWTOT)
         ACONT(L) = PI4 * ACONT(L) / (RSTAR*CLIGHT*RINT*RINT*EWTOT)
         ATHOM(L) = PI4 * ATHOM(L) / (RSTAR*CLIGHT*RINT*RINT*EWTOT)
+        DO NA=1, NATOM
+          ARADELEM(NA,L)  = PI4 * ARADELEM(NA,L) / 
+     >                              (RSTAR*CLIGHT*RINT*RINT*EWTOT)
+          ACONTELEM(NA,L)  = PI4 * ACONTELEM(NA,L) / 
+     >                              (RSTAR*CLIGHT*RINT*RINT*EWTOT)
+          DO ION=1, MAXION
+            ARADION(L,NA,ION) = PI4 * ARADION(L, NA, ION) / 
+     >                              (RSTAR*CLIGHT*RINT*RINT*EWTOT)
+            ACONTION(L,NA,ION) = PI4 * ACONTION(L, NA, ION) / 
+     >                              (RSTAR*CLIGHT*RINT*RINT*EWTOT)
+          ENDDO
+        ENDDO
 
 C***    Note: QOPAHMEAN is with the average density (not: clump), because it 
 C***          enters a transfer eq. 
diff -bur ./grey.f ../../powr-refactor/src/grey.f
--- ./grey.f	2024-07-28 13:13:30.000000000 +0200
+++ ../../powr-refactor/src/grey.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,7 +1,7 @@
       SUBROUTINE GREY (ND,T,RADIUS,XLAMBDA,FWEIGHT,NF,ENTOT,RNE,RSTAR,
      $            ALPHA,SEXPO,
      $            ADDCON1, ADDCON2, ADDCON3, 
-     $            IGAUNT,POPNUM,TAUROSS,R23,TEXIST,NDIM,N,
+     >            IGAUNT,POPNUM,TAUROSS,R23,TEXIST,NDIM,N,
      $            LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,ENLTE,KODAT,
      $            ABXYZ,NOM,NFIRST,NLAST,NATOM,EXPFAC,SIGMAKI,NFEDGE,
      $            OPAC,ETAC,SIGMAFF,MAXION,MAXATOM,SIGMATHK,EDGEK,
@@ -42,6 +42,8 @@
       COMMON / COMOS / OPSYS
       CHARACTER*8 OPSYS
 
+      INTEGER, PARAMETER :: ITER23MAX = 50
+
       DIMENSION XLAMBDA(NF),FWEIGHT(NF),EXPFAC(NF)
       DIMENSION SIGMAKI(NF,LASTKON)
       DIMENSION T(ND),RADIUS(ND),RNE(ND),ENTOT(ND),TAUROSS(ND)
@@ -232,9 +234,9 @@
       R23COM=R23
       TAU1=1.
       IF (TAUROSS(ND) .LT. TAU1  ) THEN
-      R1 COM=1.
+      R1COM=1.
          ELSE
-         CALL LIPO (R1 COM,TAU1 ,RADIUS,TAUROSS,ND)
+         CALL LIPO (R1COM,TAU1 ,RADIUS,TAUROSS,ND)
          ENDIF
       TAU13=0.333333333333
       IF (TAUROSS(ND) .LT. TAU13 ) THEN
@@ -244,9 +246,9 @@
          ENDIF
  
       IF (ITER .LE. 1 .OR. 
-     >    (DTMAX .GT. 10. .AND. ITER .LE. 20)) GOTO 100
+     >    (DTMAX .GT. 10. .AND. ITER .LE. ITER23MAX)) GOTO 100
 C      IF (DTMAX .GT. 10.) GOTO 100
-      IF (ITER .GT. 20) THEN
+      IF (ITER .GT. ITER23MAX) THEN
         WRITE (0,*) 'Max Number of Iterations exceeded in Subr. GREY'
       ENDIF
  
diff -bur ./initfcorr.f ../../powr-refactor/src/initfcorr.f
--- ./initfcorr.f	2024-07-28 13:13:32.000000000 +0200
+++ ../../powr-refactor/src/initfcorr.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,14 +1,25 @@
-      SUBROUTINE INITFCORR (TEFF, RSTAR, T, RNE, bNoARAD,
+      SUBROUTINE INITFCORR (TEFF, RSTAR, T, RNE, bNoARAD, bINCADV,
      >                      ABXYZ, ATMASS, ELEMENT, NATOM, WRTYPE,
      >                      RADIUS, VELO, GRADI, VTURB, ENTOT, ND,
      >                      HTOTM, HTOTG, HTOTOBS, HTOTL, ACONT, ATHOM,
      >                      AGRAV, AMECH, ARAD, APRESS, WORKRATIO, 
      >                      CLUMP_SEP, OPAROSS, MacroCard, DENSCON,
-     >                      FILLFAC, OPALINE_SCALE,
-     >                      FTCOLI, XJTOTL, XKTOTL, XNTOTL, HTOTCMF0, 
-     >                      XMSTAR, MFORM, GLOG, ATMEAN, VMACH,
-     >                      TAUROSS, QIONMEAN, GAMMARADMEAN, RCON)
-
+     >                      FILLFAC, OPALINE_SCALE, MacroDamp, FTCOLI,
+     >                      XJTOTL, XKTOTL, XNTOTL, HTOTCMF0, 
+     >                      HTOTCMF0ADV, HTOTND, HTOTE, XMSTAR, MFORM, 
+     >                      GLOG, ATMEAN, VMACH,
+     >                      XMU, TAUROSS, QIONMEAN, GAMMARADMEAN, RCON)
+C***********************************************************************
+C**** calculates the acceleration contributions, the integrated
+C**** work ratio as well as the input of the wind on the observed flux
+C**** This information is used most prominently in the subroutines
+C**** ENSURETAUMAX and HYDROSOLVE, where the hydrostatic/-dynamic
+C**** is solved to obtain a new velocity field.
+C**** A graphical output of the contributions is provided by the 
+C**** ACC plot done in PLOTACC
+C****
+C**** called by STEAL
+C***********************************************************************
       IMPLICIT NONE
       INCLUDE 'interfacebib.inc'
      
@@ -19,29 +30,34 @@
      >                       HTOTM, HTOTG, HTOTOBS, HTOTL, HTOTCMF0,
      >                       AGRAV, AMECH, ARAD, APRESS, GEFFL, RI,
      >                       ATHOM, ACONT, ALINES, DENSCON, FILLFAC, 
-     >                       XJTOTL, XKTOTL, XNTOTL, FTCOLI, 
-     >                       OPAROSS, ClumpScale, TAUROSS, VMACH
+     >                       XJTOTL, XKTOTL, XNTOTL, FTCOLI, MacroDamp,
+     >                       OPAROSS, ClumpScale, HTOTE, HTOTCMF0ADV,
+     >                       TAUROSS, VMACH, XMU, VTURB
      
       INTEGER :: MFORM, NA, L, LCON
-      REAL :: GLOG, VTURB, ATMEAN, XMSTARG, XMSTAR, TEFF, XMDOT,
+      REAL :: GLOG, ATMEAN, XMSTARG, XMSTAR, TEFF, XMDOT, TINT,
      >        EWTOT, WMEAN, XHY, YHE, XC, SUM, SUMADD, HNULL, VELOINT,
      >        RINT, DELTAH, DELTAV, DELTAR, XMECH, VDR, RSTAR, RL2,
      >        HMECH, HMECH1, HGRAV, XGRAV, XKINT, XJINT, WRAD, WWIND, 
      >        RHOL, RHOLP, XMUL, XMULP, AL2, ALP2, PL, PLP, WORKRATIO,
-     >        CLUMP_SEP, OPALINE_SCALE, DCmacro, fAmod, TauCL,
-     >        QIONMEAN, GAMMARADMEAN, RCON
+     >        CLUMP_SEP, OPALINE_SCALE, DCmacro, fAmod, TauCL, dummy,
+     >        QIONMEAN, GAMMARADMEAN, RCON, HTOTND, DVDR, DVTURBDR,
+     >        VMACHINT, VTURBINT, ENTOTINT, DENTOTDR, DVMACHDR, DJDR,
+     >        AMACHINT, APRESSTEST, DELTAA, XESPC, HESPC, HSPCM, DHSPC,
+     >        DELTAHADV
       
       CHARACTER(2) :: WRTYPE
       CHARACTER(9) :: MLRELATION
       CHARACTER(120) :: MacroCard
 
-      LOGICAL :: BFMEC, bNoARAD
+      LOGICAL :: BFMEC, bNoARAD, bINCADV
 
 C***  Physical constants
       REAL, PARAMETER :: PI4 = 12.5663706144    !PI4 = 4*PI
       REAL, PARAMETER :: GCONST = 6.6726E-8     !GCONST = GRAVITATIONAL CONSTANT (CGS-UNITS)
       REAL, PARAMETER :: STEBOL = 1.8046E-5     !STEBOL = STEFAN-BOLTZMANN CONSTANT (CGS-UNITS) / PI
-      REAL, PARAMETER :: CLIGHTKM = 2.9979E5    !CLIGHT = SPEED OF LIGHT IN KILOMETER/SECOND
+      REAL, PARAMETER :: CLIGHTKM = 2.99792458E5    !CLIGHT = SPEED OF LIGHT IN KILOMETER/SECOND
+      REAL, PARAMETER :: RADCONST = 7.5657E-15  !RADIATION CONSTANT in cgs (erg cm^-3 K^-4)
       REAL, PARAMETER :: BOLTZK = 1.3807E-16    !BOLTZMANN CONSTANT on cgs units
       REAL, PARAMETER :: XMSUN = 1.989E33       !XMSUN = Solar Mass (g)
       REAL, PARAMETER :: XLSUN = 3.85E33        !Solar Luminosity (CGS-Units)
@@ -116,6 +132,24 @@
       ENDDO
       WMEAN = AMU*ATMEAN
 
+      DO L=1, ND
+        XMU(L)  = ATMEAN / (1.+RNE(L))
+        XMULP = ATMEAN / (1.+RNE(L+1))
+        IF (L == ND-1) THEN
+          XMU(ND) = XMULP
+        ENDIF
+        AL2   = BOLTZK / AMU * T(L) / XMU(L)
+        ALP2  = BOLTZK / AMU * T(L+1) / XMULP
+      
+        VMACH(L) = SQRT(AL2) / 1.E5
+        IF (L == ND-1) THEN
+          VMACH(ND) = SQRT(ALP2) / 1.E5
+        ENDIF      
+        
+        IF (L == ND) CYCLE
+        RI(L) = 0.5 * ( RADIUS(L) + RADIUS(L+1) )        
+      ENDDO
+            
             
       DO L=1, ND          
          RL2 = RADIUS(L) * RADIUS(L)
@@ -129,22 +163,29 @@
          XGRAV = XMDOT*GCONST*XMSTARG/RSTAR * (1. - 1./RADIUS(L))
          HGRAV = XGRAV / (RSTAR*RSTAR*PI4*PI4)
          
+C***     Flux of specific Gas Energy
+         XESPC   = XMDOT * BOLTZK * T(L) / (XMU(L) * AMU)
+         HESPC   = XESPC / (RSTAR*RSTAR*PI4*PI4)
+         
          IF (L .EQ. 1) HMECH1 = HMECH
 
          HTOTM(L) = HMECH
          HTOTG(L) = HGRAV
+         HTOTE(L) = HESPC
 
 C***  Gravitational and Wind acceleration at radius interstices
          IF (L .EQ. ND) EXIT
 
-         RI(L) = 0.5 * ( RADIUS(L) + RADIUS(L+1) )
          RINT = RI(L) * RSTAR
          AGRAV(L) = XMSTARG * GCONST / RINT / RINT
 
-         VELOINT = 0.5 * (VELO(L) + VELO(L+1)) 
-         DELTAV = (VELO(L) - VELO(L+1)) 
+c         VELOINT = 0.5 * (VELO(L) + VELO(L+1)) 
+         CALL SPLINPOX(VELOINT, RI(L), VELO, RADIUS, ND, DFDX=DVDR)
+         
+c         DELTAV = (VELO(L) - VELO(L+1)) 
          DELTAR = (RADIUS(L) - RADIUS(L+1)) * RSTAR
-         AMECH(L) = VELOINT * DELTAV / DELTAR * 1.E10
+c         AMECH(L) = VELOINT * DELTAV / DELTAR * 1.E10
+         AMECH(L) = VELOINT * DVDR * 1.E10 / RSTAR
 C***  Gas Pressure term
 C***     a_press = - 1/rho dp/dr
 C***       including turbulence:
@@ -153,24 +194,16 @@
 C***         rho = ENTOT * m_H * ATMEAN = ENTOT * WMEAN
 C***          mu = ATMEAN / ( 1 + RNE )
          EWTOT = 0.5 * (ENTOT(L) + ENTOT(L+1)) * WMEAN
-         RHOL  = ENTOT(L) * WMEAN
-         RHOLP = ENTOT(L+1) * WMEAN
-         XMUL  = ATMEAN / (1.+RNE(L))
-         XMULP = ATMEAN / (1.+RNE(L+1))
-         AL2   = BOLTZK / AMU * T(L) / XMUL
-         ALP2  = BOLTZK / AMU * T(L+1) / XMULP
-         PL  = RHOL  * (AL2  + (VTURB*1.E5)**2)
-         PLP = RHOLP * (ALP2 + (VTURB*1.E5)**2)
-         APRESS(L) = (PLP-PL) / (DELTAR * EWTOT)
-
-         VMACH(L) = SQRT(AL2) / 1.E5
-         IF (L == ND-1) THEN
-           VMACH(ND) = SQRT(ALP2) / 1.E5
-         ENDIF
-C         IF (L > 50) THEN
-C           WRITE (0,'(I4,6(G15.8))') L, PL, EWTOT,
-C     >     DELTAR, (PLP-PL), EWTOT*DELTAR, APRESS(L)
-C         ENDIF
+         CALL SPLINPOX(ENTOTINT,RI(L),ENTOT,RADIUS,ND, DFDX=DENTOTDR)
+         CALL SPLINPOX(VMACHINT,RI(L),VMACH,RADIUS,ND, DFDX=DVMACHDR)
+         CALL SPLINPOX(VTURBINT,RI(L),VTURB,RADIUS,ND, DFDX=DVTURBDR)
+         CALL SPLINPOX(TINT,RI(L),T,RADIUS,ND)
+         
+         APRESS(L) = - (
+     >            (VMACHINT**2 + VTURBINT**2) / ENTOTINT * DENTOTDR
+     >                 + 2. * VMACHINT * DVMACHDR
+     >                 + 2. * VTURBINT * DVTURBDR
+     >                 ) * 1.E10 / RSTAR
 
 C***     Scale line acceleration if CARDS option is set        
          IF (OPALINE_SCALE /= 1.) THEN
@@ -180,6 +213,7 @@
          ENDIF
 
 C***     Adjust with macroclumping effect 
+         MacroDamp = 1.
          IF (CLUMP_SEP > 0.) THEN
            DCmacro = 0.5 * (DENSCON(L) + DENSCON(L+1))
            ClumpScale(L) = CLUMP_SEP * ( 3./PI4 /DCmacro )**(1./3.)
@@ -192,6 +226,8 @@
            ENDIF
            ARAD(L) = ARAD(L) * fAmod
            ACONT(L) = ACONT(L) * fAmod
+           ATHOM(L) = ATHOM(L) * fAmod
+           MacroDamp(L) = fAmod
          ENDIF          
 
 C***  Integrals of total work (arbitrary units)
@@ -207,6 +243,7 @@
 
       ENDDO
 
+      
 C***  Calculate mean GAMMARAD and mean ionization parameter q  
       QIONMEAN = RNE(ND) / ATMEAN
       DO L=ND-1, 1, -1
@@ -226,8 +263,16 @@
 C***        interstices L+1/2, L-1/2. 
       HNULL = 0.25 * STEBOL * TEFF*TEFF*TEFF*TEFF
       HTOTCMF0(ND-1) = HNULL
+      HTOTCMF0ADV(ND-1) = HNULL
       DO L=ND-1, 2, -1
          VDR = VELO(L)/RADIUS(L)
+         CALL SPLINPOX(dummy,RADIUS(L),XJTOTL,RADIUS,ND, DFDX=DJDR)
+         DELTAHADV = ( (GRADI(L)-VDR)*(XKTOTL(L)+XJTOTL(L))
+     >                  + 4 * VDR*XJTOTL(L) 
+     >                  + VELO(L)*DJDR-2*VDR*XJTOTL(L) ) *
+     >              0.5 * (RADIUS(L-1)-RADIUS(L+1)) / CLIGHTKM
+         HTOTCMF0ADV(L-1) = HTOTCMF0ADV(L) - DELTAHADV
+
          DELTAH = ((GRADI(L) -VDR)*XKTOTL(L) + VDR*XJTOTL(L)) *
      >            0.5 * (RADIUS(L-1)-RADIUS(L+1)) / CLIGHTKM
          HTOTCMF0(L-1) = HTOTCMF0(L) - DELTAH 
diff -bur ./intepo.f ../../powr-refactor/src/intepo.f
--- ./intepo.f	2024-07-28 13:13:33.000000000 +0200
+++ ../../powr-refactor/src/intepo.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,11 +1,15 @@
-      SUBROUTINE INTEPO (ND,N,RNE,NCHARG,POPNUM,ENTOT,NATOM,ABXYZ,
-     $                   NFIRST,NLAST,IFRO,ITO,MODE,NOPOP)
+      SUBROUTINE INTEPO (ND,N,RNE,NCHARG,POPNUM,ENTOT,NATOM,
+     >                   NALIM, IONLIM, ABXYZ, NFIRST, NLAST,
+     >                   IFRO, ITO, MODE, NOPOP)
 C***********************************************************************
 C***  LINEAR INTERPOLATION BETWEEN GIVEN DENSITY POINTS OR 
 C***  EXTRAPOLATION FROM A GIVEN DENSITY POINT TO INNER OR OUTER BOUNDARY
 C***
 C***  THE ELECTRON DENSITY IS UPDATED ACCORDING TO THE NEW POPNUMBERS
+C***
+C***  note: limitation to ION blocks not yet implemented (only ATOM blocks)
 C***********************************************************************
+      INTEGER, INTENT(IN) :: ND, N, NATOM, NALIM, IONLIM
  
       DIMENSION RNE(ND),NCHARG(N),POPNUM(ND,N),ENTOT(ND)
       DIMENSION ABXYZ(NATOM),NFIRST(NATOM),NLAST(NATOM)
@@ -43,6 +47,7 @@
 
 C***  LOOP FOR EACH ELEMENT  ------------------------------
       DO 1 NA=1,NATOM
+      IF (NALIM > 0 .AND. NA /= NALIM) CYCLE        !ATOM limitation (useful with DM split)
       NFIRNA=NFIRST(NA)
       NLANA=NLAST(NA)
       POPSUM=.0
diff -bur ./interpolatepopnum.f ../../powr-refactor/src/interpolatepopnum.f
--- ./interpolatepopnum.f	2024-07-28 13:13:34.000000000 +0200
+++ ../../powr-refactor/src/interpolatepopnum.f	2023-09-27 10:14:15.109755551 +0200
@@ -5,12 +5,21 @@
      >                             Rold,    !old radius grid vector
      >                             ENTOTnew, !old total particle number
      >                             ENTOTold, !new total particle number
+     >                             RNEnew,  !new relative electron number density
+     >                             RNEold,
+     >                             Tnew,    !new temperature structure
+     >                             Told,    !old temperature structure
      >                             N,       !number of levels in DATOM
      >                             ND,      !number of depth points
      >                             ABXYZ,
      >                             NFIRST,  !Array with first level number of element blocks in level list
      >                             NLAST,   !similar to NFIRST, but with last level number
      >                             NATOM,   !Number of different elements in the model
+     >                             NCHARG,  !charge per level
+     >                             WEIGHT,  !Weight (g) factor per level
+     >                             EION,    !Ionization energy per level 
+     >                             ELEVEL,  !Level energy per level
+     >                             NOM,     !corresponding element index for each level
      >                             bUseENTOT)     
 C**********************************************************************
 C***
@@ -28,20 +37,46 @@
       INCLUDE 'interfacebib.inc'
 
       INTEGER, INTENT(IN) :: N, ND, NATOM
-      INTEGER, DIMENSION(NATOM) :: NFIRST, NLAST
-      REAL, DIMENSION(NATOM) :: ABXYZ
-      REAL, DIMENSION(ND), INTENT(IN) :: Rnew, Rold, ENTOTold, ENTOTnew
+      INTEGER, DIMENSION(NATOM), INTENT(IN) :: NFIRST, NLAST
+      REAL, DIMENSION(NATOM), INTENT(IN) :: ABXYZ
+      REAL, DIMENSION(ND), INTENT(IN) :: Rnew, Rold, Tnew, Told,
+     >                                   ENTOTold, ENTOTnew, RNEold
+      REAL, DIMENSION(ND), INTENT(INOUT) :: RNEnew
       REAL, DIMENSION(ND, N), INTENT(IN) :: POPOLD
       REAL, DIMENSION(ND, N), INTENT(INOUT) :: POPNUM
+      INTEGER, DIMENSION(N), INTENT(IN) :: NCHARG, NOM
+      REAL, DIMENSION(N), INTENT(IN) :: WEIGHT, EION, ELEVEL 
       REAL, INTENT(IN) :: POPMIN
       
-      REAL, DIMENSION(ND) :: ENTOToldLOG, POPJLOG, RoldLOG
+      INTEGER, PARAMETER :: NIPMAX = 5000
+      INTEGER, PARAMETER :: NDIPMAX = 500
         
-      INTEGER :: L, J, NA, NFIRNA, NLANA
-      REAL :: SUMME, POPJLOGnewL, ENTOTnewLOGL, RnewLOGL
+      REAL, DIMENSION(NDIPMAX) :: ENTOToldLOG, RoldLOG, POPJLOG
+      REAL, DIMENSION(NIPMAX) :: ENLTE, DEPARToldND
+        
+      INTEGER :: L, J, NA, NFIRNA, NLANA, NDr
+      REAL :: SUMME, POPJLOGnewL, ENTOTnewLOGL, RnewLOGL, RNEL, TL, ENE
 
       LOGICAL, INTENT(IN) :: bUseENTOT
       
+C***  File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+      
+      IF (N > NIPMAX) THEN
+        WRITE (hCPR,'(A)') 'IPVECRLOG: FATAL ERROR ******'
+        WRITE (hCPR,'(A)') 'IPVECRLOG: NIPMAX INSUFFICIENT'
+        WRITE (hCPR,'(2(A,I4))') 'N = ', N, ', NIPMAX = ', NIPMAX
+        STOP 'FATAL ERROR IN STEAL->INTERPOLATEPOPNUM'      
+      ENDIF
+      
+      IF (ND > NDIPMAX) THEN
+        WRITE (hCPR,'(A)') 'IPVECRLOG: FATAL ERROR ******'
+        WRITE (hCPR,'(A)') 'IPVECRLOG: NDIPMAX INSUFFICIENT'
+        WRITE (hCPR,'(2(A,I4))') 'ND = ', ND, ', NDIPMAX = ', NDIPMAX
+        STOP 'FATAL ERROR IN STEAL->INTERPOLATEPOPNUM'      
+      ENDIF
+      
       
 C***  Skip this routine if called for a not yet defined popnumber array
       IF (MAXVAL(POPOLD) <= 0.) THEN
@@ -49,6 +84,16 @@
         RETURN
       ENDIF
       
+C***  Calculate departure coefficients for old innermost depth point
+C     (required for inner extrapolation)
+      ENE = RNEold(ND) * ENTOTold(ND)
+      TL = Told(ND)
+      CALL LTEPOP (N, ENLTE, TL, ENE, 
+     >             WEIGHT, NCHARG, EION, ELEVEL, NOM,
+     >             ABXYZ, NFIRST, NLAST, NATOM)
+      DO J=1, N
+        DEPARToldND(J) = POPOLD(ND,J) / ENLTE(J) 
+      ENDDO
 
 C***  Recommended branch: interpolation of (log n_i) over (log n_tot)
       IF (bUseENTOT) THEN
@@ -63,8 +108,13 @@
           dploop: DO L=1, ND
             ENTOTnewLOGL = LOG10(ENTOTnew(L))
             IF (ENTOTnewLOGL > ENTOToldLOG(ND)) THEN
-              !more dense than old innermost value => take old inner boundary value
-              POPJLOGnewL = POPJLOG(ND)
+               TL = Tnew(L)
+C              !use old RNE(ND) for ENE here (can this be improved?)
+               ENE = RNEold(ND) * ENTOTnew(L)
+               CALL LTEPOP (N, ENLTE, TL, ENE, 
+     >                      WEIGHT, NCHARG, EION, ELEVEL, NOM,
+     >                      ABXYZ, NFIRST, NLAST, NATOM)                            
+               POPJLOGnewL = LOG10( ENLTE(J) * DEPARToldND(J) )
             ELSEIF (ENTOTnewLOGL < ENTOToldLOG(1)) THEN
               !less dense than old outermost value => take old outer boundary value
               POPJLOGnewL = POPJLOG(1)
@@ -80,7 +130,15 @@
 C***   double-logarithmic interpolation over radius
         DO J=1, N
           DO L=1, ND
+            IF (L > 1) THEN
+C***          Account for the possibility that the old radius might be shifted
+C***          and thus we have to determine the number of points NDr in the "normal"
+C***          radius Range 1...RMAX. 
+C***          (One point for R < 1 is allowed to avoid inner cutoffs.)
+              IF (Rold(L-1) < 1. .OR. Rold(L) <= 0.) EXIT
+            ENDIF
             RoldLOG(L) = LOG10(Rold(L))
+            NDr = L
 C           Note: minimum popnumber ist POPMIN
             POPJLOG(L) = LOG10(MAX(POPOLD(L,J),POPMIN))
           ENDDO          
@@ -89,11 +147,11 @@
             IF (RnewLOGL > RoldLOG(1)) THEN
 C             If R outside the old grid, use old outermost value
               POPJLOGnewL = POPJLOG(1)
-            ELSEIF (RnewLOGL < RoldLOG(ND)) THEN
+            ELSEIF (RnewLOGL < RoldLOG(NDr)) THEN
 C             If R < 1 use innermost value (should never happen)
-              POPJLOGnewL = POPJLOG(ND)
+              POPJLOGnewL = POPJLOG(NDr)
             ELSE
-              CALL SPLINPOX(POPJLOGnewL,RnewLOGL,POPJLOG,RoldLOG,ND)
+              CALL SPLINPOX(POPJLOGnewL,RnewLOGL,POPJLOG,RoldLOG,NDr)
             ENDIF
             POPNUM(L,J) = 10**(POPJLOGnewL)
           ENDDO
@@ -117,6 +175,11 @@
           ENDIF
         ENDDO
 
+        RNEL=0.0
+        DO J=1, N
+          RNEL = RNEL + NCHARG(J) * POPNUM(L,J)
+        ENDDO
+        RNEnew(L)=RNEL
       ENDDO
 
       RETURN
diff -bur ./interpolatetemp.f ../../powr-refactor/src/interpolatetemp.f
--- ./interpolatetemp.f	2024-07-28 13:13:34.000000000 +0200
+++ ../../powr-refactor/src/interpolatetemp.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,6 +1,9 @@
-      SUBROUTINE INTERPOLATETEMP(Tnew, Told, Rnew, Rold, ND)
+      SUBROUTINE INTERPOLATETEMP(Tnew, Told, Rnew, Rold, 
+     >                           ENTOTnew, ENTOTold, 
+     >                           TAUold, TEFF, ND, bUseENTOT)
 C***********************************************************************
 C***  Interpolation of the electron temperature on a new grid
+C***   note: TAUold is the FULL TAUROSS incl. lines (from COLI)
 C***  
 C***  called by ENSURETAUMAX
 C***********************************************************************
@@ -9,30 +12,85 @@
       INCLUDE 'interfacebib.inc'
 
       INTEGER, INTENT(IN) :: ND
+      REAL, INTENT(IN) :: TEFF
       REAL, DIMENSION(ND), INTENT(INOUT) :: Tnew
-      REAL, DIMENSION(ND), INTENT(IN) :: Rnew, Rold, Told
+      REAL, DIMENSION(ND), INTENT(IN) :: Rnew, Rold, Told,
+     >                                   ENTOTold, ENTOTnew, TAUold
 
-      REAL :: RnewLOGL
-      INTEGER :: L
-      LOGICAL, PARAMETER :: bLOG = .TRUE.
+      LOGICAL, INTENT(IN) :: bUseENTOT
       
-C***  Heap variables      
-      REAL, DIMENSION(ND) :: RoldLOG      
+      INTEGER, PARAMETER :: NDextrap = 2
+      REAL, DIMENSION(NDextrap) :: Textrap, TextrapENTOT
+      REAL, DIMENSION(ND) :: ENTOToldLOG, ENTOTnewLOG, TAUnew, RoldLOG
 
+      REAL :: TMold, TMnew, DTDR, Thelp, Rhelp, 
+     >        RinOLD, TinOLD, RnewLOGL
+      INTEGER :: L, NDr
+      LOGICAL :: bTINEXTRAP, bTAUEXTRAP
 
-      IF (bLOG) THEN
+      bTINEXTRAP = .FALSE.      !switch on/off inner temperature extrapolation
+      bTAUEXTRAP = .FALSE.     
+      
+      IF (bUseENTOT) THEN
+
+        DO L=1, ND
+          ENTOToldLOG(L) = LOG10(ENTOTold(L))
+          ENTOTnewLOG(L) = LOG10(ENTOTnew(L))
+        ENDDO          
+        
+C       Estimate current Tau change         
+        TAUnew(1) = 0.
+        DO L=2, ND
+          TAUnew(L) = TAUnew(L-1) + ENTOTnew(L)/ENTOTold(L)
+     >         * (Rnew(L-1) - Rnew(L))/(Rold(L-1) - Rold(L))
+     >         * (TAUold(L) - TAUold(L-1))          
+        ENDDO
+        TMnew = TAUnew(ND)
+        
+        IF (ENTOTnewLOG(ND) > ENTOToldLOG(ND)) THEN          
+          CALL SPLINPOX(TMold, ENTOToldLOG(ND), TAUnew, ENTOTnewLOG, ND)
+          TinOLD = Told(ND)          
+        ENDIF
+        
+C       Perform interpolation
+        dploop: DO L=1, ND
+          IF (ENTOTnewLOG(L) > ENTOToldLOG(ND)) THEN
+            IF (bTINEXTRAP) THEN
+              Tnew(L) = TinOLD *
+     >                ( (TAUnew(L) + 2./3.) / (TMold + 2./3.) )**(0.25)
+            ELSE
+              Tnew(L) = Told(ND)
+            ENDIF
+          ELSEIF (ENTOTnewLOG(L) < ENTOToldLOG(1)) THEN
+            !less dense than old outermost value => take old outer boundary value
+            Tnew(L) = Told(1)
+          ELSE
+            CALL SPLINPOX(Tnew(L), ENTOTnewLOG(L),
+     >                    Told, ENTOToldLOG, ND)
+          ENDIF
+        ENDDO dploop
+
+      ELSEIF (.TRUE.) THEN
 C***    Interpolation over log radius  
         DO L=1, ND
+          IF (L > 1) THEN
+C***    Account for the possibility that the old radius might be shifted
+C***    and thus we have to determine the number of points NDr in the "normal"
+C***    radius Range 1...RMAX. 
+C***    (One point for R < 1 is allowed to avoid inner cutoffs.)
+            IF (Rold(L-1) < 1. .OR. Rold(L) <= 0.) EXIT
+          ENDIF
           RoldLOG(L) = LOG10(Rold(L))
+          NDr = L
         ENDDO                 
         DO L=1, ND
           RnewLOGL = LOG10(Rnew(L))
           IF (RnewLOGL > RoldLOG(1)) THEN
             Tnew(L) = Told(1)
-          ELSEIF (RnewLOGL < RoldLOG(ND)) THEN
-            Tnew(L) = Told(ND) 
+          ELSEIF (RnewLOGL < RoldLOG(NDr)) THEN
+            Tnew(L) = Told(NDr) 
           ELSE
-            CALL SPLINPOX(Tnew(L), RnewLOGL, Told, RoldLOG, ND)
+            CALL SPLINPOX(Tnew(L), RnewLOGL, Told, RoldLOG, NDr)
           ENDIF
         ENDDO
       ELSE
diff -bur ./inv.f ../../powr-refactor/src/inv.f
--- ./inv.f	2024-07-28 13:13:35.000000000 +0200
+++ ../../powr-refactor/src/inv.f	2023-11-21 10:10:55.289269787 +0100
@@ -7,7 +7,8 @@
 C***  NMAX   = MAXIMUM VALUE OF NDIM
 C**********************************************************************
 
-      PARAMETER (NMAX=2000)
+c      PARAMETER (NMAX=2000)
+      PARAMETER (NMAX=4000)
       DIMENSION A(NDIM,NDIM)
       CHARACTER*4 CKEY
 
@@ -15,7 +16,8 @@
 C***  If DEC-DXML Routines are used, it should be 64*NPDIM
 C***  Here NPDIM=94 is assumed ==> 94 * 64 = 6016
 C***  Or, for solving the statistical equations NDIM=300 ==> 300 * 64 = 19200
-      PARAMETER (NDIMSC = 19200)
+C      PARAMETER (NDIMSC = 19200)
+      PARAMETER (NDIMSC = NMAX * 64)
       DIMENSION SCRATCH(NDIMSC)
 
 C***  Array for special for the Use in DEC-DXML-Routines 
@@ -44,7 +46,7 @@
       IF (CKEY(1:3) .EQ. 'OWN' .OR. CKEY(1:4) .EQ. 'OWNL') THEN
         CALL OWNINV(N, NDIM, A, CKEY) 
       ELSE
-          if (ndim .gt. 300) then
+          if (ndim .gt. NMAX) then
             write (0,*) '*** obsolete program branch'
             write (0,*) '*** check DIMENSION SCRATCH'
             stop '*** FATAL ERROR in SUBR. INV' 
diff -bur ./isamax.f ../../powr-refactor/src/isamax.f
--- ./isamax.f	2024-07-28 13:13:35.000000000 +0200
+++ ../../powr-refactor/src/isamax.f	2023-11-21 10:10:55.289269787 +0100
@@ -1,24 +1,19 @@
       FUNCTION ISAMAX (N, X, INC)
-C***  Find index of vector element with highest absolute value
-      DIMENSION X(N)
-
-ccc   The following call works with our intel compiler
-ccc   with gfortran one might need to add the library -lbas as option
 
       ISAMAX = IDAMAX (N, X, INC)
 
-C***  If IDAMAX is still not found, one can comment the above call
-C***  and activete the following hand-made version
+c      DIMENSION X(N)
+
 c      XMAX = ABS(X(1))
 c      IMAX = 1
-c
+
 c      DO I=2*INC, N, INC
 c        IF (ABS(X(I)) .GT. XMAX) THEN
 c          XMAX = ABS(X(I))
 c          IMAX = I
 c        ENDIF
 c      ENDDO
-c
+
 c      ISAMAX = IMAX
 
       RETURN
Only in .: jcuopen (1).f
Only in .: jlderiv (1).f
Only in .: jstart (1).f
diff -bur ./jstart.f ../../powr-refactor/src/jstart.f
--- ./jstart.f	2024-07-28 13:13:36.000000000 +0200
+++ ../../powr-refactor/src/jstart.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,48 +1,46 @@
-      SUBROUTINE JSTART (NF,XLAMBDA, ND,R,T,XJC,XJL,ELEVEL, N,EINST,
+      SUBROUTINE JSTART (NF,XLAMBDA,KEY,ND,R,T,XJC,XJL,ELEVEL, N,EINST,
      $                NDIM, INDNUP, INDLOW, LASTINDALL, LASTIND,
-     >                NAUTO, WSTABIL, R23, TAUROSS, LTESTART, BLACKEDGE, 
-     >                KRUDAUT)
+     >                   NAUTO, WSTABIL, R23, TAUROSS, 
+     >                   LTESTART, BLACKEDGE, bOLDJ, XJCold, XLAMBDAold, Rold,
+     >                   NFold, NDold, KRUDAUT)
 C******************************************************************************
 C***  START APPROXIMATION OF THE RADIATION FIELD
 C***  XJC: CONTINUUM RADIATION FIELD
 C***  XJL: LINE RADIATION FIELD
 C******************************************************************************
  
-      DIMENSION XLAMBDA(NF)
-      DIMENSION R(ND), T(ND), XJC(ND), XJL(ND), TAUROSS(ND)
-      DIMENSION ELEVEL(NDIM),EINST(NDIM,NDIM)
-      DIMENSION INDNUP(LASTINDALL),INDLOW(LASTINDALL)
-      DIMENSION WSTABIL(NAUTO), KRUDAUT(NAUTO)
-      LOGICAL LTESTART
-      DIMENSION XJSP(4), TAUSP(4)
+      INTEGER, INTENT(IN) :: NFold, NDold, LASTIND, LASTINDALL, NAUTO, ND, NF
+      REAL, DIMENSION(NF) :: XLAMBDA
+      CHARACTER(8), DIMENSION(NF) :: KEY
+      REAL, DIMENSION(ND) :: R, T, XJC, XJL, TAUROSS
+      REAL, DIMENSION(NDIM) :: ELEVEL
+      REAL, DIMENSION(NDIM, NDIM) :: EINST
+      INTEGER, DIMENSION(LASTINDALL) :: INDNUP, INDLOW
+      INTEGER, DIMENSION(NAUTO) :: KRUDAUTO
+      REAL, DIMENSION(NAUTO) :: WSTABIL
+      REAL, DIMENSION(NDold) :: Rold
+      REAL, DIMENSION(NFold) :: XLAMBDAold
+      REAL, DIMENSION(NDold,NFold) :: XJCold
+      CHARACTER(8) :: NAME
+      REAL, DIMENSION(4) :: XJSP, TAUSP
 
-      CHARACTER*8 NAME
+      LOGICAL :: LTESTART, bOLDJ
 
 C***  Find temperature at tau = 2/3
       CALL LIPO (T23, R23, T, R, ND)
 
-C***  Construct vector with 4 elements for spline interpolation
-C***   in order to smooth over the tau=1 discontinuity 
-
-C***  This feature must be skipped if TAUROSS is not monotonic
-      DO I=2, ND
-         IF (TAUROSS(I) .LE. TAUROSS(I-1)) THEN
-            WRITE (0,*) 'WARNING: TAUROSS not strictly monotonic'
-            NSP = 0
-            GOTO 1
-         ENDIF
-      ENDDO
-
-C***  Find first depth index with tau > 1.5
+C***  Find depth index inside tau = 1
       L1  = ISRCHFGT(ND,TAUROSS, 1, 1.5)
-      IF (L1 .EQ. 0) L1 = ND
+      IF (L1 .EQ. 0) L1 = ND-1
 
 C***  Find depth index outside tau = 1/3
       L13 = ISRCHFGT(ND,TAUROSS, 1, 0.333333)
       IF (L13 .GT. 1) L13 = L13 - 1
       IF (L13 .EQ. 0) L13 = 1
 
-      IF (L13 .EQ. 1 .OR. L1 .EQ. ND .OR. L13 .GE. L1) THEN 
+C***  Construct vector with 4 elements for spline interpolation
+C***   in order to smooth over the tau=1 discontinuity 
+      IF (L13 .EQ. 1 .OR. L1 .GE. (ND-1)) THEN 
          NSP = 0
       ELSE
          NSP = 4
@@ -55,7 +53,6 @@
          TAUSP(3) = TAUROSS(ISP3)     
          TAUSP(4) = TAUROSS(ISP4)     
       ENDIF
-    1 CONTINUE
 
 C***  CONTINUUM RADIATION FIELD XJC  *****************************************
 C***  LOOP OVER ALL CONTINUUM FREQUENCY POINTS
@@ -63,8 +60,28 @@
       DO 6 K=1,NF
       XLAM=XLAMBDA(K)
  
+      IF (bOLDJ) THEN
+C***     BRANCH FOR XJC FROM OLD MODEL
+         DO L=1, ND
+C***       Determine the corresponding depth point in the old model
+C***       (This could be optimized with a more precise interpolation)
+           lofind: DO LL=1, NDold
+             IF (R(L) >= Rold(LL)) THEN
+               Lold = LL
+               EXIT lofind
+             ENDIF
+           ENDDO lofind
+           WN = 1.E8/XLAM
+           IF (XLAM < XLAMBDAold(1)) THEN
+             XJC(L) = MIN(XJCold(L,1), BNUE(XLAM, T(L)))
+           ELSEIF (XLAM > XLAMBDAold(NFold)) THEN 
+             XJC(L) = MIN(XJCold(L,NFold), BNUE(XLAM, T(L))) 
+           ELSE
+             CALL XRUDI (XJC(L),WN,XJCold,XLAMBDAold,NDold,NFold,Lold)
+           ENDIF
+         ENDDO
+      ELSEIF (LTESTART) THEN
 C***  BRANCH FOR LTESTART
-      IF (LTESTART) THEN
          DO L=1,ND
            XJC(L)=BNUE(XLAM,T(L))
            IF (R(L) > R23 .AND. XLAM < BLACKEDGE) THEN
@@ -124,8 +141,22 @@
         ENDIF
 
 C***  THIS VERSION: SAME APPROXIMATION AS FOR CONTINUUM
-C***   BRANCH FOR LTE
-      IF (LTESTART) THEN
+        IF (bOLDJ) THEN
+C***      Branch for old radiation field: Just interpolate XJC from above
+          DO L=1,ND
+C***        Determine the corresponding depth point in the old model
+C***        (This could be optimized with a more precise interpolation)
+            lofind2: DO LL=1, NDold
+              IF (R(L) >= Rold(LL)) THEN
+                Lold = LL
+                EXIT lofind2
+              ENDIF
+            ENDDO lofind2
+            WN = 1.E8/XLAM
+            CALL XRUDI (XJL(L),WN,XJCold,XLAMBDAold,NDold,NFold,Lold)
+          ENDDO        
+        ELSEIF (LTESTART) THEN
+C***      BRANCH FOR LTESTART
          DO L=1,ND
             XJL(L)=BNUE(XLAM,T(L))
             IF (R(L) > R23 .AND. XLAM < BLACKEDGE) THEN
Only in .: jsymset (1).f
Only in .: kholtsmark (1).f
Only in .: ksigma (1).f
Only in .: lcore (1).f
diff -bur ./lcore.f ../../powr-refactor/src/lcore.f
--- ./lcore.f	2024-07-28 13:13:37.000000000 +0200
+++ ../../powr-refactor/src/lcore.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,13 +1,19 @@
       SUBROUTINE LCORE (XRED,XBLUE,GAMMAL,LASTIND,INDLOW,INDNUP,
-     $      GAMMAR,IPRILC,MODHEAD,JOBNUM,OPALOLD,
+     $      GAMMAR,IPRILC,MODHEAD,JOBNUM,OPALOLD,LASTINDAUTO,
+     >      XLAMAPPMEAN, ALOMIN, bUSEALO, bLAMAPPCOLI,
      $      L,ND,VELO,GRADI,RADIUS,SLOLD,XMAX,ERXMIN,
-     $      VDOP,RSTAR,ENTOT,EN,NF,XLAMBDA,ELEVEL,NOM,
+     $      VDOPUNIT,RSTAR,ENTOT,EN,NF,XLAMBDA,ELEVEL,NOM,
      $      NDIM,N,NCHARG,WEIGHT,EINST,LINE,NSCHAR,BDIAG,GAMMAD)
 C*******************************************************************************
 C***  DETERMINATION OF THE CMF-FREQUENCIES XRED, XBLUE WHICH CONFINE THE
 C***  OPTICALLY THICK LINE CORES
 C*******************************************************************************
  
+      INTEGER, INTENT(IN) :: LASTIND, LASTINDAUTO
+      REAL, INTENT(IN) :: ALOMIN
+
+      REAL, DIMENSION(ND, LASTINDAUTO) :: XLAMAPPMEAN
+
       COMMON / COMFUN / DELTAV,XMIN
       LOGICAL LINE(2)
       DIMENSION TAUMIN(0:2),GAMPRI(0:2)
@@ -21,37 +27,46 @@
       DIMENSION INDLOW(LASTIND),INDNUP(LASTIND),OPALOLD(LASTIND)
       INTEGER NSCHAR
 
-      LOGICAL BDIAG(LASTIND)
+      REAL :: DELTAV, XMIN
+
+      LOGICAL, DIMENSION(LASTINDAUTO), INTENT(INOUT) :: bUSEALO
+      LOGICAL, DIMENSION(LASTIND) :: BDIAG
+
+      LOGICAL :: bLAMAPPCOLI     !.true. if CARDS line XJLAPP COLI has been set
 
 C***  BRANCH FOR GAMMAL=0 : LINE CORES ARE ZERO
       IF (GAMMAL.LE..0 .AND. GAMMAR.LE..0 .AND. GAMMAD.LE..0) THEN
-      DO 1 IND=1,LASTIND
+        DO IND=1,LASTIND
       XRED(IND)=.0
       XBLUE(IND)=.0
-      SLOLD(IND)=UNDEF
-    1 CONTINUE
+          bUSEALO(IND) = .FALSE.
+          SLOLD(IND)=TRANSFER('UNDEF', SLOLD(IND))
+        ENDDO
       RETURN
       ENDIF
  
 C***  BRANCH FOR GAMMAL .NE. .0
 C***  VL = VELOCITY IN DOPPLER UNITS ,  GL = GRADIENT IN DOPPLER UNITS
-      VL=VELO(L)/VDOP
-      GL=GRADI(L)/VDOP
+      VL=VELO(L)/VDOPUNIT
+      GL=GRADI(L)/VDOPUNIT
       RL=RADIUS(L)
-      DO 3 IND=1,LASTIND 
+      
+      DO IND=1, LASTIND !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       LOW=INDLOW(IND)
       NUP=INDNUP(IND)
       XRED(IND)=0.
       XBLUE(IND)=0.
-      SLOLD(IND)=UNDEF
+        
+        SLOLD(IND)=TRANSFER('UNDEF', SLOLD(IND))
       OPALOLD(IND)=.0
 C***  IRON: OMIT LINES TREATED WITH DIAGONAL OPERATOR, LASER CHECK
       IF (BDIAG(IND)) THEN
          XLAM=1.E8/(ELEVEL(NUP)-ELEVEL(LOW))
          CALL LIOP (EINST(NUP,LOW),WEIGHT(LOW),WEIGHT(NUP),LOW,NUP,
-     $              1,XLAM,ENTOT(L),EN,RSTAR,OPALOLD(IND),ETAL,VDOP)
+     >               1,XLAM,ENTOT(L),EN,RSTAR,OPALOLD(IND),ETAL,
+     >               VDOPUNIT)
          IF (OPALOLD(IND) .LE. .0) THEN
-            SLOLD(IND)= UNDEF
+            SLOLD(IND)=TRANSFER('UNDEF', SLOLD(IND))
             GOTO 2
          ELSE
 C***        Note: This setting of XBLUE is used as a switch for DERIV
@@ -73,7 +88,27 @@
             GAMMA=GAMMAL
          ENDIF
       ENDIF
-      IF (GAMMA .LE. .0) GOTO 2
+        IF (GAMMA .LE. .0) THEN
+          IF (bLAMAPPCOLI) THEN
+            XLAMAPPMEAN(L, IND) = 0.
+            IF (.NOT. BDIAG(IND)) bUSEALO(IND) = .FALSE.
+          ENDIF
+          GOTO 2
+        ELSEIF (bLAMAPPCOLI) THEN
+C***    For Gamma damping, we first transformed into
+C***      a TAU-like quantity, then reduce and transform back
+C***      BOUNDARIES: No amplification
+          IF (L == 1 .OR. L == ND) THEN
+            XLAMAPPMEAN (L, IND) = .0
+c            bUSEALO(IND) = .FALSE.
+          ELSE
+            TAU = -ALOG(1.-XLAMAPPMEAN(L,IND))
+            XLAMAPPMEAN(L, IND) = 1. - EXP(-TAU/GAMMA)
+            XLAMAPPMEAN(L, IND) = MAX(0., XLAMAPPMEAN(L, IND))
+            IF (XLAMAPPMEAN(L, IND) < ALOMIN) XLAMAPPMEAN(L, IND) = .0
+          ENDIF
+      
+        ENDIF
 
 C***  RUDIMENTAL LINES : CORE IS SET TO ZERO
       IF (EINST(LOW,NUP) .EQ. -2.) GOTO 2
@@ -83,42 +118,53 @@
 C***  LINES WHICH WERE NOT TREATED IN THE RADIATION TRANSFER
 C***  ARE ASSUMED TO HAVE ZERO CORE
       IF (.NOT.LINE(IND)) GOTO 2
-      XLAM=1.E8/(ELEVEL(NUP)-ELEVEL(LOW))
+        
 C*** CALCULATE LINE OPACITY OPAL AT CURRENT DEPTH POINT AND LINE
+        XLAM=1.E8/(ELEVEL(NUP)-ELEVEL(LOW))
       CALL LIOP (EINST(NUP,LOW),WEIGHT(LOW),WEIGHT(NUP),LOW,NUP,
-     $    1,XLAM       ,ENTOT(L),EN,RSTAR,OPALOLD(IND),ETAL,VDOP)
+     >             1, XLAM, ENTOT(L),EN,RSTAR,OPALOLD(IND),ETAL,
+     >             VDOPUNIT)
 C***  LASER SECURITY : CORE OF LASER LINES ARE SET TO ZERO
       IF (OPALOLD(IND) .LE. .0) GOTO 2
+      
 C***  IF AMBIENT CONTINUUM IS OPTICALLY THICK : 
-C***  RADIAL DIRECTION -------------------------------------------------
+C***    RADIAL DIRECTION -----------------------------------------------
       TAU=OPALOLD(IND)/GL
       GDT=GAMMA /TAU
-      DV1=VELO(1)/VDOP - VL
-      DVND=VL - VELO(ND)/VDOP
+        DV1=VELO(1)/VDOPUNIT - VL
+        DVND=VL - VELO(ND)/VDOPUNIT
       DELTAV=AMIN1(DV1,DVND)
       CALL COFREQ (XRR,XBR,XMAX,ERXMIN,GDT   ,THIN)
       IF (THIN) GOTO 2
-C***  TRANSVERSAL DIRECTION  -------------------------------------------
+        
+C***    TRANSVERSAL DIRECTION  -----------------------------------------
       R1=RADIUS(1)
       TAUT=OPALOLD(IND)*RL/VL
       GDT=GAMMA /TAUT
-      DELTAV=SQRT(1.-RL*RL/R1/R1)*VELO(1)/VDOP
+        DELTAV=SQRT(1.-RL*RL/R1/R1)*VELO(1)/VDOPUNIT
       CALL COFREQ (XRT,XBT,XMAX,ERXMIN,   GDT,THIN)
       IF (THIN) GOTO 2
-C***  FIND THE MINIMUM CORE FROM BOTH DIRECTIONS -----------------------
+        
+C***    FIND THE MINIMUM CORE FROM BOTH DIRECTIONS ---------------------
       XRED(IND)=AMAX1(XRR,XRT)
       XBLUE(IND)=AMIN1(XBR,XBT)
 C***  STORE OLD LINE SOURCE FUNCTION
-    6 SLOLD(IND)=ETAL/OPALOLD(IND)
+        SLOLD(IND)=ETAL/OPALOLD(IND)
+        
     2 CONTINUE
+C***    Non-core lines should not be considered for ALO (except IRON)
+        IF (XRED(IND) >= XBLUE(IND) .AND. .NOT. BDIAG(IND)) THEN
+c          IF (.NOT. bLAMAPPCOLI) bUSEALO(IND) = .FALSE.
+        ENDIF
+
 C***  STORE OPTICAL DEPTHS FOR PRINTOUT
-      DO 4 I=0,2
+        DO I=0,2
       IF (IND .EQ. IPRILC+I) THEN
             TAUMIN(I)=OPALOLD(IND)/AMAX1(GL,VL/RL)
             GAMPRI(I)=GAMMA
             ENDIF
-    4 CONTINUE
-    3 CONTINUE
+        ENDDO
+      ENDDO  !End of large IND loop ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
       IF (IPRILC .GT. 0)
      $      CALL PRILC (IPRILC,LASTIND,XRED,XBLUE,TAUMIN,L,ND,ERXMIN,
Only in .: lengthms (1).f
diff -bur ./lengthms.f ../../powr-refactor/src/lengthms.f
--- ./lengthms.f	2024-07-28 13:13:38.000000000 +0200
+++ ../../powr-refactor/src/lengthms.f	2023-12-04 09:16:53.969561991 +0100
@@ -4,7 +4,7 @@
 C************************************************************
 
       CALL CMSSTORE (ICHANNEL, IDUMMY, IDUMMY, NAME, NDUMMY, XDUMMY, 
-     >               NDIM, 'LENGTH', IERR)
+     >               NDIM, 'LENGTH  ', IERR)
 
       RETURN
       END
Only in .: levelcards (1).f
diff -bur ./levelcards.f ../../powr-refactor/src/levelcards.f
--- ./levelcards.f	2024-07-28 13:13:38.000000000 +0200
+++ ../../powr-refactor/src/levelcards.f	2023-09-27 10:14:15.109755551 +0200
@@ -3,7 +3,7 @@
 C***  creates LEVEL Cards from comparing DATOM with DATOM_OLD
 C***************************************************************
 
-      PARAMETER (NDIM = 2560)
+      PARAMETER (NDIM = 1560)
       CHARACTER*10 OLDLEVEL(NDIM), NEWLEVEL(NDIM)
       CHARACTER*80 LINE, OUTLINE(NDIM)
       CHARACTER*20 ACTPAR
Only in .: limbdark_output (1).f
Only in .: limbdark_prep (1).f
Only in .: limb_info (1).f
Only in .: linpop (1).f
diff -bur ./linpop.f ../../powr-refactor/src/linpop.f
--- ./linpop.f	2024-07-28 13:13:39.000000000 +0200
+++ ../../powr-refactor/src/linpop.f	2024-07-22 09:27:16.104033925 +0200
@@ -1,11 +1,11 @@
       SUBROUTINE LINPOP (T,RNE,ENTOT,ITNE,POPNUM,DEPART,POPLTE,POP1,
      >   N,ENLTE,WEIGHT,NCHARG,EION,ELEVEL,EN,EINST,LEVEL,
      >   FWEIGHT,XJC,NF,XJL,WCHARM,SCOLD,
-     >   XJLAPP,
-     >   DM, V1,V2,GAMMAC,GAMMAL,EPSILON,
+     >   XJLAPP, XLAMAPPMEAN, bUSEALO, ALOMIN, bLAMAPPCOLI,
+     >   DM, V1,V2,GAMMAC,GAMMAL,EPSILON,TOLD,
      >   NOTEMP,DELTAC,GAMMAR,IPRICC,IPRILC,MODHEAD,JOBNUM,IFRRA,ITORA,
      >   RADIUS,RSTAR,OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,
-     >   VELO,GRADI, VDOP,NFLDIM,PHI,PWEIGHT,
+     >   VELO,GRADI,VDOPDD,VDOPUNIT,NFLDIM,PHI,PWEIGHT,
      >   LASTIND, LASTINDAUTO, LASTINDALL, 
      >   SIGMAKI,
      >   ND,LSRAT,CRATE,RRATE,RATCO,ALPHA,SEXPO, 
@@ -19,9 +19,9 @@
      >   SIGMATHK,SEXPOK,EDGEK,XDATA,
      >   KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,LASTKDR,KEYCBF,NATOUT,
      >   BRRESET,NOCON,ENOLD,TEFF,
-     >   KRUDAUT, ELEMENT, 
-     >   BAUTO, BAUTO_ABORT, CKONVER, SMALLPOP, BUNLU, 
-     >   DENSCON, FILLFAC, ENTOTDENS,
+     >   KRUDAUT, 
+     >   BAUTO, CKONVER, SMALLPOP, BUNLU, 
+     >   FILLFAC, ENTOTDENS,
      >   WFELOW, WFENUP, GAMMAD, NKONVER, WJC, 
      >   OPC, BPLOCC, LPLOCC, KPLOCC, KANAL, 
      >   LASTFE, WJCMIN, NKONV_THRESH,
@@ -48,14 +48,13 @@
      >   IFF_MAX, IFF_MAX_MS, FF_INFO, IFF_DK, IFF_WCHARM, WCHARM_FINE, 
      >   IFF_N_MS,
 C***  Split artistic
-     >   bBLOCKINVERSION, AOFF, CORRLAST, bRELSCHARMERACC,
-C***  Settings for ZERO_RATES (not yet implemented), BROYDEN TWOPOINT, and AUTO_MODIFY
-     >   iZRType, bUseTWOPNT, iAMT,
-C***  Fe rate temperature correction
-     >   CORRS, DEXFAC, bFeTCORR,
+     >   iBLOCKINVERSION, AOFF, CORRLAST, bRELSCHARMERACC, bFRACINV,
+C***  Fe rate and Zero Rate settings
+     >   CORRS, DEXFAC, bFeTCORR, iZRType,
+C***  Two-point broyden and auto modify temperature settings
+     >   bUseTWOPNT, iAMT, 
 C***  Contants consitence check
      >   NDIM_steal, MAXIND_steal, NFDIM_steal, MAXFEIND_steal)
-
 C*******************************************************************************
 C***  CALCULATION OF NEW NLTE POPULATION NUMBERS (ARRAY POPNUM)
 C***  RADIATIVE RATES ARE CALCULATED WITH THE SCHARMER RADIATION FIELD
@@ -75,16 +74,18 @@
 
       IMPLICIT NONE
 
-      INTEGER, PARAMETER :: MAXIND  =       45000 
-      INTEGER, PARAMETER :: NDIM    =        2560 
-      INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400
+      INTEGER, PARAMETER :: NDIM    =        2560   !must be exactly as in STEAL
+      INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400  !must be exactly as in STEAL
+      INTEGER, PARAMETER :: MAXIND  =       45000   !must be exactly as in STEAL
+      INTEGER, PARAMETER :: MAXFEIND  =       2500  !must be exactly as in STEAL
+      
 
-      INTEGER, PARAMETER :: MAXFEIND  =       2500 
 
       INTEGER, INTENT(IN) :: ND, NDDIM, N, NF, JOBNUM, MAXION, NFLDIM,
      >                       MAXLAP, NATOM, LASTKDR, MAXFINE, INDEXMAX,
      >                       IFF_MAX, IFF_MAX_MS, MAXATOM, LASTKON,
-     >          LASTIND, MAXAUTO, LASTINDAUTO, LASTINDALL, NKONV_THRESH
+     >                       LASTIND, MAXAUTO, LASTINDAUTO, LASTINDALL,
+     >                       NKONV_THRESH
 
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
      >                                IFENUP, IFELOW, INDFEACT
@@ -99,6 +100,7 @@
       REAL, DIMENSION(MAXIND) :: XRED, XBLUE, SLOLD, DETAL, OPAL, 
      >                           SLNEW, DOPAL, SCOLIND, SCNEIND,
      >                           OPACIND, XRED0, XBLUE0, OPALOLD
+      LOGICAL, DIMENSION(LASTINDAUTO) :: bUSEALO
       REAL, DIMENSION(4, MAXIND) :: COCO
 
       COMMON /COMIND/  INDNUP, INDLOW, XRED,XBLUE, SLOLD, DETAL, OPAL,
@@ -120,18 +122,20 @@
       REAL, DIMENSION(NDDIM) :: OPAFE, ETAFE
       REAL, DIMENSION(ND, N) :: POPNUM, POP1, POPLTE, DEPART
       REAL, DIMENSION(ND) :: ENLTE, RNE, T, ENTOT, OPA, ETA, VELO,
-     >                       GRADI, THOMSON, CORRS
+     >                       GRADI, THOMSON, CORRS, TOLD
       INTEGER, DIMENSION(ND) :: ITNE, IWARN
       REAL, DIMENSION(NDIM) :: ELEVEL, EION, DRRATEN, RDIEL, RAUTO,
      >                         DRJLW, DRJLWE, DRLJW
       REAL, DIMENSION(NDIM+2) :: V1, V2, EN, BRS, BRSP, BRY, DTEST
       REAL, DIMENSION(4, NDIM) :: ALTESUM
-      INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND
+      INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND, 
+     >                            NBSTART, NBEND, NBATOM
       REAL, DIMENSION(NDIM, NDIM) :: EINST, CRATE, RRATE
       REAL, DIMENSION(NDIM+2,NDIM+2) :: RATCO, DM, AOFF, 
      >                                  ATEST, BTEST, SCRATCH
 
       REAL, DIMENSION(ND,LASTINDALL) :: XJL
+      REAL, DIMENSION(ND,LASTINDAUTO) :: XLAMAPPMEAN
       REAL, DIMENSION(ND, 5) :: XJL_PLOTDATA
       REAL, DIMENSION(ND, 4) :: XJC_PLOTDATA_I
 
@@ -145,18 +149,17 @@
       REAL, DIMENSION(NF,ND) :: SCOLD
       REAL, DIMENSION(NF,0:MAXION) :: SIGMAFF
       REAL, DIMENSION(NF) :: FWEIGHT
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: EDGEK, SIGMATHK, SEXPOK
+      REAL, DIMENSION(MAXATOM,MAXION) :: EDGEK, SIGMATHK, SEXPOK
       REAL, DIMENSION(MAXATOM) :: ABXYZ
       INTEGER, DIMENSION(MAXATOM) :: IMAXPOP
-      INTEGER, DIMENSION(NATOM) :: NFIRST, NLAST, KODAT
+      INTEGER, DIMENSION(NATOM) :: NFIRST, NLAST, KODAT, NBFirstIon
 
       REAL, DIMENSION(N+2) :: EN1
       INTEGER, DIMENSION(N) :: NOM
       REAL, DIMENSION(ND,LASTIND) :: WFELOW, WFENUP
-      LOGICAL :: BRDIVFAILED, BMONOTONIC, bFeTCORR
-      LOGICAL, DIMENSION(MAXIND) :: BDIAG, RUDLINE
+      LOGICAL :: BRDIVFAILED, bRELSCHARMERACC, bFRACINV, bFeTCORR
+      LOGICAL, DIMENSION(MAXIND) :: LINE, BLASERL, BDIAG, RUDLINE
       LOGICAL, DIMENSION(LASTKON) :: NRB_CONT
-      LOGICAL, DIMENSION(MAXIND) :: LINE, BLASERL
       INTEGER, DIMENSION(MAXIND) :: LINEINDEX, NUPACT, LOWACT
       REAL, DIMENSION(MAXIND) :: XLAMZERO, XLAMSOR, XLAMMIN, XLAMMAX,
      >                           ETAL, XKMIN, XKMAX, XKMID, XKRED, 
@@ -175,6 +178,7 @@
 
       REAL, DIMENSION(MAXFINE) :: SFINE_OLD, SFINE_NEW
       REAL, DIMENSION(INDEXMAX) :: SIGMAFE
+      REAL, DIMENSION(ND, NATOM), INTENT(IN) :: VDOPDD
 
       REAL, DIMENSION(1) :: ALPHA, SEXPO, ADDCON1, ADDCON2, ADDCON3, 
      >                      XDATA
@@ -183,7 +187,6 @@
       CHARACTER(4), DIMENSION(MAXIND) :: KEYCBB
       CHARACTER(10), DIMENSION(N) :: LEVEL
       CHARACTER(10), DIMENSION(ND) :: MAINPRO, MAINLEV
-      CHARACTER*10 ELEMENT(NATOM)
 
       LOGICAL, DIMENSION(N,ND) :: ZERO_RATES
       INTEGER, DIMENSION(NDIM) :: NZERORATES, LMINZERORATES, LMAXZERORATES
@@ -196,28 +199,30 @@
      >           NPLUS1, NPLUS2, NOUT, ITBR, NBRCANC, NKONVER, IADR16,
      >           INEGMIN, INEGMAX, LNEGMIN, LNEGMAX, NEGINTL, NEGINTC,
      >           INEGMINC, INEGMAXC, LNEGMINC, LNEGMAXC, NFL, KANAL, LL,
-     >           KON, NUP, LOW, LPLOCC, KPLOCC, ICOUNT, NA, NFIRNA, NF2,
+     >           KON, NUP, LOW, LPLOCC, KPLOCC, NA, NFIRNA, NF2,
      >           NLANA, NSCHAR, ION, NAUTO, LASTFE, NLINE, MAXFEACT,
      >           IPLOT_XJCAPP, IPLOT_XJLAPP, LPLOT_XJCAPP, ITABS, IERR,
      >           NITER_PLOT_JAPP, IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP,
      >           IDUMMY, ldepth, LSRAT, IFRRA, ITORA, NETTO, LM1, 
      >           MINEX, MAXEX, IPRINTZERORATES, NATOUT,
+     >           iPopMinViolations, iBLOCK, NBLOCK, NChargeLast, 
      >           NDIM_steal, MAXFEIND_steal, NFDIM_steal, MAXIND_steal,
-     >           iPopMinViolations, iZRType, iAMT
+     >           nTest, iZRType, iAMT
       REAL :: RSTAR, GAMMAC, GAMMAD, GAMMAL, GAMMAR, DELTAC, EPSILON, 
-     >        EPSDN, TL, TOLD, EDGE, EDGELAM, ERXMIN, WJCMIN, DELTAX,
-     >        VDOP, VDOPFE, WAVENUM, XMAX, OPARL, FN, FNOLD, 
-     >        FTN, FTNOLD, TSAVE, TMID, DTDR, TEFF, TLAST,  
+     >        EPSDN, TL, TLOLD, EDGE, EDGELAM, ERXMIN, WJCMIN, DELTAX,
+     >        VDOPUNIT, VDOPFE, WAVENUM, XMAX, FN, FNOLD, 
+     >        FTN, FTNOLD, TEFF, ALOMIN,
      >        ENE, BRRESET, BRRES2, TLOG, ROOTTL, XLAM, XLAMLOG, W, W3,
      >        PRESIG, GIII, POPMIN, OPATHOM, DXFE, XLAM0FE, DFEINDR,
      >        SUM, ENMIN, ENMAX, ENNEW, XLAM_FINE_START, XLAM_FINE_END,
-     >        IFF_N_MS, SMALLPOP, CORRLAST      
+     >        IFF_N_MS, SMALLPOP, CORRLAST,
+     >        TLxj
 
 C***  Iteration Sequence output ("Scharmer-Tapete")
-      CHARACTER(1), DIMENSION(100) :: ITCODE        !@todo: warum nicht auf ND dimensionieren?
+      CHARACTER(1), DIMENSION(100) :: ITCODE        !@todo: warum nicht auf ITMAX dimensionieren?
 
 C***  tiefenabh. clumping nach goetz
-      REAL, DIMENSION(NDDIM) :: DENSCON, FILLFAC
+      REAL, DIMENSION(NDDIM) :: FILLFAC
 
 C***  AUTO_MODIFY FACILITY
       CHARACTER(3) :: CHR
@@ -230,13 +235,17 @@
       CHARACTER(80) :: CHR1, CHR2
       CHARACTER(100) :: MODHEAD
       LOGICAL :: KONVER, NOTEMP, BROYDEN, TWOPNT, NOCON, BNUEFE,
-     >           BRIMP, BRIMP2, BAUTO, BAUTO_ABORT, BNEWTONRESET,
+     >           BRIMP, BRIMP2, BAUTO, BNEWTONRESET,
      >           BSUM, BUNLU, BPLOCC, BFECHECK, BFEWING, BFEMODEL,
      >           BXJLAPPNEW, BXJCAPPNEW, BXJLAPPCORE, BNEWOPER,
-     >           BPLOTAPP, bFFASSET, bRELSCHARMERACC, bUseTWOPNT 
+     >           BPLOTAPP, bFFASSET, bUseTWOPNT 
+
+C***  SETXJL switch (in COMA)    
+      LOGICAL :: bLAMAPPCOLI
 
 C***  Split switch
-      LOGICAL :: bBLOCKINVERSION, bUseDMFILE
+      INTEGER :: iBLOCKINVERSION
+      LOGICAL :: bUseDMFILE
 
 C***  Warning counter for negative line opacities --> PRICORR
       COMMON / COMNEGI / NEGINTL,INEGMIN,INEGMAX,LNEGMIN,LNEGMAX
@@ -259,6 +268,7 @@
 C***  Physical Constants
       REAL, PARAMETER :: C1 = 1.4388        !C1 = H * C / K    ( CM * KELVIN )
       REAL, PARAMETER :: CFF = 1.370E-23    !CFF = COEFFICIENT FOR FREE-FREE CROSS SECTION ( ALLEN P.100 )
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5      !Stephan-Boltzmann constant (CGS) / Pi
 
       bUseDMFILE = .TRUE.                   !Default: DMFILE is used
       iPopMinViolations = 0
@@ -304,55 +314,10 @@
 C      EPSDN = MAX(EPSILON, CORRLAST) * 0.03
 C     but CORRLAST does not exist in the wrh branch
 
-C--------------- additional stuff from goetz ---------------------
 C***  Increase SMPOP for outer Depth Points
       NOUT = 20
       IF (NOUT .GT. ND/2) NOUT = ND/2
       
-CC***  Set T and TNEW:  TEMPEQ Branch is dead --> NOTEMP = .TRUE.
-CC***  ---------------
-C      NOTEMP = .TRUE.
-CC***  No T-Corrections:
-C      IF (.NOT. BUNLU) TNEW = T
-
-CC***  For TNEW:
-CC***  RECOVER THE DIFFUSION APPROX. AT THE INNER BOUNDARY
-C      IF (BTND) THEN
-C         TNDM  = TNEW(ND-1)
-C         TND   = TNEW(ND)
-C         TSAVE = TND
-C
-C         IF (OPARND .GT. 0.) THEN
-C            OPARL = OPARND
-C            WRITE (0,*) 'LINPOP: OPARND=', OPARND
-C         ELSE
-C            CALL OPAROSS(OPARL,EN,TND,RNE(ND),ENTOTDENS(ND),RSTAR,
-C     >                  NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
-C     >                  ALPHA,SEXPO,ADDCON1, ADDCON2, ADDCON3, 
-C     >                  IGAUNT,NF,XLAMBDA,FWEIGHT,NOM,
-C     >                  MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,RADIUS(ND),
-C     >                  KONTNUP,KONTLOW,LASTKON,BXSFINE,NXAPP,XSAPP,X0)
-CC***        Scale opacity down with filling factor
-C            OPARL = OPARL * FILLFAC(ND)
-C         ENDIF
-C
-C         TBAR = TNDM / TEFF
-C         DR   = RADIUS(ND-1)-RADIUS(ND)
-C            
-C         PP   = TBAR / DR / 3.
-C         QQ   = OPARL / DR / TBAR / TBAR / 8.
-C         DTDR = TEFF * (-PP +SQRT(PP*PP + QQ))
-C            
-C         TND  = TNDM + DR * DTDR
-C            
-C         TNEW(ND)= TND
-C         TNDCORR = (TND-TSAVE) / TND
-C      ELSE
-C
-C         TNDCORR = 0.
-C      ENDIF
-C--------------- end of additional stuff from goetz --------------
-
 
       NPLUS1=N+1
       NPLUS2=N+2
@@ -361,7 +326,7 @@
 
 C***  Note:wrh SPLIT option does not reducde the rank (unlike goetz!)
 C***  implemented since May 2013 
-C***  bBLOCKINVERSION is set via CARDS line SPLITINVERSION
+C***  iBLOCKINVERSION is set via CARDS line SPLITINVERSION
  
 C***  ITERATION NUMBER WHERE BROYDEN UPDATING STARTS (MUST BE .GE. 1)
       IF (ITBR .EQ. 0) ITBR=ITMAX+1
@@ -388,6 +353,7 @@
 C***      NEWTON-RAPHSON ITERATIONS
       ITWARN=0 
       NOCON = .FALSE.
+      BRDIVFAILED = .FALSE.
 
 C***  REMOVE NEGATIVE LINE INTENSITIES
       NEGINTL=0
@@ -452,8 +418,8 @@
 C***  DETERMINE THE WEIGHT FUNCTION WCHARM FOR THE CONTINUUM, AND SCOLD
 C***  AT ALL DEPTH POINTS
       CALL CCORE (WCHARM,NF,GAMMAC,DELTAC,IPRICC,MODHEAD,JOBNUM,
-     >            SCOLD,RADIUS,XLAMBDA,ND,T,RNE,POP1,ENTOTDENS,RSTAR,
-     >            OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,
+     >            SCOLD,RADIUS,XLAMBDA,ND,T,RNE,POP1,POPMIN,ENTOTDENS,
+     >            RSTAR,OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,
      >            NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,SIGMAKI,
      >            MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,XDATA,
      >            KONTNUP,KONTLOW,LASTKON,FILLFAC, WJC, OPC, WJCMIN, 
@@ -494,17 +460,68 @@
         LMAXZERORATES(J) = 0
       ENDDO
 
-      IF (bBLOCKINVERSION) THEN
-        WRITE (hCPR,'(A)') ' DM Inversion: SPLIT'
+      IF (bLAMAPPCOLI) THEN
+        WRITE (hCPR,'(A)') ' ALO version: XJLAPP COLI'
+      ENDIF
+      IF (iBLOCKINVERSION > 1) THEN
+        WRITE (hCPR,'(A)') ' DM Inversion: SPLIT by ION'
+      ELSEIF (iBLOCKINVERSION == 1) THEN
+        WRITE (hCPR,'(A)') ' DM Inversion: SPLIT by ATOM'
       ELSE
         WRITE (hCPR,'(A)') ' DM Inversion: TOTAL'
       ENDIF
+      IF (bFRACINV) THEN
+        WRITE (hCPR,'(A)') ' POP Corrections: FRACTIONAL'
+      ELSE
+        WRITE (hCPR,'(A)') ' POP Corrections: TOTAL'
+      ENDIF
       IF (bFeTCORR) THEN
         WRITE (hCPR,'(A)') ' FERAT T Correction: ON'
       ELSE
         WRITE (hCPR,'(A)') ' FERAT T Correction: OFF'
       ENDIF
 
+C***  If SPLIT option is set, initialize block boundaries now
+      IF (iBLOCKINVERSION > 0) THEN
+        iBLOCK = 0.
+        IF (iBLOCKINVERSION == 2) THEN
+          !Determine ion blocks
+          DO na=1, NATOM
+            J = NFIRST(na)
+            NChargeLast = NCHARG(J)
+            iBLOCK = iBLOCK + 1
+            NBSTART(iBLOCK) = J
+            NBATOM(iBLOCK) = na
+            NBFirstIon(na) = iBLOCK
+            DO WHILE (J < NLAST(na))
+              J = J + 1
+              IF (NCHARG(J) /= NChargeLast) THEN
+                !different charge == new ion detected => new block
+                NBEND(iBLOCK) = J - 1
+                iBLOCK = iBLOCK + 1              
+                NBSTART(iBLOCK) = J
+                NBATOM(iBLOCK) = na
+                NChargeLast = NCHARG(J)
+              ENDIF
+            ENDDO
+            NBEND(iBLOCK) = J
+          ENDDO
+        ELSE
+          !Blocks are atom blocks
+          DO na=1, NATOM
+            iBLOCK = iBLOCK + 1
+            NBSTART(iBLOCK) = NFIRST(na)
+            NBEND(iBLOCK) = NLAST(na)
+            NBATOM(iBLOCK) = na
+          ENDDO
+        ENDIF
+        NBLOCK = iBLOCK
+      ELSE
+        NBLOCK = 1
+        NBSTART(1) = 1
+        NBEND(1) = NRANK
+      ENDIF
+      
       CALL LOAD_FF(ND, NDDIM, MODHEAD, JOBNUM, bFFASSET,
      >             FF_INFO, IFF_DK, IFF_N_MS, IFF_MAX_MS)
       
@@ -525,6 +542,7 @@
       EN(NPLUS1)=RNE(L)
       EN1(NPLUS1)=EN(NPLUS1)
       TL = T(L)
+      TLOLD = TOLD(L)
  
 C***  ERROR STOP, IF NEGATIVE TEMPERATURES ON THE MODEL FILE
       IF (TL .LE. .0) THEN
@@ -536,12 +554,12 @@
       ENDIF
 ccc   Here one might consider to apply TOLD -- now it is identical to TNEW
 ccc   TOLD is parameter of CALL COMA, goes to SETXJC and SETXJL
-      TOLD=TL 
+      TLxj=TL 
 
 C***  IRON: IRON-LINES ARE CALCULATED WITH DIAGONAL OPERATOR
       DO IND=1, LASTINDALL
          BDIAG(IND) = NOM(INDLOW(IND)) .EQ. KODAT(26)
-         IF (GAMMAD .GT. 0.) THEN
+         IF (BDIAG(IND) .AND. GAMMAD .GT. 0.) THEN
 ccc   Der Sinn BEIDER nachstehenden Daempfungs-Varienten ist dunkel ... 
 ccc     wrh, 18-Sep-2002 17:34:07
 cc            WFELOW(L,IND) = WFELOW(L,IND)*EXP(1.-GAMMAD)
@@ -552,6 +570,18 @@
             WFELOW(L,IND) = 0.
             WFENUP(L,IND) = 0.
          ENDIF
+
+        IF (IND <= LASTINDAUTO .AND. bLAMAPPCOLI) THEN
+C***      NULL ALO TERMS in CASE OF GAMMAR and GAMMAL = 0
+          bUSEALO(IND) = .TRUE.
+          IF (GAMMAL <= .0 .AND. GAMMAR <= .0 .AND. .NOT. BDIAG(IND)) THEN
+C**         Do not use ALO for line transitions if GAMMAs are switched off        
+            bUSEALO(IND) = .FALSE.
+            IF (bLAMAPPCOLI) THEN
+              XLAMAPPMEAN(L, IND) = 0.
+            ENDIF
+          ENDIF         
+        ENDIF
       ENDDO
 
 C***  DETERMINE THE CORE-CONFINING FREQUENCIES XRED, XBLUE OF THE LINES
@@ -560,9 +590,10 @@
 C***  This only holds if DENSCON = 1. / FILLFAC !!!
       IF (GAMMAL .GT. .0 .OR. GAMMAR .GT .0 .OR. L .EQ. 1) 
      >      CALL LCORE (XRED0,XBLUE0,GAMMAL,LASTIND,INDLOW,INDNUP,
-     >      GAMMAR,IPRILC,MODHEAD,JOBNUM,OPALOLD,
+     >      GAMMAR,IPRILC,MODHEAD,JOBNUM,OPALOLD,LASTINDAUTO,
+     >      XLAMAPPMEAN, ALOMIN, bUSEALO, bLAMAPPCOLI,
      >      L,ND,VELO,GRADI,RADIUS,SLOLD,XMAX,ERXMIN,
-     >      VDOP,RSTAR,ENTOT,EN,NF,XLAMBDA,ELEVEL,NOM,
+     >      VDOPUNIT,RSTAR,ENTOT,EN,NF,XLAMBDA,ELEVEL,NOM,
      >      NDIM,N,NCHARG,WEIGHT,EINST,LINE,NSCHAR,BDIAG,GAMMAD)
 
 C***  IN CASE OF NON-ZERO LINE CORES: 
@@ -670,9 +701,9 @@
      >      INDNUP,NOM,NATOM,KODAT,NFIRST,NLAST,PHI,PWEIGHT,DELTAX,XMAX,
      >      NFL,OPAC,SCNEW,DOPA,DETA,OPAL,SLNEW,DOPAL,DETAL,SIGMAKI,
      >      ETAC,NFEDGE,EXPFAC,SCOLIND,SCNEIND,OPACIND,SIGMAFF,MAXION,
-     >      NOTEMP,TOLD,KONTLOW,KONTNUP,LASTKON,RUDLINE,IONGRND,
-     >      XRED,XBLUE,WCHARM,EN,RSTAR,SCOLD,XJCAPP,VDOP,COCO, KEYCBB,
-     >      NRB_CONT, ZERO_RATES, POPMIN,
+     >      NOTEMP,TLxj,TLOLD,KONTLOW,KONTNUP,LASTKON,RUDLINE,IONGRND,
+     >      XRED,XBLUE,WCHARM,EN,RSTAR,SCOLD,XJCAPP,VDOPDD,VDOPUNIT,
+     >      COCO, KEYCBB, NRB_CONT, ZERO_RATES, POPMIN,
      >      IONAUTO,NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,DRRATEN,
      >      RDIEL,RAUTO,DRJLW,DRJLWE,DRLJW,IBLENDS,MAXLAP,XLAMZERO,
      >      KODRNUP,KODRLOW,LASTKDR,KEYCBF, OPALOLD,
@@ -681,6 +712,7 @@
      >      XJCLP1, OPAC1, RADIUS, ITNE(L), TEFF, OPATHOM, 
      >      LASTINDAUTO, LASTIND, KRUDAUT, LEVEL, 
      >   WFELOW, WFENUP, EN1, BDIAG, 
+     >      XLAMAPPMEAN, bLAMAPPCOLI, bUSEALO,
      >   FERATLU, FERATUL, LASTFE, FERATLU0, FERATUL0, 
 C*** Quantities for fine-frequency grid 
      >   SFINE_OLD, SFINE_NEW, MAXFINE, KONTHLP, MAXIND, XKC, XKC2,
@@ -702,14 +734,13 @@
      >   BPLOTAPP, PWEIGHTCL, WS, FWTEST, 
      >   IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP, 
      >   XJCAPPNEW, XJLAPPNEW, 
-     >   GAMMAC, GAMMAL, GAMMAR, 
-     >   XLAM_FINE_START, XLAM_FINE_END, IMAXPOP, bBLOCKINVERSION,
+     >   GAMMAC, GAMMAL, GAMMAR, GAMMAD,
+     >   XLAM_FINE_START, XLAM_FINE_END, IMAXPOP, iBLOCKINVERSION,
 C***  New Fine-spaced WCHARM handling
      >   IFF_MAX, IFF_MAX_MS, FF_INFO, IFF_DK, IFF_WCHARM, WCHARM_FINE, 
      >   IFF_N_MS, bFFASSET,
 C***  FERAT correction     
-     >   CORRS, DEXFAC, bFeTCORR)
-
+     >   bFRACINV, CORRS, DEXFAC, bFeTCORR, iZRType)
 
 C***  Update counters for ZERO_RATES
       IF (ITNE(L) .EQ. 1) THEN
@@ -825,12 +856,16 @@
           itcode(itne(l)) = 'N'
 C***      SOLVE THE LINEAR SYSTEM: >>  V2 * M = V1  << FOR V2
 
-          IF (bBLOCKINVERSION) THEN
-C***        matrix M (alias DM) is inverted block by block
-C           electron line will be ignored
+
+          IF (iBLOCKINVERSION > 0) THEN
+C***        since 28.05.2010 -> SPLIT-Variante ohne Elektronenzahluebergabe
+C           matrix M (alias DM) is inverted block by block
             CALL LINSOL_SPLIT (V2, DM, V1, NRANK, NRANK,
-     >                   NFIRST, NLAST, NATOM, AOFF,
-     >                   SCRATCH, ATEST, BTEST, DTEST, VERSION, ELEMENT)
+     >                         NFIRST, NLAST, NATOM, NBLOCK, AOFF,
+     >                         SCRATCH, ATEST, BTEST, DTEST, VERSION, 
+     >                         NBSTART, NBEND, NBATOM, NBFirstIon,
+     >                         IMAXPOP, ZERO_RATES, LEVEL, 
+     >                         iBLOCKINVERSION)
           ELSE
 C           matrix M (alias DM) is inverted as a whole
             CALL LINSOL (V2, DM, V1, NRANK, NRANK, 
@@ -843,6 +878,16 @@
             GOTO 420
           ENDIF        
 
+          IF (bFRACINV) THEN
+            DO J=1, NRANK
+              V2(J) = MIN(V2(J),  9.0)
+              V2(J) = MAX(V2(J), -0.9)
+              V2(J) = V2(J) * EN(J)
+            ENDDO
+C***        Do store only the version not modified for fractional corrections:
+            CALL SCALEDM(DM, EN, NRANK, .FALSE.)
+          ENDIF
+
 C*****************
         ENDIF
 C*****************
@@ -879,10 +924,13 @@
             iPopMinViolations = iPopMinViolations + 1
           ENDIF
         ENDDO
+        IF (bFRACINV) THEN
+          WRITE (0,*) 'EN(12) ', EN(12)
+        ENDIF
  
 C***    RE-ADJUST THE ELECTRON DENSITY (new suggestion from wrh: 11. Apr 2011)
-        !moved here at 10.10.2011
-        IF (bBLOCKINVERSION .AND. LASTIT == 'NEWTON') THEN
+C        !moved here at 10.10.2011
+        IF ((iBLOCKINVERSION > 0) .AND. LASTIT == 'NEWTON') THEN
           ENNEW=0.0
           DO j=1,N
             ENNEW = ENNEW + EN(j) * NCHARG(j)
@@ -907,12 +955,19 @@
           KONVER = .FALSE.
           IF (LASTIT .EQ. 'NEWTON' .OR. .NOT. BNEWTONRESET) THEN
             IF (.NOT. BRDIVFAILED) THEN
+              IF (SUM > 10.) THEN
               ITCODE(ITNE(L)) = 'S'
+              ELSE 
+                ITCODE(ITNE(L)) = 's'
+              ENDIF
+cc              ITCODE(ITNE(L)) = 'S'
 C***  TEST PRINTOUT: Correction Vector
-C            write (*,*) 'V2: '
-C            DO nTest=1, NRANK
-C               write (*,*) ' ', V2(nTest)
-C            ENDDO
+              IF (L==1) THEN
+                DO nTest=1, NRANK
+                  write (*,'(A,I6,4(3X,G20.10))') 'V2: ', nTest,
+     >             V2(nTest), EN1(nTest), V1(nTest), RATCO(nTest,nTest)
+                ENDDO
+              ENDIF
             ELSE
               ITCODE(ITNE(L)) = 'D'
             ENDIF
@@ -1006,23 +1061,26 @@
 C***  test output: "image" of specified matrix (NOTE:  ndim <= 126 )
       ldepth = 0
       if (l .eq. ldepth) then
-        call primat (rrate,n,ndim,'RRATE')
-        call primat (crate,n,ndim,'CRATE')
-        call primat (ratco,nrank,nrank,'RATCO')
+C        call primat (rrate,n,ndim,'RRATE')
+C        call primat (crate,n,ndim,'CRATE')
+C        call primat (ratco,nrank,nrank,'RATCO')
+C        WRITE (hOUT,*) IMAXPOP
+C        call primat (DM,nrank,nrank,'DM^(-1)')
       endif
 C***********************************************************************
 
 C***  PRINTOUT OF RATE COEFFICIENTS ETC.  ------------------------------
       IF (LSRAT.NE.-1) THEN
         IF ((L.GE.IFRRA.AND.L.LE.ITORA).OR.ITORA.EQ.0) THEN
-          NETTO=1
+cc          NETTO=1
 c!!!      NETTO=2
+          NETTO=2
           LM1=L-1
           IF (IFRRA.GT.0) LM1=L-IFRRA
           IF  (((LM1)/LSRAT)*LSRAT.EQ.(LM1).OR.L.EQ.ND) THEN
             CALL PRIRAT (ITNE(L),N,LEVEL,NDIM,L,CRATE,RRATE,RATCO,EN,
      $           IFRRA,MODHEAD,JOBNUM,NETTO,NFIRST,NLAST,NATOM,NATOUT,
-     $           NAUTO,RDIEL,RAUTO,IONGRND,KODRLOW,LASTKDR)
+     $           NAUTO,RDIEL,RAUTO,IONGRND,KODRLOW,LASTKDR,NRANK)
           ENDIF
         ENDIF
       ENDIF
Only in .: linsol (1).f
Only in .: linsol_split (1).f
diff -bur ./linsol_split.f ../../powr-refactor/src/linsol_split.f
--- ./linsol_split.f	2024-07-28 13:13:40.000000000 +0200
+++ ../../powr-refactor/src/linsol_split.f	2023-09-27 10:14:15.109755551 +0200
@@ -1,6 +1,9 @@
       SUBROUTINE LINSOL_SPLIT (X, A, B, N, NDIM,
-     >                         NFIRST, NLAST, NATOM, AOFF,
-     >                  SCRATCH, ATEST, BTEST, DTEST, VERSION, ELEMENT)
+     >                         NFIRST, NLAST, NATOM, NBLOCK, AOFF,
+     >                         SCRATCH, ATEST, BTEST, DTEST, VERSION, 
+     >                         NBSTART, NBEND, NBATOM, NBFirstIon, 
+     >                         IMAXPOP, ZERO_RATES, LEVEL, 
+     >                         iBLOCKINVERSION)
 C**********************************************************************
 C***  SOLVES THE LINEAR SYSTEM:  >>  X * A = B
 C***    by using the atomic block structure of A
@@ -12,7 +15,13 @@
 C***  X     = UNKNOWN VECTOR  --> SOLUTION
 C***  Call from Subroutine LINPOP
 C**********************************************************************
-
+C     
+C     Notation info:
+C     i = row index, j = column index
+C     When using blocks, the indexes i and j ares used for the index inside the blocks only.
+C     indBlockI and indBlockJ are used for referencing a block inside the large matrix
+C      
+C**********************************************************************
 C     This version is based on the ideas from the subroutine 
 C      linsol_split in the Goetz branch. However, there are certain
 C      things in Goetz code that are not in the wrh version. These are:
@@ -37,7 +46,7 @@
 
       IMPLICIT NONE
 
-      INTEGER, INTENT(IN) :: NDIM, N, NATOM
+      INTEGER, INTENT(IN) :: NDIM, N, NATOM, NBLOCK, iBLOCKINVERSION
       REAL, DIMENSION(NDIM,NDIM), INTENT(INOUT) :: A, AOFF
       REAL, DIMENSION(NDIM), INTENT(IN) :: B
       REAL, DIMENSION(NDIM), INTENT(OUT) :: X
@@ -49,21 +58,31 @@
 
       REAL, DIMENSION(NDIM,NDIM), INTENT(OUT) :: ATEST
       REAL, DIMENSION(NDIM), INTENT(OUT) :: BTEST, DTEST
-      INTEGER, DIMENSION(NATOM), INTENT(IN) :: NFIRST, NLAST
+      REAL, DIMENSION(NDIM) :: ROWINVIONIMAX, JBSTART, JBEND 
+      INTEGER, DIMENSION(NDIM), INTENT(IN) :: NBSTART, NBEND, NBATOM
+      INTEGER, DIMENSION(NATOM) :: NBPIVOT
+      INTEGER, DIMENSION(NATOM), INTENT(IN) :: NFIRST, NLAST,
+     >                                         IMAXPOP, NBFirstIon
       CHARACTER(4), INTENT(INOUT) :: VERSION
-      CHARACTER*10 ELEMENT(NATOM)
+      CHARACTER(10), DIMENSION(N), INTENT(IN) :: LEVEL
+      LOGICAL, DIMENSION(NDIM), INTENT(IN) :: ZERO_RATES
 
-      INTEGER :: IMPMAX, na, nn, i, j, nBlockDim, 
-     >           indBlockI, indBlockJ, nFirstNA, nLastNA,
+      INTEGER :: IMPMAX, na, nn, i, j, nBlockDim, nPivotDim, iBLOCK,
+     >           indBlockI, indBlockJ, nFirstLev, nLastLev,
      >           nVectorIndex, IMPRO, iPrimat
-      REAL :: DIFF
+      REAL :: DIFF, SUMINVi
 
-      LOGICAL :: bForceBlock, bPrintRightVector
+      LOGICAL :: bForceBlock, bPrintRightVector, bPIVOT
 
 C***  Operating system:
       COMMON / COMOS / OPSYS
       CHARACTER(8) :: OPSYS
 
+      !File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      
+      
 C***  set iPrimat to zero to print the inverted matrix structure
       iPrimat = 1
 
@@ -103,15 +122,15 @@
          DO nn=1, NDIM
             ATEST(nn, nn) = 1.
          ENDDO
-C***     copy atom blocks
-         DO na=1, NATOM
-            nFirstNA = NFIRST(na)
-            nLastNA = NLAST(na)
-            nBlockDim = nLastNA - nFirstNA + 1
+C***     copy atom/ion blocks
+         DO iBLOCK=1, NBLOCK
+            nFirstLev = NBSTART(iBLOCK)
+            nLastLev = NBEND(iBLOCK)
+            nBlockDim = nLastLev - nFirstLev + 1
             DO j=1, nBlockDim
-               indBlockJ = nFirstNA + j - 1
+               indBlockJ = nFirstLev + j - 1
                DO i=1, nBlockDim
-                  indBlockI = nFirstNA + i - 1
+                  indBlockI = nFirstLev + i - 1
                   ATEST(indBlockI, indBlockJ) = A(indBlockI, indBlockJ)
                ENDDO
             ENDDO
@@ -123,20 +142,53 @@
             ENDDO
          ENDIF
 
+         AOFF = 0.
+         DO i=1, NDIM
+            DO j=1, NDIM
+               AOFF(i,j) = A(i,j) - ATEST(i,j)    !non-block elements are stored in AOFF
+               A(i,j) = ATEST(i,j)
+            ENDDO
+         ENDDO
+         IF (NDIM > NLAST(NATOM)) THEN
+           !remove all non-block lines fom offcenter matrix
+           DO J=NLAST(NATOM)+1, NDIM
+             DO I=1, NDIM     
+               IF (I /= J) THEN
+                 AOFF(I, J) = 0.
+                 AOFF(J, I) = 0.
+               ENDIF
+             ENDDO
+           ENDDO
+         ENDIF
+
+C***     Restore number conservation column for ion split
+         IF (iBLOCKINVERSION == 2) THEN          
+           DO na=1, NATOM
+              DO i=NFIRST(na), NLAST(na)
+C                IF (AOFF(i, IMAXPOP(na)) == 1.) THEN
+                IF (AOFF(i, IMAXPOP(na)) == 1. .AND.
+     >                 .NOT. ZERO_RATES(i)) THEN
+                  !The innermost IF is necessary to prevent overwriting level switchoff effects
+                  ATEST(i, IMAXPOP(na)) = 1.
+                  AOFF(i, IMAXPOP(na)) = 0.
+                ENDIF
+              ENDDO
+           ENDDO
+         ENDIF
+
+         
 C***  PRINT Matrix debug option
          IF (iPrimat .eq. 0) THEN
             write (*,*) 'LINSOL_SPLIT> PRIMAT'
-            CALL PRIMAT(A, N, NDIM, 'Matrix A')
+            CALL PRIMAT(ATEST, N, NDIM, 'Matrix A')
+            write (*,*) 'LINSOL_SPLIT> end of PRIMAT'
+            write (*,*) 'LINSOL_SPLIT> PRIMAT'
+            CALL PRIMAT(AOFF, N, NDIM, 'Matrix AOFF')
             write (*,*) 'LINSOL_SPLIT> end of PRIMAT'
             iPrimat = 1
          ENDIF
 C***  end of block structure test
 
-         DO i=1, NDIM
-            DO j=1, NDIM
-               A(i,j) = ATEST(i,j)
-            ENDDO
-         ENDDO
       ELSE      
          DO i=1, N
             DO j=1, N
@@ -145,17 +197,61 @@
          ENDDO
       ENDIF
 
-C***  MATRIX INVERSION -------------------------------
+      DO iBLOCK=1, NBLOCK
+        JBSTART(iBLOCK) = NBSTART(iBLOCK)
+        JBEND(iBLOCK) = NBEND(iBLOCK)
+C        WRITE (6,*) 'START, END: ', i, JBSTART(i), JBEND(i)
+      ENDDO
+      NBPIVOT = 0.
+      IF (iBLOCKINVERSION == 2) THEN
+        !Re-sort blocks to have pivot block (= block with IMAXPOP) first for each atom
+        DO iBLOCK=1, NBLOCK
+          NA = NBATOM(iBLOCK)
+          IF (IMAXPOP(NA) >= NBSTART(iBLOCK) 
+     >               .AND. IMAXPOP(NA) <= NBEND(iBLOCK)) THEN
+            !"PIVOT" block has the number conservation directly in the block
+            ! => This block is the one that has to be inverted first
+            NBPIVOT(NA) = iBLOCK
+          ENDIF 
+        ENDDO
       DO na=1, NATOM         
+          WRITE (6,*) 'PIVOT, FI: ', na, NBPIVOT(na), NBFirstIon(na)
+          IF (NBPIVOT(na) /= NBFirstIon(na)) THEN
+            !If first block does not contain number conservation 
+            !   => switch with PIVOT block, so that PIVOT block is inverted first
+            !get block start level from block index from NBFirstIon
+            JBSTART(NBFirstIon(na)) = NBSTART(NBPIVOT(na))
+            JBEND(NBFirstIon(na)) = NBEND(NBPIVOT(na))
+            JBSTART(NBPIVOT(na)) = NBSTART(NBFirstIon(na))
+            JBEND(NBPIVOT(na)) = NBEND(NBFirstIon(na))
+          ENDIF
+        ENDDO
+      ENDIF
+
+C***  MATRIX INVERSION -------------------------------
+      DO iBLOCK=1, NBLOCK         
          SCRATCH = 0.
 C***     extract blocks
-         nFirstNA = NFIRST(na)
-         nLastNA = NLAST(na)
-         nBlockDim = nLastNA - nFirstNA + 1
+         nFirstLev = JBSTART(iBLOCK)
+         nLastLev = JBEND(iBLOCK)
+         nBlockDim = nLastLev - nFirstLev + 1
+         !First ion block in an atom is pivot block (ensured above)
+         NA = NBATOM(iBLOCK)
+         IF (iBLOCKINVERSION == 2) THEN
+            bPIVOT = (NBFirstIon(NA) == iBLOCK)
+            WRITE (6,'(A,2(I3,2X),L1,2(2X,I5))') 'BLOCK: ', iBLOCK, NA,
+     >                bPIVOT, nFirstLev, nLastLev
+            IF (bPIVOT) THEN
+              ROWINVIONIMAX = 0.
+              nPivotDim = nBlockDim     !save dimension of pivot block
+            ENDIF
+         ELSE
+           bPIVOT = .FALSE.
+         ENDIF
          DO j=1, nBlockDim
-            indBlockJ = nFirstNA + j - 1
+            indBlockJ = nFirstLev + j - 1
             DO i=1, nBlockDim
-               indBlockI = nFirstNA + i - 1
+               indBlockI = nFirstLev + i - 1
 C***           store column vectors of current block in one giant vector
 C***             because the dimension of the blocks is unknown
 C***             when SCRATCH has to be initialized
@@ -171,16 +267,46 @@
 
 C***     replace original block with inverted block in the matrix
          DO j=1, nBlockDim
-            indBlockJ = nFirstNA + j - 1
+            indBlockJ = nFirstLev + j - 1
             DO i=1, nBlockDim
-               indBlockI = nFirstNA + i - 1
+               indBlockI = nFirstLev + i - 1
                nVectorIndex = i + (j - 1) * nBlockDim
                A(indBlockI, indBlockJ) = SCRATCH(nVectorIndex)
+               IF (bPIVOT .AND. indBlockI == IMAXPOP(NA)) THEN
+                 ROWINVIONIMAX(j) = A(indBlockI, indBlockJ)
+               ENDIF
             ENDDO
          ENDDO
 
+C***     Off-Diagonal-Elements (only for ION SPLIT)
+         IF (iBLOCKINVERSION == 2 .AND. (.NOT. bPIVOT)) THEN
+C***       off-diagonal block is rectangular: 
+C***            rows = rows of current block
+C***         columns = columns of IIONMAX (PIVOT) 
+C***       The offcenter blocks are calculated as  -1 * MATMUL( A^(-1), C ) 
+C***            with C consisting of identical rows. The value for this row
+C***            is stored in ROWINVIONIMAX when the IONMAX (=PIVOT) block is inverted
+           DO i=1, nBlockDim
+             SUMINVi = 0.
+             indBlockI = nFirstLev + i - 1
+             IF (ZERO_RATES(indBlockI)) CYCLE
+             DO j=1, nBlockDim
+               !First build the sum of A^(-1) of row i in the regular block
+               indBlockJ = nFirstLev + j - 1
+               SUMINVi = SUMINVi + A(indBlockI, indBlockJ)
+             ENDDO
+             DO j=1, nPivotDim
+               !Now fill the offcenter block with 
+               indBlockJ = JBSTART(NBFirstIon(NA)) + j - 1
+               A(indBlockI, indBlockJ) = - SUMINVi * ROWINVIONIMAX(j)
+             ENDDO
+           ENDDO
+         ENDIF
+
          IF (VERSION .EQ. 'SING') THEN
-            write (0,*) 'SING in block for element ' // ELEMENT(NA)
+            WRITE (hCPR,'(A,I5,3A)') 
+     >          'SING in block with first index', nFirstLev, 
+     >          ' (',LEVEL(i),')'
             RETURN
          ENDIF
       ENDDO
Only in .: linstark (1).f
Only in ../../powr-refactor/src/: lintridiagsol.f
Only in .: liop (1).f
diff -bur ./liop.f ../../powr-refactor/src/liop.f
--- ./liop.f	2024-07-28 13:13:40.000000000 +0200
+++ ../../powr-refactor/src/liop.f	2023-11-21 10:10:55.289269787 +0100
@@ -9,9 +9,18 @@
 C***                     WEIGHTI, WEIGHTJ = STATISTICAL WEIGHTS (UP, LOW)
 C***                     POPNUM(L,J) = RELATIVE POPULATION NUMBERS
 C***                     ENTOT(L) = TOTAL NUMBER DENSITY
+C***                     I = LOW,  J = UP
+C***  called from:
+C***       COLI -> CHECK_LINES -> LIOP
+C***      STEAL -> LINPOP -> LCORE -> LIOP
+C***      STEAL -> LINPOP -> COMA -> SETXJL -> LIOP
+C***      STEAL -> LINPOP -> COMA -> SETXJLCF -> LIOP
+C***      STEAL -> LINPOP -> COMA -> SETXJFINE -> LIOP
+C***     FORMAL -> LIOP
 C***********************************************************************
  
       DIMENSION ENTOT(ND),OPAL(ND),ETAL(ND),POPNUM(ND,1)
+      REAL :: ENI, ENJ, VDOP
 
 C***  C2 = 2 * H * C     ( CGS UNITS )
       DATA C2 / 3.9724E-16 /
Only in .: lipo (1).f
Only in .: load_ff (1).f
Only in ../../powr-refactor/src/: mainadapter.f
Only in ../../powr-refactor/src/: mainadapter.for
Only in ../../powr-refactor/src/: maincoli.f
Only in ../../powr-refactor/src/: maincoli.for
Only in ../../powr-refactor/src/: maincomo.f
Only in ../../powr-refactor/src/: maincomo.for
Only in ../../powr-refactor/src/: mainextrap.f
Only in ../../powr-refactor/src/: mainextrap.for
Only in ../../powr-refactor/src/: mainformal.f
Only in ../../powr-refactor/src/: mainformal.for
Only in ../../powr-refactor/src/: mainmodify.f
Only in ../../powr-refactor/src/: mainmodify.for
Only in ../../powr-refactor/src/: mainmsinfo.f
Only in ../../powr-refactor/src/: mainmsinfo.for
Only in ../../powr-refactor/src/: mainnewdatom.f
Only in ../../powr-refactor/src/: mainnewdatom.for
Only in ../../powr-refactor/src/: mainnewformal_cards.f
Only in ../../powr-refactor/src/: mainnewformal_cards.for
Only in ../../powr-refactor/src/: mainnjn.f
Only in ../../powr-refactor/src/: mainnjn.for
Only in ../../powr-refactor/src/: mainsteal.f
Only in ../../powr-refactor/src/: mainwrcont.f
Only in ../../powr-refactor/src/: mainwrcont.for
Only in ../../powr-refactor/src/: mainwrstart.f
Only in ../../powr-refactor/src/: mainwrstart.for
Only in ../../powr-refactor/src/: Makefile
Only in ../../powr-refactor/src/: Makefile.bak
Only in ../../powr-refactor/src/: modify.exe
Only in ../../powr-refactor/src/: modify.exe.opt
diff -bur ./modify.f ../../powr-refactor/src/modify.f
--- ./modify.f	2024-07-28 13:13:44.000000000 +0200
+++ ../../powr-refactor/src/modify.f	2023-09-27 10:14:15.113755615 +0200
@@ -14,12 +14,15 @@
       INTEGER, PARAMETER :: NFDIM    = 2*NDIM + 400 
       INTEGER, PARAMETER :: MAXKONT  =     NFDIM/2 
       INTEGER, PARAMETER :: MAXIND   =       45000 
-      INTEGER, PARAMETER :: MAXFEIND =        1500 
+      INTEGER, PARAMETER :: MAXFEIND =        2500 
       INTEGER, PARAMETER :: NDDIM    =          89 
       INTEGER, PARAMETER :: MAXHIST  =        4000 
  
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR (SEE ALSO SUBR. GAUNTFF)
+      INTEGER, PARAMETER :: MAXION = 27 
+
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      INTEGER, PARAMETER :: MAXAUTO = 2850 
+      INTEGER, PARAMETER :: MAXAUTO = 3200 
       INTEGER, DIMENSION(MAXAUTO) :: LOWAUTO, IONAUTO, KRUDAUT
       REAL, DIMENSION(MAXAUTO) :: WAUTO, EAUTO, AAUTO
       COMMON / COMAUTO / LOWAUTO, WAUTO, EAUTO, AAUTO, IONAUTO, KRUDAUT
@@ -43,9 +46,9 @@
       CHARACTER(8*MAXHIST) :: MODHIST
 
       INTEGER :: I, N, L, IFRO, ITO, JOBNUM, LASTIND, NATOM, NAUTO, ND,
-     >           LASTKON, LASTFE, JOBNUM_SAVE, IDUMMY, IERR,
-     >           LAST, LSPOP, IARG, NARG, N_WITH_DRLEVELS
-      REAL :: A, B, X, Q, FEDUMM,
+     >           LASTKON, LASTFE, JOBNUM_SAVE, IDUMMY, IERR, NALIM, 
+     >           LAST, LSPOP, IARG, NARG, IONLIM, N_WITH_DRLEVELS
+      REAL :: A, B, X, Q, FEDUMM, POPMIN, TMIN, TMPREAL,
      >        VDOPFE, DXFE, XLAM0FE, XL, FROM, FTO, ASECOND
 
       CHARACTER(255) :: HISTENTRY
@@ -56,7 +59,7 @@
       CHARACTER(7) :: MODE
       CHARACTER(4), DIMENSION(MAXIND) :: KEYCBB
       CHARACTER(2), DIMENSION(MAXATOM) :: SYMBOL
-      CHARACTER(10), DIMENSION(10) :: ARGUMENT
+      CHARACTER(10), DIMENSION(15) :: ARGUMENT
       CHARACTER(64) :: BUFFER64
       CHARACTER(72) :: BUFFER72
       LOGICAL NOTEMP, BAUTO, NOPOP
@@ -65,7 +68,7 @@
 C***  include "dimblock"
 C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
 C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
-      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl / hydro
 
       REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
@@ -103,11 +106,11 @@
       WRITE(hCPR,'(4A)') '>>> created by ', LINK_USER(:IDX(LINK_USER)),
      >      ' at host ', LINK_HOST(:IDX(LINK_HOST))
 
-c      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
-c        CALL CLOCK(TIM1)
-c      ELSE
-c        CALL TIME(TIM1)
-c      ENDIF
+      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+        CALL CLOCK(TIM1)
+      ELSE
+        CALL TIME(TIM1)
+      ENDIF
 
       CALL       DATOM (NDIM,N,LEVEL,NCHARG , WEIGHT,ELEVEL,EION,MAINQN,
      $                  EINST,ALPHA,SEXPO,
@@ -124,7 +127,7 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >         LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
 C***  READING OF THE MODEL FILE ----------------------------------------
       CALL OPENMS (hMODEL, IDUMMY, IDUMMY, 1, IERR)
@@ -138,6 +141,10 @@
 C***  Save JOBNUM
       JOBNUM_SAVE = JOBNUM
       CALL READMS (hMODEL, POPNUM ,ND*N,'POPNUM  ' , IERR)
+      CALL READMS (hMODEL, POPMIN ,  1, 'POPMIN  ' , IERR)
+      IF (IERR == -10) THEN
+        POPMIN = 1.E-99   !Note: STEAL has a default of 1.E-25
+      ENDIF
       CALL READMS (hMODEL, RNE    , ND, 'RNE     ' , IERR)
       CALL READMS (hMODEL, ENTOT  , ND, 'ENTOT   ' , IERR)
       CALL READMS (hMODEL, T      , ND, 'T       ' , IERR)
@@ -177,11 +184,16 @@
       NOTEMP = .FALSE.
       BAUTO = .FALSE.
       NOPOP = .FALSE.
+      NALIM = 0
+      IONLIM = 0
+
+C***  Set minimum temperature for extrapolation
+      TMIN = 3000.
 
 C***  IF INPUT-FILE IS FINISHED (END=66) THEN UPDATE THE MODEL
     7 READ(hMODINPUT,'(A)',END=66) KARTE
 
-      DO IARG=1, 10
+      DO IARG=1, 15
        ARGUMENT(IARG) = ""
       ENDDO
 
@@ -196,9 +208,7 @@
 
       ELSEIF ( KARTE(:9) .EQ. 'PRINT POP' ) THEN
 C                              =========
-c            DECODE (80,4,KARTE) XL
-            READ (KARTE(10:),'(F10.0)') XL
-c    4       FORMAT (9X,F10.0)
+            READ(UNIT=KARTE, FMT='(9X,F10.0)') XL
             LSPOP=IFIX(XL)
             IF (LSPOP.EQ.0) LSPOP=1
 C***        READ NEXT INPUT CARD
@@ -211,6 +221,14 @@
             IFRO=IFIX(FROM)
             ITO=IFIX(FTO)
             MODE='INTERPO'
+            IF ( NARG > 7 .AND. ARGUMENT(8) == 'ONLY' ) THEN
+              READ (ARGUMENT(10),'(F10.0)') tmpREAL
+              IF ( ARGUMENT(9) == 'ATOM' ) THEN
+                NALIM = IFIX(tmpREAL)
+              ELSEIF ( ARGUMENT(9) == 'ION' ) THEN
+                IONLIM = IFIX(tmpREAL)
+              ENDIF
+            ENDIF
             JOBNUM = JOBNUM + 1
 C***        DO INTERPOLATION
             GOTO 80
@@ -273,6 +291,22 @@
 C***        READ NEXT INPUT CARD
             GOTO 7
             
+      ELSE IF (ARGUMENT(1)(1:6) .EQ. 'POPMIN' ) THEN
+C                                     =======
+            READ (ARGUMENT(2),'(F10.0)') tmpREAL
+            IF (POPMIN <= 1.E-98) THEN
+              !use CARDS value only if not stored in MODEL file
+              POPMIN = tmpREAL
+            ENDIF
+C***        READ NEXT INPUT CARD
+            GOTO 7
+
+      ELSEIF (ARGUMENT(1) == 'TMIN') THEN 
+C                             ====
+            READ (ARGUMENT(2),'(F10.0)') TMIN
+C***        READ NEXT INPUT CARD
+            GOTO 7
+
       ENDIF
 
       GOTO 7
@@ -281,8 +315,8 @@
 C***  INTER- OR EXTRAPOLATION OF THE POPULATIONS  **********************
 C***  ENTRY-POINT FOR INTERPOLATION AND EXTRAPOLATION
    80 CONTINUE
-          CALL INTEPO (ND,N,RNE,NCHARG,POPNUM,ENTOT,NATOM,
-     $                           ABXYZ,NFIRST,NLAST,IFRO,ITO,MODE,NOPOP)
+          CALL INTEPO (ND,N,RNE,NCHARG,POPNUM,ENTOT,NATOM,NALIM,IONLIM,
+     >                           ABXYZ,NFIRST,NLAST,IFRO,ITO,MODE,NOPOP)
 
 C***  INTERPOLATION OF THE TEMPERATURE STRATIFICATION
       IF (.NOT. NOTEMP) THEN
@@ -327,8 +361,13 @@
       ENDIF
 
 C***  TO AVOID NEGATIVE OR SMALL POPNUMBERS: CALL INHIBIT
-      CALL INHIBIT(POPNUM, N, ND, NCHARG, RNE, 
-     >             NATOM, ABXYZ, NFIRST, NLAST, 1.E-99)
+      CALL INHIBIT (POPNUM, N, ND, NCHARG, RNE,
+     >              NATOM, ABXYZ, NFIRST, NLAST, POPMIN)
+
+C***  AVOID TEMPERATURES BELOW TMIN (especially negative T)
+      DO L=1, ND
+        T(L) = MAX(T(L), TMIN)
+      ENDDO
 
 C***  UPDATING THE MODEL HISTORY
 C***  JOBNUM IS INCREASED FOR EVERY INTERPOLATION OR EXTRAPOLATION CARD
Only in ../../powr-refactor/src/: msinfo.exe
Only in ../../powr-refactor/src/: msinfo.exe.opt
diff -bur ./multiple.f ../../powr-refactor/src/multiple.f
--- ./multiple.f	2024-07-28 13:13:46.000000000 +0200
+++ ../../powr-refactor/src/multiple.f	2023-09-27 10:14:15.113755615 +0200
@@ -2,8 +2,7 @@
      >                    DELXLAP,NBLINE,MAXLAP,INDLOW,INDNUP,LASTIND,
      >                    MAXIND,LEVEL,WEIGHT,ELEVEL,N,EINST,NDIM,
      >                    POPNUM,T,ND,ALN,VDOP, 
-     >                    MAXNSUBLEVEL, MAXNSUBLINE,
-     >                    NSUBLOW,NSUBNUP,BROAD,LINPRO,AVOIGT,
+     >                    MAXSUBL,NSUBLOW,NSUBNUP,BROAD,LINPRO,AVOIGT,
      >                    NMOD, MAXMOD, NDDIM, 
      >                    MAINQN, NCHARG, EION, NOM, IND_ORIGLEV)
 C***********************************************************************
@@ -31,7 +30,7 @@
       DIMENSION EINST(NDIM,NDIM), IND_ORIGLEV(NDIM)
       DIMENSION INDLOW(LASTIND),INDNUP(LASTIND)
       DIMENSION POPNUM(NDDIM,NDIM,NMOD),T(NDDIM,NMOD)
-      DIMENSION NSUBLOW(MAXNSUBLINE), NSUBNUP(MAXNSUBLINE)
+      DIMENSION NSUBLOW(MAXSUBL),NSUBNUP(MAXSUBL)
       CHARACTER KARTE*80
       CHARACTER*10 LEVEL(N), LEV, LEVUP, LEVLOW
       CHARACTER*8 LINPRO(MAXLAP)
@@ -46,7 +45,7 @@
       NLOW=0
       NNUP=0
 C***  NSUBLOW, NSUBNUP: POINTER TO SUBLEVELS IN THE ORIGINAL ARRAYS
-      DO 10 I=1, MAXNSUBLINE
+      DO 10 I=1,MAXSUBL
       NSUBLOW(I)=0
    10 NSUBNUP(I)=0
 
@@ -102,12 +101,11 @@
          ENDIF
 
          NLOW=NLOW+1
-
-C***     Error exit
-         IF (NLOW .GT. MAXNSUBLEVEL) THEN
-            WRITE (0,*)  '*** More sublevels than dimensioned!'
-            WRITE (0,*)  '*** FATAL ERROR in subr. MULTIPLE'
-            STOP '*** ERROR: NLOW'
+         IF (NLOW .GT. MAXSUBL) THEN
+            PRINT *,
+     >           ' >>>>> SUBR. MULTIPLE: ERROR STOP (NLOW .GT. MAXSUBL)'
+            CALL REMARK ('MULTIPLE: NLOW GREATER THAN MAXSUBL')
+            STOP 'NLOW'
          ENDIF
          NSUBLOW(NLOW)=JLOW
 
@@ -156,9 +154,10 @@
          ENDIF
 
          NNUP=NNUP+1
-         IF (NNUP .GT. MAXNSUBLEVEL) THEN
-            WRITE (0,*)  '*** More sublevels than dimensioned!'
-            WRITE (0,*)  '*** FATAL ERROR in subr. MULTIPLE'
+         IF (NNUP .GT. MAXSUBL) THEN
+            PRINT *,
+     >           ' >>>>> SUBR. MULTIPLE: ERROR STOP (NNUP .GT. MAXSUBL)'
+            CALL REMARK ('MULTIPLE: NNUP GREATER THAN MAXSUBL')
             STOP 'NNUP'
          ENDIF
          NSUBNUP(NNUP)=JNUP
@@ -252,8 +251,8 @@
 
 C***  3. SPLITTING OF THE ENERGY LEVELS: BOLTZMANN (LTE POPNUMBERS)
       DO IMOD=1, NMOD
-        CALL MULTSPLI(ND(IMOD), N, NSUBLOW, MAXNSUBLEVEL, 
-     >                NLOW, POPNUM(1,1,IMOD), ELEVEL, 
+        CALL MULTSPLI(ND(IMOD), N, NSUBLOW, MAXSUBL, NLOW, POPNUM(1,1,IMOD), 
+     >                ELEVEL, 
      >                T(1,IMOD), WEIGHT, NNUP, NSUBNUP, LOW, NUP, 
      >                LEVEL)
       ENDDO
diff -bur ./multspli.f ../../powr-refactor/src/multspli.f
--- ./multspli.f	2024-07-28 13:13:47.000000000 +0200
+++ ../../powr-refactor/src/multspli.f	2023-09-27 10:14:15.113755615 +0200
@@ -1,8 +1,8 @@
-      SUBROUTINE MULTSPLI(ND, N, NSUBLOW, MAXNSUBLEVEL, NLOW, POPNUM, 
+      SUBROUTINE MULTSPLI(ND, N, NSUBLOW, MAXSUBL, NLOW, POPNUM, 
      >                 ELEVEL, T, WEIGHT, NNUP, NSUBNUP, LOW, NUP, 
      >                 LEVEL)
 
-      DIMENSION NSUBLOW(MAXNSUBLEVEL), NSUBNUP(MAXNSUBLEVEL)
+      DIMENSION NSUBLOW(MAXSUBL), NSUBNUP(MAXSUBL)
       DIMENSION POPNUM(ND, N), T(ND), ELEVEL(N), WEIGHT(N)
       CHARACTER*10 LEVEL(N) 
 C***  C1 = H * C / K    ( CM * ANGSTROEM )
Only in ../../powr-refactor/src/: newdatom.exe
Only in ../../powr-refactor/src/: newdatom.exe.opt
diff -bur ./newdatom.f ../../powr-refactor/src/newdatom.f
--- ./newdatom.f	2024-07-28 13:13:47.000000000 +0200
+++ ../../powr-refactor/src/newdatom.f	2023-09-27 10:14:15.113755615 +0200
@@ -11,9 +11,9 @@
 C***
 C**********************************************************************
       PARAMETER (NDIM=1000) !Maximale Zahl der Levels
-      PARAMETER (MAXION=20)
+      PARAMETER (MAXION=27)
       CHARACTER LEVEL(NDIM, MAXION)*10
-      CHARACTER ZEILE*80, NAMEION(MAXION)*5, FILENAME*255 
+      CHARACTER ZEILE*80, NAMEION*5(MAXION), FILENAME*255 
       CHARACTER ELEMENT*2 !Elementsymbol
       CHARACTER IONDEGREE(MAXION)*10 !vorkommende Ionen
       CHARACTER HIGHESTION*10, ROMAN(20)*5
@@ -62,14 +62,11 @@
       
 C     Gesamtes Steuerfile als Kommentar oben drueber schreiben, d.h.
 C     einlesen und ausgeben
-ccc      CALL DATE(CDATE)
-ccc      CALL TIME(CTIME)
-      CALL DATE_AND_TIME (DATE=CDATE, TIME=CTIME)
-
+      CALL DATE(CDATE)
+      CALL TIME(CTIME)
       WRITE (99,'(A)') 
-     > '* This DATOM-FILE has been created at ' //
-     >     CDATE(1:4) // '/' // CDATE(5:6) // '/' // CDATE(7:8) // ' ' 
-     >  // CTIME(1:2) // ':' // CTIME(3:4) // ':' // CTIME(5:6)  
+     > '* This DATOM-FILE has been created at ' // CDATE 
+     >                  // '' // CTIME
       WRITE (99,'(A)') '* with the program NEWDATOM' 
       WRITE (99,'(A)') '*'
       WRITE (99,'(A)') '* NEWDATOM_INPUT was'       
diff -bur ./newdatomion.f ../../powr-refactor/src/newdatomion.f
--- ./newdatomion.f	2024-07-28 13:13:48.000000000 +0200
+++ ../../powr-refactor/src/newdatomion.f	2023-09-27 10:14:15.113755615 +0200
@@ -10,24 +10,22 @@
 C***  
 C**********************************************************************     
 
-      CHARACTER ZEILE*80, NAMEION(MAXION)*5, FILENAME*255 
-      CHARACTER ELEMENT*2, IONDEGREE(MAXION)*10
-      DIMENSION NLEVEL(MAXION)
+      CHARACTER(255) :: FILENAME
+      CHARACTER(80) :: ZEILE, ZEILE2, ZEILE3, ZEILE4
+      CHARACTER(5), DIMENSION(20) :: NAMEION 
+      CHARACTER(2) :: ELEMENT
+      INTEGER, DIMENSION(MAXION) :: NLEVEL, LEVELCOUNT
       LOGICAL, DIMENSION(MAXION) :: DRTRANSIT, KSHELL
-      INTEGER LEVELCOUNT(MAXION)
       CHARACTER LEVEL(NDIM, MAXION)*(*)
-      LOGICAL LEVELFOUND
-      LOGICAL LEVELFOUNDA
-      LOGICAL LEVELFOUNDZ
-      CHARACTER ZEILE2*80
-      CHARACTER ZEILE3*80
-      CHARACTER ZEILE4*80
-      CHARACTER PATH(MAXION)*255
-      CHARACTER FEHLERZEILE(MAXION)*80
-      CHARACTER ZIELNIVEAU(MAXION, NDIM)*10
-      LOGICAL ZIEL
-      INTEGER Z
-      LOGICAL BTRUEAUTOLEV
+      LOGICAL :: LEVELFOUND, LEVELFOUNDA, LEVELFOUNDZ, ZIEL
+      CHARACTER(255), DIMENSION(MAXION) :: PATH
+      CHARACTER(80), DIMENSION(MAXION) :: FEHLERZEILE
+      CHARACTER(10), DIMENSION(MAXION) :: IONDEGREE
+      CHARACTER(10), DIMENSION(MAXION, NDIM) :: ZIELNIVEAU
+      INTEGER :: Z
+      LOGICAL :: BTRUEAUTOLEV
+
+
 
 C     Oeffnen aller Ionendateien fuer ein Element
       
@@ -274,7 +272,7 @@
       END DO !Ende der Schleife ueber alle Ionen
        
 C     K-SHELL 
-    7 DO ION=1, NION ! Fuer jedes Ion seine individuellen Daten einlesen
+    7 DO ION=1, NION !Fuer jedes Ion seine Datendatei einlesen
         IF (.NOT. KSHELL(ION)) CYCLE
         DO
          READ (ION,'(A)',END=6) ZEILE2 
Only in ../../powr-refactor/src/: newformal_cards.exe
Only in ../../powr-refactor/src/: newformal_cards.exe.opt
diff -bur ./newformal_cards.f ../../powr-refactor/src/newformal_cards.f
--- ./newformal_cards.f	2024-07-28 13:13:48.000000000 +0200
+++ ../../powr-refactor/src/newformal_cards.f	2023-09-27 10:14:15.113755615 +0200
@@ -15,10 +15,12 @@
 
 C***  SET ARRAY DIMENSION PARAMETERS
       INTEGER, PARAMETER :: MAXATOM =          26 
+      INTEGER, PARAMETER :: MAXION  =          27
       INTEGER, PARAMETER :: NDIM    =        2560 
-      INTEGER, PARAMETER :: MAXAUTO =        2850 
+      INTEGER, PARAMETER :: MAXAUTO =        3200 
       INTEGER, PARAMETER :: MAXIND  =       45000 
-      INTEGER, PARAMETER :: MAXKONT =        NDIM 
+      INTEGER, PARAMETER :: MAXKONT =        NDIM + 200
+      INTEGER, PARAMETER :: MAXKODR =        NDIM 
       INTEGER, PARAMETER :: MAXMULTI=       10000 
       INTEGER, PARAMETER :: MAXDRTRANSIT =   1000 
       INTEGER, PARAMETER :: MAXIONRESTRICT =  200
@@ -79,7 +81,7 @@
       REAL, DIMENSION(NDIM,NDIM) :: EINST
       REAL, DIMENSION(MAXATOM) :: ATMASS, STAGE
 
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       REAL, DIMENSION(4,NDIM) :: ALTESUM
       
       REAL, DIMENSION(MAXKONT) :: ALPHA, SEXPO, 
@@ -95,11 +97,11 @@
 
 C***  IRON: 
 C***  include "dimblock"
-C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
+c      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
+c      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
       INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
 
-      INTEGER, PARAMETER :: MAXFEIND  =       1500 
+      INTEGER, PARAMETER :: MAXFEIND  =       2500 
  
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
      >                                IFENUP, IFELOW
@@ -111,6 +113,8 @@
       
       INTEGER, DIMENSION(MAXIONRESTRICT) :: LISTRESTRICT 
       
+      CHARACTER(10) :: TIM1
+
 C***  Operating system:
       CHARACTER(8) :: OPSYS
       COMMON / COMOS / OPSYS
@@ -123,7 +127,6 @@
       CHARACTER(7), DIMENSION(MAXIONNAMES) :: NUMMER
       CHARACTER(2), DIMENSION(MAXIONNAMES) :: SYM
 
-      INTEGER, PARAMETER :: MAXION = 27
       CHARACTER(4), DIMENSION(0:MAXION) :: ROMION
       
       !File and channel handles (=KANAL)
@@ -163,9 +166,16 @@
 
       CALL INSTALL
                                  
+      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+        CALL CLOCK(TIM1)
+      ELSE
+        CALL TIME(TIM1)
+      ENDIF
+      
 * Eisenabfrage      
       BIRON = .FALSE.
       WRITE(*,*) 'BIRON=', BIRON
+      WRITE(hCPR,*) 'Opening DATOM...'
 
 C***  READING THE ATOMIC DATA FROM FILE DATOM
       CALL DATOM (NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,MAINQN,
@@ -183,9 +193,10 @@
      >                  LASTFE, SIGMAFE, INDRB, INDRF,
      >                  IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY, 
      >                  VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
 
  
+      WRITE(hCPR,*) 'DATOM loaded...'
       WRITE(*,*) 'BFEMODEL', BFEMODEL
       IF (BFEMODEL) THEN
         BIRON = .TRUE.
@@ -246,13 +257,11 @@
       OPEN (hNFCIN,FILE='NEWFORMAL_CARDS_INPUT',ACTION = 'READ',ERR=903)
       
 C     Header erstellen
-ccc      CALL DATE(CDATE)
-ccc      CALL TIME(CTIME)
-      CALL DATE_AND_TIME (DATE=CDATE, TIME=CTIME)
+      CALL DATE(CDATE)
+      CALL TIME(CTIME)
       WRITE (hFC,'(A)') 
-     > '* This FORMAL_CARDS-FILE has been created at ' //
-     >     CDATE(1:4) // '/' // CDATE(5:6) // '/' // CDATE(7:8) // ' ' 
-     >  // CTIME(1:2) // ':' // CTIME(3:4) // ':' // CTIME(5:6)  
+     > '* This FORMAL_CARDS-FILE has been created at ' 
+     >         // CDATE(:IDX(CDATE)) // ' ' // CTIME
       WRITE (hFC,'(A)') '* with the program NEWFORMAL_CARDS' 
       WRITE (hFC,'(A)') '* and the following input from file'
       WRITE (hFC,'(A)') '* NEWFORMAL_CARDS_INPUT:' 
@@ -543,7 +552,7 @@
                   ENDIF
                 ENDDO
                 LOWE = ELEVEL(INDEXL) !an diesem Index Energie auslesen
-                IF (.NOT. LEVELLOW) THEN
+                IF (LEVELLOW == .FALSE.) THEN
                   !Level nicht gefunden
                   WRITE (hCPR,*) 'WARNING: Lowerlevel not found: ',
      >                              LOWNAME
@@ -559,7 +568,7 @@
                 ENDDO
                 UPE = ELEVEL(INDEXU) !an diesem Index Energie auslesen
 C              WRITE (0,*) 'Upperlevel: ', UPNAME, UPE
-                IF (.NOT. LEVELUP) THEN
+                IF (LEVELUP == .FALSE.) THEN
                   !Level nicht gefunden
                   WRITE (hCPR,*) 'WARNING: Upperlevel not found: ', 
      >                              UPNAME
@@ -596,7 +605,7 @@
      >                 LEVELUP .AND. LEVELLOW) THEN
 
 C          Header fuer das Ion schreiben
-                  IF (HEADER) THEN
+                  IF (HEADER .EQ. .TRUE.) THEN
                     WRITE (hFC,'(A)') 
      >               '************************************************'
                     WRITE (hFC,'(A)',advance='no') '*'
@@ -779,7 +788,7 @@
                 IF (PASST) THEN !eine Wellenlaenge im Band
                   PASST = .FALSE.
 C             Header fuer das Ion schreiben
-                  IF (HEADER) THEN
+                  IF (HEADER .EQ. .TRUE.) THEN
                     WRITE (hFC,'(A)') 
      >                '************************************************'
                     WRITE (hFC,'(A)',advance='no') '*'
diff -bur ./nextjob.f ../../powr-refactor/src/nextjob.f
--- ./nextjob.f	2024-07-28 13:13:49.000000000 +0200
+++ ../../powr-refactor/src/nextjob.f	2023-09-27 10:14:15.113755615 +0200
@@ -1,7 +1,8 @@
       SUBROUTINE NEXTJOB (JOBNUM,JOBMAX,MODHIST,LAST,CORMAX,EPSILON,
      $                    NEWWRC,MOREJOBS,CONVERG,NOEXTRAP, NOCON, 
      >                    BPRICORR, COREX, BCOREX, NCOLIP, BAG, BGFIN, 
-     >                    BAUTO_ABORT, FLUXEPS, ND, FLUXERR, IHSSTATUS)
+     >                    BAUTO_ABORT, FLUXEPS, ND, FLUXERR, IHSSTATUS, 
+     >                    IHDSTATUS, bRESTART, bHYDROSOLVE, bHydroHelp)
 C**********************************************************************
 C***  CALLED FROM: STEAL
 C***  THIS SUBROUTINE DECIDES UPON THE NEXT JOB TO BE EXECUTED.
@@ -15,24 +16,25 @@
       IMPLICIT NONE
 
       INTEGER, INTENT(IN) :: JOBNUM, JOBMAX, LAST, NEWWRC, NCOLIP, 
-     >                       IHSSTATUS, ND
+     >                       IHSSTATUS, IHDSTATUS, ND
       REAL, INTENT(IN) :: COREX, CORMAX, EPSILON, FLUXEPS
       REAL, DIMENSION(ND), INTENT(IN) :: FLUXERR
-      LOGICAL, INTENT(INOUT) :: CONVERG, MOREJOBS
+      LOGICAL, INTENT(INOUT) :: CONVERG, MOREJOBS, bHydroHelp
       LOGICAL, INTENT(IN) :: NOEXTRAP, NOCON, BPRICORR, BCOREX,
-     >                       BAG, BGFIN, BAUTO_ABORT
+     >                       BAG, BGFIN, BAUTO_ABORT, bRESTART,
+     >                       bHYDROSOLVE
       CHARACTER(8*LAST), INTENT(IN) :: MODHIST
 
       REAL, PARAMETER :: CORLIMIT = 1E-8 !used to avoid LOG if CORMAX = 0
       REAL :: LOGCORMAX
 
       INTEGER :: JOBDIFF, LASTEX, LASTCHAR, LASTWRC, LASTMOD, NGDIFF,
-     >           MODDIFF, LASTWHATEVER, NRFOUND,
+     >           MODDIFF, LASTWHATEVER, NRFOUND, NSTEAL,
      >           I, J, ISTART, IEND, ILEN, IMAX
 
       CHARACTER(1) :: NAM1
       CHARACTER(6) :: NAM2
-      CHARACTER(8) :: NEXTNAME
+      CHARACTER(8) :: NEXTNAME, NEXTNORG
       CHARACTER(20) :: BUFFER20
       CHARACTER(40) :: JOBFMT
       CHARACTER(255) :: HISTENTRY
@@ -204,10 +206,23 @@
         ENDIF
       ENDIF            
             
+      IF (bCONVCRIT .AND. IHDSTATUS >= 0) THEN
+        IF (IHDSTATUS == 0) THEN
+          bCONVCRIT = .FALSE.
+          WRITE (0,'(A)')
+     >       'STEAL: not converged: HD consistency not reached'
+          WRITE (*,'(A)')
+     >       'STEAL: not converged: HD consistency not reached'
+        ENDIF
+      ENDIF            
+      
       IF (bCONVCRIT) THEN
          CALL REMARK ('STEAL: REPEAT CYCLE IS CONVERGED')
          PRINT *,'STEAL: REPEAT CYCLE IS CONVERGED'
+         NEXTNORG=NEXTNAME
          NEXTNAME='WRCONT'
+         bCONVCRIT = .TRUE.
+         NSTEAL=0
          DO J=LASTWRC+1, JOBNUM-1
            !new convergence check: only COLI and COMO since last WRCONT allowed
            CALL GETHISTENTRY(HISTENTRY,J,MODHIST,LAST)
@@ -219,18 +234,39 @@
                HISTENTRY = ADJUSTL(HISTENTRY(I+1:IMAX))
                IF ( (HISTENTRY(1:4) /= 'COLI') .AND. 
      >              (HISTENTRY(1:4) /= 'COMO') ) THEN
+                 IF (HISTENTRY(1:5) == 'STEAL') THEN
+                   NSTEAL = NSTEAL + 1
+                   IF (NSTEAL > 1) THEN
+                     !only one STEAL should be in-between, due to hydro analysis
+                     bCONVCRIT = .FALSE.
+                   ENDIF
+                 ELSE
                  bCONVCRIT = .FALSE.
                ENDIF
+               ENDIF
                EXIT jnloop
              ENDIF
            ENDDO jnloop
          ENDDO
-
+         IF (bCONVCRIT .AND. (.NOT. bHydroHelp) 
+     >                 .AND. (.NOT. bHYDROSOLVE)) THEN
+           bCONVCRIT = .FALSE.
+           bHydroHelp = .TRUE.  !switch on hydro analysis for converged model
+           CALL REMARK ('STEAL: CONVERGED: HYDRO ANALYSIS NEXT!')
+           PRINT *, 'STEAL: CONVERGED: HYDRO ANALYSIS NEXT!'
+           NEXTNAME=NEXTNORG
+C         ELSEIF (bCONVCRIT) THEN
+         ELSE
+           bHydroHelp = .FALSE. !switch off after hydro analysis
+         ENDIF
+C         IF (JOBDIFF .LE. 3) THEN
          IF (bCONVCRIT) THEN
             CALL REMARK ('STEAL: MODEL FINALLY CONVERGED!')
             PRINT *, 'STEAL: MODEL FINALLY CONVERGED!'
             NEXTNAME='MODEL'
          ENDIF
+      ELSEIF (bHydroHelp) THEN
+        bHydroHelp = .FALSE.    !HydroHelp should only run once!
       ENDIF
 
       !prevent log(0) error
@@ -240,6 +276,10 @@
         LOGCORMAX = ALOG10(CORMAX)
       ENDIF
       
+      IF (NEXTNAME == 'REPEAT' .AND. bRESTART) THEN
+        NEXTNAME='RESTART'
+      ENDIF
+
 C***  EXTRAPOLATION
 C***  Old Version (NEWWRC=6)
       IF (NEXTNAME == 'REPEAT' .AND.
@@ -300,6 +340,13 @@
          CONVERG=.TRUE.
       ENDIF
       
+C***  RESTART MODEL if forced (optional after hydro iteration)
+      IF (NEXTNAME == 'RESTART') THEN
+         CALL REMARK ('STEAL: NEXTJOB=WRSTART')
+         PRINT *,'STEAL: NEXTJOB=WRSTART'
+         CALL JSYMSET ('G1','RESTART')
+      ENDIF
+      
 C***  MAX. NUMBER OF JOBS EXCEEDED? 
       IF (JOBNUM >= JOBMAX) THEN
          CALL REMARK ('STEAL: MAX. NUMBER OF JOBS EXCEEDED')
Only in ../../powr-refactor/src/: njn.exe
Only in ../../powr-refactor/src/: njn.exe.opt
diff -bur ./nltepop.f ../../powr-refactor/src/nltepop.f
--- ./nltepop.f	2024-07-28 13:13:50.000000000 +0200
+++ ../../powr-refactor/src/nltepop.f	2023-09-27 10:14:15.113755615 +0200
@@ -1,13 +1,13 @@
       SUBROUTINE NLTEPOP (NDIM,N,ENLTE,TL,ENE,WEIGHT,NCHARG,EION,ELEVEL,
      $                   EN,EINST,XLAMBDA,FWEIGHT,XJC,NF,L,LEVEL,
-     $                   XJL,ND,CRATE,RRATE,RATCO,SIGMAKI,ALTESUM,COCO,
-     $                   KEYCBB,NOM,NATOM,ABXYZ,KODAT,NFIRST,NLAST,
-     $                   NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
-     $                   RDIEL,RAUTO,IONAUTO,IONGRND,
-     $                   INDNUP, INDLOW, LASTIND, LASTINDALL, 
+     $                   XJL,ND,CRATE,RRATE,RATCO,SIGMAKI,
+     $                   ALTESUM,COCO,KEYCBB,NOM,NATOM,ABXYZ,KODAT,
+     $                   NFIRST,NLAST,NAUTO,MAXAUTO,LOWAUTO,WAUTO,
+     $                   EAUTO,AAUTO,RDIEL,RAUTO,IONAUTO,IONGRND,
+     $                   INDNUP,INDLOW,LASTIND, LASTINDALL, MAXION,
      $                   KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,
      $                   LASTKDR,KEYCBF,MAXATOM,SIGMATHK,SEXPOK,EDGEK,
-     $                   LASTINDAUTO, KRUDAUT, ZERO_RATES, POPMIN)
+     $                   LASTINDAUTO,KRUDAUT, ZERO_RATES, POPMIN)
  
 C******************************************************************************
 C***  CALCULATION OF NEW NLTE POPULATION NUMBERS
@@ -15,33 +15,40 @@
 C***  Calling tree: WRSTART - POPZERO - NLTEPOP
 C******************************************************************************
 
-      DIMENSION EINST(NDIM,NDIM),CRATE(NDIM,NDIM),RRATE(NDIM,NDIM)
-      DIMENSION RATCO(NDIM,NDIM)
-      DIMENSION ENLTE(NDIM),EN(NDIM),NCHARG(NDIM),WEIGHT(NDIM)
-      DIMENSION EION(NDIM),ELEVEL(NDIM)
-      DIMENSION IONGRND(NDIM),RDIEL(NDIM),RAUTO(NDIM)
-      DIMENSION KODRLOW(LASTKDR)
-      DIMENSION ABXYZ(NATOM),KODAT(NATOM),NFIRST(NATOM),NLAST(NATOM)
-      DIMENSION XLAMBDA(NF),FWEIGHT(NF)
-      CHARACTER*4 CKEY
-      CHARACTER LEVEL(NDIM)*10
-      LOGICAL ZERO_RATES(N,ND)
+      INTEGER, INTENT(IN) :: NDIM, NATOM, MAXATOM, NF, N, ND, LASTKDR
+
+      INTEGER, DIMENSION(NDIM) :: NCHARG, IONGRND
+      REAL, DIMENSION(NDIM) :: ENLTE, EN, ELEVEL, EION, WEIGHT, 
+     >                         RDIEL, RAUTO
+      REAL, DIMENSION(NDIM,NDIM) :: CRATE, RRATE, EINST, RATCO
+      INTEGER, DIMENSION(LASTKDR) :: KODRLOW
+      REAL, DIMENSION(NATOM) :: ABXYZ
+      INTEGER, DIMENSION(NATOM) :: NFIRST, NLAST
+      REAL, DIMENSION(NF) :: XLAMBDA, FWEIGHT
+      CHARACTER(4) :: CKEY
+      CHARACTER(10), DIMENSION(NDIM) :: LEVEL
+      INTEGER, DIMENSION(MAXATOM) :: KODAT
+      LOGICAL, DIMENSION(N,ND) :: ZERO_RATES
+      LOGICAL :: BFERATE
  
 C***  CHOOSE ADAEQUATE VERSION FOR MATRIX INVERSION
-      CKEY = 'OWN '
+C      CKEY = 'OWN '
+      CKEY = 'OWNL'
+      CKEY = 'FREE'
+      BFERATE = .FALSE. !in this routine we do not have Fe rates from COLI
 
 C***  SET UP THE COEFFICIENT MATRICES CRATE AND RRATE FOR ALL ELEMENTS
       CALL COLLI (NDIM,N,ENLTE,TL,ENE,NCHARG,ELEVEL,EINST,CRATE,
      $            EION,COCO,KEYCBB,WEIGHT,ALTESUM,NATOM,NOM,KODAT,
-     $            INDNUP, INDLOW, LASTIND, LASTINDAUTO, LASTINDALL,
-     $            KONTNUP,KONTLOW,LASTKON,KEYCBF,IONGRND)
+     $            INDNUP,INDLOW,LASTIND,LASTINDAUTO,LASTINDALL,
+     >            KONTNUP,KONTLOW,LASTKON,KEYCBF,IONGRND, MAXATOM)
       CALL RADIO (NDIM,N,ENLTE,TL,WEIGHT,EION,ELEVEL,EINST,
      $            RRATE,XLAMBDA,FWEIGHT,XJC,NF,L,XJL,ND,SIGMAKI,
      $            ENE,NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $            RDIEL,RAUTO,IONAUTO,IONGRND,
      $            INDNUP,INDLOW,LASTIND,KONTNUP,KONTLOW,LASTKON,
      $            NATOM,MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,NFIRST,
-     $            NLAST,NCHARG,KRUDAUT)
+     $            NLAST,NCHARG,KRUDAUT,MAXION)
 
 C***  LOOP FOR EACH ELEMENT  -------------------------------------------
       DO 11 NA=1,NATOM
@@ -90,8 +97,9 @@
 C***  applies for the subsequent COMA branch
 
       POPMIN = 1.E-99
-      CALL FLAG_ZERORATES (1, NDELP1, RATCO, NDIM, IMAXPOP, 
-     >                     EN(NFIRNA), POPMIN, ZERO_RATES(NFIRNA,L))
+      CALL FLAG_ZERORATES(1, NDELP1, RATCO, NDIM, NDIM,
+     >                    IMAXPOP, EN(NFIRNA), POPMIN, 
+     >                    ZERO_RATES(NFIRNA, L))
 
 C***  COLUMN IMAXPOP: NUMBER CONSERVATION
       DO 5 I=1,NDELP1
diff -bur ./opaross.f ../../powr-refactor/src/opaross.f
--- ./opaross.f	2024-07-28 13:13:52.000000000 +0200
+++ ../../powr-refactor/src/opaross.f	2023-11-21 10:10:55.289269787 +0100
@@ -4,7 +4,7 @@
      $                   ADDCON1, ADDCON2, ADDCON3, 
      $                   IGAUNT,NF,XLAMBDA,FWEIGHT,NOM,
      $                   MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,RL,
-     $                   KONTNUP,KONTLOW,LASTKON)
+     $                   KONTNUP,KONTLOW,LASTKON,POPMIN)
 C***********************************************************************
 C***  COMPUTATION OF THE ROSSELAND MEAN OPACITY AT DEPTH POINT L
 C***  FOR GIVEN POPNUMBERS
@@ -15,6 +15,7 @@
       DIMENSION NCHARG(N),WEIGHT(N),ELEVEL(N),EION(N)
       DIMENSION XLAMBDA(NF),FWEIGHT(NF)
       CHARACTER*10 LEVEL(N),MAINPRO,MAINLEV
+      REAL :: POPMIN
  
 C***  FREQUENCY INTEGRATION ***
 C***  NOTE: FOR NUMERICAL REASONS, THE NORMALIZATION CONSTANT Q IS
@@ -28,9 +29,9 @@
       LYMP = 1
       DO 1 K=1,NF
       XLAM=XLAMBDA(K)
-      CALL COOP (XLAM,LYMP,TL,RNEL,EN,ENTOTL,RSTAR,OPA,ETA,THOMSON,
-     $          IWARN,MAINPRO,MAINLEV,NOM,KODAT,NDIM,N,MAXATOM,
-     $          LEVEL,NCHARG,WEIGHT,
+      CALL COOP (XLAM,LYMP,TL,RNEL,EN,POPMIN,ENTOTL,RSTAR,OPA,ETA,
+     >           THOMSON,IWARN,MAINPRO,MAINLEV,NOM,KODAT,
+     >           NDIM,N,MAXATOM,LEVEL,NCHARG,WEIGHT,
      $          ELEVEL,EION,EINST,ALPHA,SEXPO,
      $          ADDCON1, ADDCON2, ADDCON3, 
      $          IGAUNT,SIGMATHK,SEXPOK,EDGEK,0,DUMMY,DUMMY,RL,
diff -bur ./overlap.f ../../powr-refactor/src/overlap.f
--- ./overlap.f	2024-07-28 13:13:53.000000000 +0200
+++ ../../powr-refactor/src/overlap.f	2024-03-22 14:59:01.464850439 +0100
@@ -1,7 +1,7 @@
       SUBROUTINE OVERLAP (IBLENDS,MAXLAP,LASTIND, LASTINDAUTO,
      >           XLAMZERO,XLAMRED,
      >           XLAMBLUE,XMAX,EINST,NDIM,ELEVEL,INDNUP,INDLOW,NOLAP,
-     >           VDOP,NBLENDS, KRUDAUT, EAUTO, NAUTO, EION)
+     >           VDOPUNIT,NBLENDS, KRUDAUT, EAUTO, NAUTO, EION)
 
 C**********************************************************************
 C***  CALLED FROM: STEAL
@@ -9,11 +9,16 @@
 C***     OF ALL LOCALLY OVERLAPPING LINES
 C**********************************************************************
 
-      DIMENSION IBLENDS(MAXLAP,LASTIND),INDNUP(LASTIND),INDLOW(LASTIND)
-      DIMENSION XLAMZERO(LASTIND), XLAMBLUE(LASTIND), XLAMRED(LASTIND)
-      DIMENSION EINST(NDIM,NDIM), ELEVEL(NDIM), NBLENDS(LASTIND)
-      DIMENSION KRUDAUT(NAUTO), EAUTO(NAUTO), EION(NDIM)
-      LOGICAL NOLAP
+      INTEGER, INTENT(IN) :: NDIM, NAUTO, LASTIND, LASTINDAUTO
+
+      INTEGER, DIMENSION(MAXLAP,LASTIND) :: IBLENDS
+      REAL, DIMENSION(LASTIND) :: XLAMZERO, XLAMBLUE, XLAMRED
+      REAL, DIMENSION(NDIM,NDIM) :: EINST
+      INTEGER, DIMENSION(LASTIND) :: INDNUP, INDLOW, NBLENDS
+      REAL, DIMENSION(NDIM) :: ELEVEL, EION
+      REAL, DIMENSION(NAUTO) :: EAUTO
+      INTEGER, DIMENSION(NAUTO) :: KRUDAUT
+      LOGICAL :: NOLAP
 
 C***  VELOCITY OF LIGHT (IN KM/SEC)
       DATA CLIGHT / 2.99792458E5 /
@@ -28,8 +33,8 @@
      >           + EAUTO(IND-LASTIND)
          ENDIF
          XLAMZERO(IND) = 1.E8 / WLAMZERO
-         XLAMBLUE(IND) = XLAMZERO(IND) * (1. - XMAX * VDOP / CLIGHT)
-         XLAMRED(IND)  = XLAMZERO(IND) * (1. + XMAX * VDOP / CLIGHT)
+         XLAMBLUE(IND) = XLAMZERO(IND) * (1. - XMAX * VDOPUNIT/CLIGHT)
+         XLAMRED(IND)  = XLAMZERO(IND) * (1. + XMAX * VDOPUNIT/CLIGHT)
          DO 150 LB=1, MAXLAP
   150    IBLENDS(LB,IND) = 0
   100 CONTINUE
@@ -40,7 +45,7 @@
             IF (INDTEST .LE. LASTIND) THEN 
                IF (EINST(LOW,NUP) .EQ. -2.) CYCLE
             ELSE
-               IF (KRUDAUT(INDTEST-LASTIND) .EQ. 1) CYCLE
+               IF (KRUDAUT(INDTEST-LASTIND)) CYCLE
             ENDIF
 
 C***  SPECIAL BRANCH IF OVERLAP OPTION IS NOT ACTIVE
@@ -57,7 +62,7 @@
             IF (INDTEST .LE. LASTIND) THEN 
                IF (EINST(LOW,NUP) .EQ. -2.) CYCLE
             ELSE
-               IF (KRUDAUT(INDTEST-LASTIND) .EQ. 1) CYCLE
+               IF (KRUDAUT(INDTEST-LASTIND)) CYCLE
             ENDIF
 C***        TEST LINE OVERLAPPING?
             IF ((XLAMBLUE(IND) .LT. XLAMRED (INDTEST)  .AND.
@@ -69,9 +74,10 @@
                LB = LB + 1
 C***           DIMENSION CHECK
                IF (LB .GT. MAXLAP) THEN
-                  WRITE (0,'(A)') '*** Dimension insufficient:'
-                  WRITE (0,'(A,I5)') '*** MAXLAP =', MAXLAP
-                  WRITE (0,'(A)') '*** FATAL ERROR in subr. OVERLAP'
+                  ASSIGN 1000 TO LABEL
+1000              FORMAT ('OVERLAP: DIMENSION MAXLAP = ', I4,
+     >                    ' .LT. LB=', I4)
+                  CALL REMARKF(LABEL, MAXLAP, LB)
                   STOP 'ERROR'
                ENDIF
                IBLENDS(LB,IND) = INDTEST
diff -bur ./owninv.f ../../powr-refactor/src/owninv.f
--- ./owninv.f	2024-07-28 13:13:53.000000000 +0200
+++ ../../powr-refactor/src/owninv.f	2024-07-22 09:27:16.104033925 +0200
@@ -21,6 +21,7 @@
       LOGICAL BNORM
 
       PARAMETER (BNORM = .TRUE.)
+C      PARAMETER (BNORM = .FALSE.)
 C      PARAMETER (NMAX = 560)  old version before split
       PARAMETER (NMAX = 2002)
 
@@ -48,7 +49,7 @@
           R = 0.
           DO L=1, N
             XM = A(L,K)
-            IF (ABS(XM) .GT. 1.E100) THEN
+            IF (ABS(XM) .GT. 1.D100) THEN
               R = 1.
               EXIT
             ENDIF
@@ -82,7 +83,7 @@
       ABSAMAX=0.
       DO 30 J=K,N
         L=N+1-K
-        IMAX=MY_ISAMAX(L,A(K,J),1)+K-1
+        IMAX=ISAMAX(L,A(K,J),1)+K-1
         IF(ABSAMAX.GT.ABS(A(IMAX,J))) GOTO 30
         AMAX=A(IMAX,J)
         ABSAMAX=ABS(AMAX)
diff -bur ./photocs.f ../../powr-refactor/src/photocs.f
--- ./photocs.f	2024-07-28 13:13:54.000000000 +0200
+++ ../../powr-refactor/src/photocs.f	2024-07-22 09:27:16.104033925 +0200
@@ -6,8 +6,8 @@
 C***  THIS ROUTINE IS ONLY CALLED FROM BFCROSS, COOP AND CMFCOOP
 C***********************************************************************
 
+      CHARACTER(8), DIMENSION(1) :: IGAUNT
       DIMENSION ALPHA(1),SEXPO(1)
-      CHARACTER*8 IGAUNT(1)
       DIMENSION ADDCON1(1), ADDCON2(1), ADDCON3(1)
 C***  THE FOLLOWING DATA ARE FOR MIHALAS' GAUNT FACTOR FIT ( HY AND HE II, N=1) 
       DATA A0,A1,A2,A3,AM1,AM2 /
@@ -22,7 +22,8 @@
 C***  althogh this is not a catastrophy. 
 C***  The followong warning might be switched off if annoying.
       IF (WAVENUM .LT. EDGE) THEN
-         WRITE (0,'(a)') '*** WARNING: PHOTOCS CALLED OUTSIDE EDGE FREQUENCY'
+         WRITE (0,'(a)') '*** WARNING: PHOTOCS CALLED '//
+     >          'OUTSIDE EDGE FREQUENCY'
          SIGMA = .0
          RETURN
       ENDIF
@@ -124,6 +125,8 @@
       ENDIF
  
 C***  GII FIT FROM SEATON (1960), REP. PROG. PHYS. 23, P. 313
+C***  using FORMULA (2.4) from page 316
+C***     note that DEN := ( n * (u + 1) )^(-2/3)
 C***  THIS FORMULA IS VALID FOR ALL HYDROGENIC LEVELS,
 C***  I.E.  H I, HE II, ..., C IV, N V, O VI
 C***  VARIABLE SEXPO IS MISUSED TO CARRY THE MAIN QUANTUM NUMBER
diff -bur ./plotacc.f ../../powr-refactor/src/plotacc.f
--- ./plotacc.f	2024-07-28 13:13:56.000000000 +0200
+++ ../../powr-refactor/src/plotacc.f	2024-02-06 10:00:27.875182895 +0100
@@ -1,8 +1,8 @@
       SUBROUTINE PLOTACC(PLOTOPT, AGRAV, AMECH, ARAD, APRESS, ACONT, 
      >                   ATHOM, WORKRATIO, VELO, RADIUS, ND, ATMEAN,
-     >                   RNE, RCON, T, TEFF, RSTAR, XMU, XMSTAR,
-     >                   Rcritical, bFULLHYDROSTAT, 
-     >                   MODHEAD, JOBNUM, hPLOT, HYSTACC)
+     >                   ENTOT, RNE, TAUROSS, RCON, T, TEFF, RSTAR, 
+     >                   XMU, VTURB, XMSTAR, Rcritical, bFULLHYDROSTAT, 
+     >                   bNoARAD, MODHEAD, JOBNUM, hPLOT)
 C******************************************************************************
 C***  DIRECT TRANSFER OF HSUM PLOT
 C***  TOTAL (FREQUENCY-INTEGRATED) FLUX versus DEPTH INDEX
@@ -13,41 +13,50 @@
       INCLUDE 'interfacebib.inc'
 
       INTEGER, PARAMETER :: NDMAX = 200
+      INTEGER, PARAMETER :: NFINE = 10
+      INTEGER, PARAMETER :: NDFINE = NDMAX * NFINE
 
       INTEGER, INTENT(IN) :: ND, JOBNUM, hPLOT
 
       REAL, DIMENSION(ND), INTENT(IN) :: AGRAV, AMECH, ARAD, APRESS, T,
-     >                                   ACONT, ATHOM, VELO, RADIUS, 
-     >                                   RNE, XMU
+     >                                   ACONT, ATHOM, VELO, VTURB, XMU,
+     >                                   RADIUS, ENTOT, RNE, TAUROSS
       REAL, INTENT(IN) :: WORKRATIO, RCON, ATMEAN, XMSTAR, RSTAR, TEFF, 
-     >                    Rcritical, HYSTACC
+     >                    Rcritical
      
-      LOGICAL, INTENT(IN) :: bFULLHYDROSTAT
+      LOGICAL, INTENT(IN) :: bFULLHYDROSTAT, bNoARAD
 
       CHARACTER(110) :: MODHEAD, HEADLINE
-      CHARACTER(8) :: CENTER, CNORM, TEXT_X2
+      CHARACTER(4) :: NormalizeTo
+      CHARACTER(8) :: CENTER, CNORM
       CHARACTER(40) :: XTEXT
-      CHARACTER(20) :: CUROPT, XAXISMODE
+      CHARACTER(20) :: CUROPT, XAXISMODE, YLABEL
       CHARACTER PLOTOPT*(*)
 
-      REAL, DIMENSION(NDMAX) :: X, Y1, Y2, Y3, Y4, Y5, 
-     >                          RI, ANORM, VMACH, VSCRATCH
-
-      INTEGER :: I, L, NPAR, NDIN, Lcand
-      REAL :: XMIN, XMAX, YMIN, YMAX, YMINVAL, XOFF, VINT,
+      REAL, DIMENSION(NDMAX) :: X, Y1, Y2, Y3, Y4, Y5, VSCRATCH, RI
+      REAL, DIMENSION(NDFINE) :: APRESSFINE, XFINE, YPFINE
+      REAL, DIMENSION(ND) :: ANORM, VMACH, RHO
+
+      INTEGER :: I, L, NPAR, NDIN, Lcand, Ltcand, 
+     >           IFINE, NTOTFINE, ITOTFINE
+      REAL :: XMIN, XMAX, YMIN, YMAX, YMINVAL, VINT, XINT,
      >        GEDDL, XLSTAR, XLSTARS, RNEINT, Xcrit,
-     >        XABST, XTICK, XLENGTH, XICON, Rsonic, Vsonic, Xsonic
+     >        XABST, XTICK, XLENGTH, XOFF, XLIN, XICON, 
+     >        Rsonic, Vsonic, Xsonic, Rts, Vts, Xts, XMG,
+     >        RFINE, NTFINE, A2, DA2DR, DNTDR, GFINE, DR
 
-      LOGICAL :: bNormalizeToGEFF
+      LOGICAL :: bBouretStyle, bDisplayFine
 
       INTEGER, EXTERNAL :: IDX
 
       !Physical constants
       REAL, PARAMETER :: PI4 = 12.5663706144    !PI4 = 4*PI
+      REAL, PARAMETER :: AMU = 1.66E-24         !Atomic mass unit (gramm)     
       REAL, PARAMETER :: STEBOL = 5.6705E-5    !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS)
       REAL, PARAMETER :: XLSUN = 3.85E33        !Solar Luminosity (CGS-Units)
       REAL, PARAMETER :: XMSUN = 1.989E33       !XMSUN = Solar Mass (g)
       REAL, PARAMETER :: RGAS = 8.3145E7        !Gas Constant (CGS)
+      REAL, PARAMETER :: GCONST = 6.6727E-8     !Gravitational Constant (CGS)      
 
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
@@ -65,14 +74,16 @@
 
 C***  Decode possible options for x-axis mode
       XAXISMODE = 'DEPTHINDEX'
-      bNormalizeToGEFF = .FALSE.
+      NormalizeTo = 'AGRAV'
+      bDisplayFine = .FALSE.
+      bBouretStyle = .FALSE.
       CALL SARGC (PLOTOPT, NPAR)
       IF (NPAR > 2) THEN
         DO I=3, NPAR
           CALL SARGV (PLOTOPT, I, CUROPT)
           SELECTCASE (CUROPT)
-            CASE ('DEPTHINDEX', 'VELOCITY', 'RADIUS',
-     >            'L', 'R', 'V')
+            CASE ('DEPTHINDEX', 'VELOCITY', 'TAUROSS', 'RADIUS',
+     >            'L', 'R', 'V', 'ENTOT', 'RHO', 'TAU')
 C***          simple keyword option mode            
               XAXISMODE = CUROPT
             CASE ('XAXISMODE', 'X')
@@ -80,7 +91,15 @@
                 CALL SARGV (PLOTOPT, I+1, XAXISMODE)
               ENDIF
             CASE ('GEFF')
-              bNormalizeToGEFF = .TRUE.
+              NormalizeTo = 'GEFF'
+            CASE ('BOURET')
+              XAXISMODE = 'VELOCITY'
+              NormalizeTo = 'THOM'
+              bBouretStyle = .TRUE.
+            CASE ('FINE')
+              NormalizeTo = 'GRAV'
+              bDisplayFine = .TRUE.
+              bBouretStyle = .FALSE.
           ENDSELECT
         ENDDO
       ELSE 
@@ -88,13 +107,19 @@
         PLOTOPT = PLOTOPT(:IDX(PLOTOPT)) // ' L'
       ENDIF
 
+      IF (bBouretStyle .AND. bNoARAD) THEN
+         WRITE (hCPR,'(A)') 'PLOTACC: WARNING - No ARAD calculated yet'
+         WRITE (hCPR,'(A)') 'PLOTACC: *** PLOT ACC BOURET SKIPPED ***'
+         RETURN
+      ENDIF
+
       XLSTAR = PI4 * STEBOL * RSTAR*RSTAR * TEFF*TEFF*TEFF*TEFF
       XLSTARS = XLSTAR / XLSUN
 
       ANORM(ND) = 0.
       DO L=1, ND-1
         RI(L) = 0.5 * ( RADIUS(L) + RADIUS(L+1) )      
-        IF (bNormalizeToGEFF) THEN
+        IF (NormalizeTo == 'GEFF') THEN
           !calculate depth-dependend GEFF 
           IF (bFULLHYDROSTAT) THEN
             !calculate geff with full a_rad
@@ -106,6 +131,9 @@
           ENDIF
           ANORM(L) = AGRAV(L) * ( 1. - GEDDL )
           CNORM = 'g&Teff&M'
+        ELSEIF (NormalizeTo == 'THOM') THEN
+          ANORM(L) = ATHOM(L)
+          CNORM = 'g&Telec&M'
         ELSE
           ANORM(L) = AGRAV(L)
           CNORM = 'g'
@@ -126,43 +154,122 @@
         CALL SPLINPOX(Vsonic,Rsonic,VMACH,RADIUS,ND)
       ENDIF
       
+      !Find "true" sonic point (incl. VTURB)
+      Ltcand = 0
+      DO L=1, ND
+        VSCRATCH(L) = VELO(L) - SQRT(VMACH(L)**2 + VTURB(L)**2)        
+        IF ((VSCRATCH(L) < 0) .AND. (Ltcand == 0)) THEN
+          Ltcand = L
+        ENDIF
+      ENDDO
+      IF (Ltcand > 1) THEN
+        CALL SPLINPOX(Rts,0.,RADIUS,VSCRATCH,ND,.FALSE.,Ltcand)
+        CALL SPLINPOX(Vts,Rts,VELO,RADIUS,ND)
+      ENDIF
+
+      DO L=1, ND
+        VSCRATCH(L) = VMACH(L)**2 + VTURB(L)**2
+      ENDDO
+      XMG = GCONST * XMSTAR * XMSUN
+      DO L=1, ND
+        IF (L > 1) THEN
+          DR = RADIUS(L-1) - RADIUS(L)
+          DO IFINE=1, NFINE
+            ITOTFINE = (L-2)*NFINE + IFINE + 1
+            RFINE = RADIUS(L-1) - FLOAT(IFINE)/FLOAT(NFINE) * DR
+            CALL SPLINPOX(NTFINE,RFINE,ENTOT,RADIUS,ND,DFDX=DNTDR)
+            CALL SPLINPOX(A2,RFINE,VSCRATCH,RADIUS,ND,DFDX=DA2DR)
+            APRESSFINE(ITOTFINE) = - A2/NTFINE * DNTDR - DA2DR
+            APRESSFINE(ITOTFINE) = APRESSFINE(ITOTFINE)*1.E10/RSTAR
+            IF (APRESSFINE(ITOTFINE) > 0.) THEN
+              GFINE = XMG/(RFINE*RSTAR)**2
+              YPFINE(ITOTFINE) = LOG10(APRESSFINE(ITOTFINE)/GFINE)
+            ENDIF
+            SELECTCASE (XAXISMODE)
+              CASE ('DEPTHINDEX', 'L')
+                XFINE(ITOTFINE) = FLOAT(L-1) + FLOAT(IFINE)/FLOAT(NFINE)
+              CASE ('RADIUS')
+                IF (RFINE > 1.) THEN
+                  XFINE(ITOTFINE) = LOG10(RFINE - 1.)
+                ELSE
+                  XFINE(ITOTFINE) = -100.
+                ENDIF
+              CASE ('VELOCITY', 'V')
+                CALL SPLINPOX(XFINE(ITOTFINE),RFINE,VELO,RADIUS,ND)
+                XFINE(ITOTFINE) = XFINE(ITOTFINE)/VELO(1)
+              CASE ('ENTOT')
+                XFINE(ITOTFINE) = LOG10(NTFINE)
+              CASE ('RHO')
+                XFINE(ITOTFINE) = LOG10(NTFINE * AMU * ATMEAN)
+              CASE ('TAU', 'TAUROSS')
+                CALL SPLINPOX(XFINE(ITOTFINE),RFINE,TAUROSS,RADIUS,ND)
+            ENDSELECT
+          ENDDO
+        ELSE
+          RFINE = RADIUS(L)
+          CALL SPLINPOX(NTFINE,RFINE,ENTOT,RADIUS,ND,DFDX=DNTDR)
+          CALL SPLINPOX(A2,RFINE,VSCRATCH,RADIUS,ND,DFDX=DA2DR)
+          APRESSFINE(1) = - A2/NTFINE * DNTDR - DA2DR        
+          APRESSFINE(1) = APRESSFINE(1)*1.E10/RSTAR
+          IF (APRESSFINE(1) > 0.) THEN
+            GFINE = XMG/(RFINE*RSTAR)**2
+            YPFINE(1) = LOG10(APRESSFINE(1)/GFINE)
+          ENDIF
+          SELECTCASE (XAXISMODE)
+            CASE ('DEPTHINDEX', 'L')
+              XFINE(1) = 1.
+            CASE ('RADIUS', 'R')
+              XFINE(1) = LOG10(RFINE - 1.)
+            CASE ('VELOCITY', 'V')
+              XFINE(1) = 1.
+            CASE ('ENTOT')
+              XFINE(1) = LOG10(NTFINE)
+            CASE ('RHO')
+              XFINE(1) = LOG10(NTFINE * AMU * ATMEAN)
+            CASE ('TAU', 'TAUROSS')
+              XFINE(1) = -100.
+          ENDSELECT
+        ENDIF
+      ENDDO
+      NTOTFINE = (ND-1)*NFINE + 1
       
       IF (XAXISMODE == 'DEPTHINDEX' .OR. XAXISMODE == 'L') THEN 
 C***     X-Axis = Depth Index
          XTEXT = CENTER//'DEPTH INDEX L'
          XMIN = 0.
          XMAX = FLOAT(ND)
-         TEXT_X2 = ' XMAX '
          XTICK = 5.
          XABST = 10. 
-C         DO L=1, ND-2
          DO L=1, ND-1
             X(L) = FLOAT(L) + 0.5
          ENDDO
          IF (Lcand > 1 .AND. Lcand < ND) THEN
-           CALL SPLINPOX(Xsonic,Rsonic,X,RI,ND)         
+           CALL SPLINPOX(Xsonic,Rsonic,X,RI,ND-1)         
+         ENDIF
+         IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+           CALL SPLINPOX(Xts,Rts,X,RI,ND-1)         
          ENDIF
       ELSEIF (XAXISMODE == 'VELOCITY' .OR. XAXISMODE == 'V') THEN
 C***     X-Axis: velocity / v_infty
          XTEXT = CENTER//'v(r) / v' // CHAR(92) // '8'
          XMIN = 0.
          XMAX = 1.
-         TEXT_X2 = ' XMIN '
          XTICK = 0.1
          XABST = 0.5 
-C         DO L=1, ND-2
          DO L=1, ND-1
            CALL SPLINPOX(VINT, RI(L), VELO, RADIUS, ND)
            X(L) = VINT/VELO(1)
          ENDDO
-         IF (Lcand > 1 .AND. Lcand < ND) THEN
+         IF (Lcand > 1) THEN
            Xsonic = Vsonic/VELO(1)
          ENDIF
+         IF (Ltcand > 1) THEN
+           Xts = Vts/VELO(1)
+         ENDIF
       ELSEIF (XAXISMODE == 'RADIUS' .OR. XAXISMODE == 'R') THEN
          XTEXT = CENTER//'LOG (R/R\*-1)'
          XMIN = LOG10 ( 0.9 * (RI(ND-1) - 1.) )
          XMAX = LOG10 ( RADIUS(1) - 1. )
-         TEXT_X2 = ' XMIN '
          XTICK = 0.2
          XABST = 1.0 
          DO L=1, ND-1
@@ -171,6 +278,60 @@
          IF (Lcand > 1 .AND. Lcand < ND) THEN
            Xsonic = LOG10( Rsonic - 1. )
          ENDIF
+         IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+           Xts = LOG10( Rts - 1. )
+         ENDIF
+      ELSEIF (XAXISMODE == 'TAUROSS' .OR. XAXISMODE == 'TAU') THEN
+         XTEXT = CENTER//'log #t#&TRoss&M'
+         XMIN = LOG10(0.4 * TAUROSS(2))
+         XMAX = LOG10( TAUROSS(ND) )
+         XTICK = 0.1
+         XABST = 1.0 
+         DO L=1, ND-1
+           CALL SPLINPOX(XINT, RI(L), TAUROSS, RADIUS, ND)
+           X(L) = LOG10(XINT)
+         ENDDO
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RI,ND-1)         
+         ENDIF
+         IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+           CALL SPLINPOX(Xts,Rts,X,RI,ND-1)         
+         ENDIF
+      ELSEIF (XAXISMODE == 'ENTOT' .OR. XAXISMODE == 'N') THEN
+         XTEXT = CENTER // 'log(&Rn&N&Ttot&M/cm&H-3&M)'
+         XMIN = LOG10(ENTOT(1))
+         XMAX = LOG10(ENTOT(ND))
+         XTICK = 1.
+         XABST = 3.
+         DO L=1, ND-1
+           CALL SPLINPOX(XINT, RI(L), ENTOT, RADIUS, ND)
+           X(L) = LOG10(XINT)
+         ENDDO      
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RADIUS,ND-1)         
+         ENDIF      
+         IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+           CALL SPLINPOX(Xts,Rts,X,RADIUS,ND-1)         
+         ENDIF
+      ELSEIF (XAXISMODE == 'RHO' .OR. XAXISMODE == 'DENS') THEN
+         XTEXT = CENTER // 'log(&R#r#&N/(g cm&H-3&M))'
+         DO L=1, ND
+           RHO(L) = ENTOT(L) * AMU * ATMEAN
+         ENDDO         
+         XMIN = LOG10(RHO(1))
+         XMAX = LOG10(RHO(ND))
+         XTICK = 1.
+         XABST = 2.
+         DO L=1, ND-1
+           CALL SPLINPOX(XINT, RI(L), RHO, RADIUS, ND)
+           X(L) = LOG10(XINT)
+         ENDDO      
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RI,ND-1)         
+         ENDIF           
+         IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+           CALL SPLINPOX(Xts,Rts,X,RI,ND-1)         
+         ENDIF
       ELSE
          WRITE (hCPR,*) 'PLOTACC: Invalid XAXISMODE ************'
          WRITE (hCPR,*) '***** The following plot was aborted:'
@@ -183,7 +344,6 @@
 
       HEADLINE = 'ACC:'//MODHEAD(13:)
       WRITE (HEADLINE(90:), '(A8,I7)') ' JOB No.', JOBNUM
-C    9 FORMAT (19X,1HJ,I3)
 
       WRITE (hPLOT, '(A)') '*NEXTPLOT: ' // PLOTOPT
       WRITE (hPLOT, '(A)') 'PLOT: ' // HEADLINE
@@ -191,7 +351,6 @@
       WRITE (hPLOT, '(A)') '\DEFINECOLOR 5 1.0 0.58 0.0'
       WRITE (hPLOT, '(A)') '\DEFINECOLOR 7 0.0 0.50 0.0'
       WRITE (hPLOT, '(A)') '\DEFINECOLOR 9 0.6 0.60 0.6'
-      WRITE (hPLOT, '(A)') '\DEFINECOLOR 8 0.6 0.8 1.0'
       WRITE (hPLOT, '(A)') '\PEN=1'     !needed to get rid of definecolor pen bug 
 
       WRITE (hPLOT, '(A)') '\COLOR=3'
@@ -209,7 +368,6 @@
      >      '\LUNA ',XICON,' YMAX 0. -0.2 0.2 -90  R&Tcon'
         ENDIF
       ENDIF
-
       IF (Lcand > 1 .AND. Lcand < ND) THEN
         IF (ABS(Xsonic) >= 0.005) THEN
           WRITE (hPLOT, '(A,F12.5,A,F12.5,A)') 
@@ -219,8 +377,17 @@
      >      '\LUNA ',Xsonic,' YMAX 0. -0.2 0.2 -90  R&Tsonic'
         ENDIF
       ENDIF
-      IF (Rcritical >= RI(ND) .AND. Rcritical <= RI(1)) THEN
-        CALL SPLINPOX(Xcrit, Rcritical, X, RI, ND)
+      IF (Ltcand > 1 .AND. Ltcand < ND) THEN
+        IF (ABS(Xts) >= 0.005) THEN
+          WRITE (hPLOT, '(A,F12.5,A,F12.5,A)') 
+     >      '\LINUN ',Xts,' YMIN ',Xts,
+     >                    ' YMAX 0. 0. SYMBOL=20 SIZE=0.025'
+          WRITE (hPLOT, '(A,F12.5,A)') 
+     >      '\LUNA ',Xts,' YMAX 0. -0.2 0.2 -90  R&Tts'
+        ENDIF
+      ENDIF
+      IF (Rcritical >= RI(ND-1) .AND. Rcritical <= RI(1)) THEN
+        CALL SPLINPOX(Xcrit, Rcritical, X, RI, ND-1)
         IF (Xcrit >= 0.005) THEN
           WRITE (hPLOT, '(A,F6.3,A,F6.3,A)') 
      >      '\LINUN ',Xcrit,' YMIN ',Xcrit,' YMAX 0. 0. SYMBOL=9'
@@ -229,16 +396,6 @@
         ENDIF
       ENDIF
       WRITE (hPLOT, '(A)') '\BGRLUN OFF'
-
-      IF (HYSTACC .GT. 0.) THEN
-         WRITE (hPLOT, '(A)') '* HYDROSTATIC INTEGRATION EPSILON'
-         WRITE (hPLOT, '(A)') '\COLOR = 8'
-         WRITE (hPLOT, '(A,F6.3,1X,F6.3,A,F6.3,A)')
-     >    '\RECT ', XICON, ALOG10(1. - HYSTACC), TEXT_X2, ALOG10(1. + HYSTACC),
-     >    '  0 0 FILLED'         
-      ENDIF
-
-
       WRITE (hPLOT, '(A)') '\COLOR=1'
 
       WRITE (hPLOT, '(A,F6.3)') 
@@ -247,54 +404,79 @@
       WRITE (hPLOT, '(A)') '\INBOX'
 
       XLENGTH = 2.5
-      XOFF = XLENGTH + 14. + 0.5
+      IF (bBouretStyle) THEN
+        XLIN = 2.
+        XOFF = XLENGTH + XLIN + 0.5
+        
+C***    ACC plot in the coloring from Bouret et al. (2012)
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -1. SYMBOL=5'
+        WRITE (hPLOT, '(A,F4.1,A)') '\LUN XMIN YMAX ', XOFF, ' M-1.'
+     >   // ' 0.3 (a&Tmech&M+g)/' // CNORM
+
+        WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=2'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH,' 0 ',XLIN,' -1.5 SYMBOL=5'
+        WRITE (hPLOT, '(A,F4.1,A)') '\LUN XMIN YMAX ', XOFF, ' M-1.5'
+     >   // ' 0.3 (a&Tmech&M-a&Tpress&M+g)/' // CNORM
+
+        WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=4'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -2. SYMBOL=5'
       WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -1. SYMBOL=5'
+     >   'LUN XMIN YMAX ', XOFF, ' M-2.0 0.3 a&Trad&M/' // CNORM
+
+        WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=7'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -2.5 SYMBOL=9'
+        WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
+     >   'LUN XMIN YMAX ', XOFF, ' M-2.5 0.3 a&Tcont&M/' // CNORM     
+      ELSE
+        XLIN = 14.
+        XOFF = XLENGTH + XLIN + 0.5
+        
+C***    Standard ACC plot colors           
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -1. SYMBOL=5'
       WRITE (hPLOT, '(A,F4.1,A)') '\LUN XMIN YMAX ', XOFF, ' M-1.'
      > // ' 0.3 (' // CNORM(:IDX(CNORM)) // '+a&Tmech&M)/' // CNORM
 
       WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=2'
-      WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -1.5 SYMBOL=9'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -1.5 SYMBOL=9'
       WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
      > 'LUN XMIN YMAX ', XOFF, ' M-1.5 0.3 a&Trad&M/' // CNORM
 
       WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=4'
-      WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -2. SYMBOL=5'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -2. SYMBOL=5'
       WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
      > 'LUN XMIN YMAX ', XOFF, ' M-2. 0.3 a&Tmech&M/' // CNORM
 
       WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=7'
-      WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -2.5 SYMBOL=9'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -2.5 SYMBOL=9'
       WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
      > 'LUN XMIN YMAX ', XOFF, ' M-2.5 0.3 a&Tcont&M/' // CNORM
 
       WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=2'
-      WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -3 SYMBOL=5'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -3 SYMBOL=5'
       WRITE (hPLOT, '(A,F4.1,A)') '\LUN ' //
      > 'XMIN YMAX ', XOFF, ' M-3.0 0.3 (a&Trad&M+a&Tpress&M)/' // CNORM
 
       WRITE (hPLOT, '(A)') CHAR(92) // 'COLOR=5'
-      WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
-     > 'LINREL XMIN YMAX ',XLENGTH,' 0 14. -3.5 SYMBOL=9 SIZE=0.05'
+        WRITE (hPLOT, '(A,2(F4.1,A))') CHAR(92) // 
+     >   'LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -3.5 '
+     >                                       // ' SYMBOL=9 SIZE=0.05'
       WRITE (hPLOT, '(A,F4.1,A)') CHAR(92) // 
      > 'LUN XMIN YMAX ', XOFF, ' M-3.5 0.3 a&Tpress&M/' // CNORM
 
       WRITE (hPLOT, '(A)') '\COLOR=6'
-      WRITE (hPLOT, '(A,F4.1,A)') 
-     > '\LINREL XMIN YMAX ',XLENGTH,' 0 14. -4.0  SYMBOL=5'
+        WRITE (hPLOT, '(A,2(F4.1,A))') 
+     >   '\LINREL XMIN YMAX ',XLENGTH, ' 0 ', XLIN, ' -4.0  SYMBOL=5'
       WRITE (hPLOT, '(A,F4.1,A)') '\LUN XMIN YMAX ', XOFF,
      > ' M-4.0 0.3 a&Tthom&M/' // CNORM
-
-      IF (HYSTACC .GT. 0.) THEN
-       WRITE (hPLOT, '(A)') '\COLOR=8'
-       WRITE (hPLOT, '(A,F4.1,1X,F4.1,A)') 
-     >  '\RECTLUN XMIN YMAX  14. -4.6 ', XLENGTH, 0.2, ' FILLED '
-       WRITE (hPLOT, '(A,F4.1,A)') '\LUN XMIN YMAX ', XOFF,
-     >  ' M-4.5 0.3 \+#e#&T&EHYD CONVERGENCE&M'
       ENDIF
       
       WRITE (hPLOT, '(A)') '\COLOR=1'
@@ -303,23 +485,21 @@
 C***  Note: HTOT may not be calculated if STEAL is used for OUTPUT ONLY
       YMIN = 0.
       YMAX = 0.
-cc      YMIN = -1.
-cc      YMAX =  1.
       DO L=1, ND-1
          Y1(L) = (ANORM(L) + AMECH(L))/ANORM(L)
          Y2(L) = ARAD(L)/ANORM(L)
          Y3(L) = AMECH(L)/ANORM(L)
          Y4(L) = ACONT(L)/ANORM(L)
          Y5(L) = APRESS(L)/ANORM(L)
-cc         IF ((Y1(L) .GT. 0.) .AND. (Y2(L) .GT. 0.)) THEN
-cc            YMAX = ALOG10(MAX(10**YMAX, 1.05*Y1(L), 1.05*Y2(L)))
-cc            YMIN = ALOG10(MIN(10**YMIN, 0.95*Y1(L), 0.95*Y2(L)))
-cc         ENDIF
+        IF (.NOT. bBouretStyle) THEN
          IF (Y1(L) > .0) Y1(L) = LOG10(Y1(L))
          IF (Y2(L) > .0) Y2(L) = LOG10(Y2(L))
          IF (Y3(L) > .0) Y3(L) = LOG10(Y3(L))
          IF (Y4(L) > .0) Y4(L) = LOG10(Y4(L))
          IF (Y5(L) > .0) Y5(L) = LOG10(Y5(L))
+        ELSE
+          Y1(L) = (AGRAV(L) + AMECH(L))/ANORM(L)
+        ENDIF
       ENDDO
 
 C***  Restrict blue curve (AMECH) to inbox area
@@ -330,12 +510,31 @@
         IF (Y3(L) < YMINVAL) EXIT
       ENDDO
 
+      IF (bBouretStyle) THEN
+        YLABEL = 'a/g&Telec&M         '
+      ELSE
+        YLABEL = 'log&T10&M(a/g)      '
+      ENDIF      
+      
       CALL PLOTANF (hPLOT,HEADLINE, '&E'//HEADLINE,
-     $        XTEXT, CENTER//'log&T10&M(a/g)',
+     $        XTEXT, CENTER//YLABEL,
      >        0., XMIN, XMAX, XTICK, XABST, 0.,
      >        0., YMIN, YMAX, .1,  0.2, 0.,
      $        X, Y1, ND-1, 5)
 
+      IF (bBouretStyle) THEN
+C***    ACC plot in the coloring from Bouret et al. (2012)
+        CALL PLOTCONS (hPLOT,X,Y2,ND-1,'COLOR=4') 
+        
+        DO L=1, ND-1
+          Y2(L) = (AMECH(L)-APRESS(L)+AGRAV(L))/ANORM(L)
+        ENDDO
+        CALL PLOTCONS (hPLOT,X,Y2,ND-1,'COLOR=2') 
+C***    Also show pure continuum contribution
+        CALL PLOTCONS (hPLOT,X,Y4,ND-1,'COLOR=7 SYMBOL=9 SIZE=0.1') 
+        
+      ELSE
+C***    Standard ACC plot colors     
       CALL PLOTCONS (hPLOT,X,Y2,ND-1,'COLOR=2 SYMBOL=9 SIZE=0.1') 
       CALL PLOTCONS (hPLOT,X,Y3,NDIN,'COLOR= 4') 
       CALL PLOTCONS (hPLOT,X,Y4,ND-1,'COLOR=7 SYMBOL=9 SIZE=0.1') 
@@ -354,5 +553,11 @@
       ENDDO
       CALL PLOTCONS (hPLOT,X,Y2,ND-1,'COLOR=6') 
 
+        IF (bDisplayFine) THEN
+          CALL PLOTCONS (hPLOT,XFINE,YPFINE,NTOTFINE,
+     >                               'COLOR=6 SYMBOL=9 SIZE=0.05') 
+        ENDIF
+      ENDIF
+      
       RETURN
       END
diff -bur ./plotalpha.f ../../powr-refactor/src/plotalpha.f
--- ./plotalpha.f	2024-07-28 13:13:56.000000000 +0200
+++ ../../powr-refactor/src/plotalpha.f	2023-11-21 10:10:55.289269787 +0100
@@ -1,26 +1,38 @@
-      SUBROUTINE PLOTALPHA (ND ,RADIUS, ALPHAF, MODHEAD, JOBNUM, bOwn)
+      SUBROUTINE PLOTALPHA (PLOTOPT, ND, RADIUS, ALPHAF, VMACH,
+     >                      VELO, TAUROSS, ENTOT, ATMEAN,
+     >                      MODHEAD, JOBNUM, bOwn)
 C******************************************************************************
 C***  PLOT FORCE MULTIPLIER PARAMETER ALPHA VS DEPTH POINT OR LOG(R/R*-1)
 C******************************************************************************
 
       IMPLICIT NONE
+      INCLUDE 'interfacebib.inc'
 
       INTEGER, PARAMETER :: NDMAX = 100
       INTEGER, INTENT(IN) :: ND, JOBNUM
       CHARACTER(100), INTENT(IN) :: MODHEAD
-      REAL, DIMENSION(ND) :: RADIUS, ALPHAF
+      REAL, DIMENSION(ND) :: RADIUS, ALPHAF, VSCRATCH, RI,
+     >                       VELO, VMACH, TAUROSS, ENTOT, RHO
       LOGICAL, INTENT(IN) :: bOwn           !own plot file or part of wruniq.plot?
 
       REAL, DIMENSION(NDMAX) :: X, Y
       CHARACTER(60) :: HEAD1, HEAD2
+      CHARACTER(40) :: XTEXT
       CHARACTER(10) :: CTIME
-      CHARACTER(8) :: CDATE
+      CHARACTER(8) :: CDATE, CENTER
+      CHARACTER(20) :: CUROPT, XAXISMODE      
+      CHARACTER PLOTOPT*(*)
 
-      INTEGER :: L
-      REAL :: XMIN, XMAX, YMIN, YMAX, 
+      INTEGER :: L, NPAR, I, Lcand
+      REAL :: XMIN, XMAX, YMIN, YMAX, Xsonic, Rsonic, Vsonic, ATMEAN,
      >        XSCALE, XTICK, XABST,
      >        YSCALE, YTICK, YABST
 
+      INTEGER, EXTERNAL :: IDX
+     
+      !Physical constants
+      REAL, PARAMETER :: AMU = 1.66E-24         !Atomic mass unit (gramm)     
+     
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
@@ -36,20 +48,149 @@
         CALL REMARK ('FORCE MULTIPLIERS TO BE ROUTED')
       ENDIF
         
+      XAXISMODE = 'DEPTHINDEX'
+      CALL SARGC (PLOTOPT, NPAR)
+      IF (NPAR > 2) THEN
+        parloop: DO I=3, NPAR
+          CALL SARGV (PLOTOPT, I, CUROPT)
+          IF (CUROPT == 'XAXISMODE' .OR. CUROPT == 'X') THEN
+            IF (NPAR >= (I+1)) THEN
+              CALL SARGV (PLOTOPT, I+1, CUROPT)
+            ELSE
+              CYCLE parloop
+            ENDIF
+          ENDIF
+          SELECTCASE (CUROPT)
+            CASE ('VELOCITY', 'VELO', 'V')
+              XAXISMODE = 'VELOCITY'
+            CASE ('TAUROSS', 'TAU')
+              XAXISMODE = 'TAUROSS'
+            CASE ('RADIUS', 'R')
+              XAXISMODE = 'RADIUS'
+            CASE ('DEPTHINDEX', 'INDEX', 'ND')
+              XAXISMODE = 'DEPTHINDEX'
+            CASE ('N', 'NTOT', 'ENTOT', 'PARTDENS')
+              XAXISMODE = 'ENTOT'
+            CASE ('RHO', 'DENS', 'DENSITY')
+              XAXISMODE = 'RHO'
+          ENDSELECT
+        ENDDO parloop
+      ENDIF
+ 
+ 
+      !Find sonic point parameters
+      Lcand = 0
+      DO L=1, ND
+        IF (L /= ND) THEN
+          RI(L) = 0.5 * ( RADIUS(L) + RADIUS(L+1) )
+        ENDIF
+        VSCRATCH(L) = VELO(L) - VMACH(L)        
+        IF ((VSCRATCH(L) < 0) .AND. (Lcand == 0)) THEN
+          Lcand = L
+        ENDIF
+      ENDDO
+      IF (Lcand > 1) THEN
+        CALL SPLINPOX(Rsonic,0.,RADIUS,VSCRATCH,ND,.FALSE.,Lcand)
+        CALL SPLINPOX(Vsonic,Rsonic,VMACH,RADIUS,ND)
+      ENDIF
+      
  
 C***  HEADER  ------------------------------------------------------
       HEAD1=' FORCE MULTIPLIER PARAMETER ALPHA VERSUS DEPTH INDEX'
       HEAD2      = MODHEAD(13:32)
       HEAD2(22:) = 'FORCE MULTIPLIER ALPHA(L)'
 
+      CENTER = '\CENTER\'
+      
 C***  X-AXIS: ----------------------------------------------------------
 C***  DEPTH POINT INDEX
 C***  @TODO: IMPLEMENT RADIUS OPTION
-      XMAX=FLOAT(ND)
-      XMIN=0.
-      XSCALE = 22./(XMAX-XMIN)
-      XTICK=5.
-      XABST=10.
+
+      IF (XAXISMODE == 'DEPTHINDEX') THEN 
+C***     X-Axis = Depth Index
+         XTEXT = CENTER//'DEPTH INDEX L'
+         XMIN = 0.
+         XMAX = FLOAT(ND)
+         XTICK = 5.
+         XABST = 10. 
+         DO L=1, ND-1
+            X(L) = FLOAT(L) + 0.5
+         ENDDO
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RADIUS,ND-1)         
+         ENDIF
+      ELSEIF (XAXISMODE == 'VELOCITY') THEN
+C***     X-Axis: velocity / v_infty
+         XTEXT = CENTER//'v(r) / v\8'
+         XMIN = 0.
+         XMAX = 1.
+         XTICK = 0.1
+         XABST = 0.5 
+C         DO L=1, ND-2
+         DO L=1, ND-1
+            X(L) = 0.5 * (VELO(L) + VELO(L+1)) / VELO(1)
+         ENDDO
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           Xsonic = Vsonic/VELO(1)
+         ENDIF
+      ELSEIF (XAXISMODE == 'TAUROSS') THEN
+         XTEXT = CENTER//'LOG Rosseland Optical Depth #t#'
+         XMIN = LOG10(0.9 * TAUROSS(2))
+         XMAX = LOG10( TAUROSS(ND) )
+         XTICK = 0.1
+         XABST = 1.0 
+         DO L=1, ND-1
+           X(L) = LOG10 (0.5 * (TAUROSS(L) + TAUROSS(L+1)))
+         ENDDO
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RADIUS,ND-1)         
+         ENDIF
+      ELSEIF (XAXISMODE == 'RADIUS') THEN
+         XTEXT = CENTER//'LOG (R/R\*-1)'
+         XMIN = LOG10 ( 0.9 * (RI(ND-1) - 1.) )
+         XMAX = LOG10 ( RADIUS(1) - 1. )
+         XTICK = 0.1
+         XABST = 0.5 
+         DO L=1, ND-1
+           X(L) = LOG10( RI(L) - 1. )
+         ENDDO
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           Xsonic = LOG10( Rsonic - 1. )
+         ENDIF
+      ELSEIF (XAXISMODE == 'ENTOT') THEN
+         XTEXT = CENTER // 'log(&Rn&N&Ttot&M/cm&H-3&M)'
+         XMIN = LOG10(ENTOT(1))
+         XMAX = LOG10(ENTOT(ND))
+         XTICK = 1.
+         XABST = 3.
+         DO L=1, ND-1
+           X(L) = LOG10(0.5 * (ENTOT(L) + ENTOT(L+1)))
+         ENDDO      
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RADIUS,ND-1)         
+         ENDIF      
+      ELSEIF (XAXISMODE == 'RHO') THEN
+         XTEXT = CENTER // 'log(&R#r#&N/(g cm&H-3&M))'
+         DO L=1, ND
+           RHO(L) = ENTOT(L) * AMU * ATMEAN
+         ENDDO         
+         XMIN = LOG10(RHO(1))
+         XMAX = LOG10(RHO(ND))
+         XTICK = 1.
+         XABST = 2.
+         DO L=1, ND-1
+           X(L) = LOG10(0.5 * (RHO(L) + RHO(L+1)))
+         ENDDO      
+         IF (Lcand > 1 .AND. Lcand < ND) THEN
+           CALL SPLINPOX(Xsonic,Rsonic,X,RADIUS,ND-1)         
+         ENDIF      
+      ELSE
+         WRITE (hCPR,*) 'PLOTACC: Invalid XAXISMODE ************'
+         WRITE (hCPR,*) '***** The following plot was aborted:'
+         WRITE (hCPR,*) PLOTOPT(:IDX(PLOTOPT))
+         RETURN
+      ENDIF
+      
 
 C***  Y-AXIS:  ---------------------------------------------------------
 C***  ALPHA RANGE (AUTO)
@@ -61,7 +202,6 @@
 
 C***  DATA TABLE ------------------------------------
       DO L=1, ND-1
-        X(L) = FLOAT(L)
         Y(L) = ALPHAF(L)
       ENDDO
  
@@ -84,9 +224,9 @@
      >   CTIME(1:2), ':', CTIME(3:4), ')'
 
       CALL PLOTANF (hPLOT,HEAD1,HEAD2
-     >        ,'\CENTER\depth index'
+     >        ,XTEXT
      >        ,'\CENTER\force multiplier parameter #a#'
-     >        ,XSCALE,XMIN,XMAX,XTICK,XABST,.0
+     >        ,0.,XMIN,XMAX,XTICK,XABST,.0
      >        ,YSCALE,0.,0.,YTICK,YABST,.0
      >        ,X,Y,ND-1, 5)
  
diff -bur ./plotanf.f ../../powr-refactor/src/plotanf.f
--- ./plotanf.f	2024-07-28 13:13:56.000000000 +0200
+++ ../../powr-refactor/src/plotanf.f	2023-11-21 10:10:55.293269795 +0100
@@ -4,33 +4,44 @@
 C***********************************************************************
 C***  DIESE ROUTINE BEREITET EIN NEUES PLOTFILE ZUR UEBERTRAGUNG VOR
 C***  DIE ANGEGEBENEN WERTE BESCHREIBEN DEN PLOTKASTEN
+C***  Use NPLOT = '' in CALL PLOTANF to skip the "PLOT:" line
 C***********************************************************************
       CHARACTER*(*) NPLOT,NHEAD,NX,NY
+      INTEGER, EXTERNAL :: IDX
 
+      IF (IDX(NPLOT) > 0) THEN
+        !Some plots insert their own "PLOT:"-line to allows KASDEF commands
+        ! before the coordinate box. Therefore only write "PLOT:"-line if not empty!
       WRITE (KANAL,1) NPLOT
+      ENDIF
       WRITE (KANAL, '(A)') 'KASDEF FONT=HELVET'
       WRITE (KANAL,2) NHEAD
-      WRITE(KANAL,3) NX
+      WRITE (KANAL,3) NX
       WRITE (KANAL,4) NY
     1 FORMAT (' PLOT   :',A)
     2 FORMAT (' HEADER :',A)
     3 FORMAT (' X-ACHSE:',A)
     4 FORMAT (' Y-ACHSE:',A)
 
-C***  Special branch activating Lars' AUTO axes: set XMIN = XMAX!
-      IF (B2 .EQ. B3) THEN
-         WRITE (KANAL, 6)
+C***  Special branch activating Lars' AUTO axes: set XMIN = XMAX and/or YMIN = YMAX!
+      IF (B2 == B3 .AND. C2 == C3) THEN
+         WRITE (KANAL, 5)
+    5   FORMAT (5X,
+     > 'MASSTAB    MINIMUM    MAXIMUM    TEILUNGEN  BESCHRIFT. DARUNTER'
+     >  / ,' X: AUTO',/,' Y: ')
+      ELSEIF (B2 == B3) THEN
+         WRITE (KANAL, 6) C1,C2,C3,C4,C5,C6
     6   FORMAT (5X,
      $ 'MASSTAB    MINIMUM    MAXIMUM    TEILUNGEN  BESCHRIFT. DARUNTER'
-     $  / ,' X: AUTO',/,' Y: ')
+     $  / ,' X: AUTOX',/,' Y: ',6(G12.6,1X))
       ELSE IF (C2 .EQ. C3) THEN
         WRITE (KANAL,7) B1,B2,B3,B4,B5,B6
     7   FORMAT (5X,
      $ 'MASSTAB    MINIMUM    MAXIMUM    TEILUNGEN  BESCHRIFT. DARUNTER'
      $  / ,' X: ',6(G12.6,1X),/,' Y: AUTO')
       ELSE 
-        WRITE (KANAL,5) B1,B2,B3,B4,B5,B6,C1,C2,C3,C4,C5,C6
-    5   FORMAT (5X,
+        WRITE (KANAL,8) B1,B2,B3,B4,B5,B6,C1,C2,C3,C4,C5,C6
+    8   FORMAT (5X,
      $ 'MASSTAB    MINIMUM    MAXIMUM    TEILUNGEN  BESCHRIFT. DARUNTER'
      $  / ,' X: ',6(G12.6,1X),/,' Y: ',6(G12.6,1X))
       ENDIF
diff -bur ./plotcbb.f ../../powr-refactor/src/plotcbb.f
--- ./plotcbb.f	2024-07-28 13:13:57.000000000 +0200
+++ ../../powr-refactor/src/plotcbb.f	2023-09-27 10:14:15.117755680 +0200
@@ -8,9 +8,9 @@
 C***  SET ARRAY DIMENSION PARAMETERS
 C***  IRON: ADD GENERIC ION TO MAXATOM
       PARAMETER ( MAXATOM =          26 )
-      PARAMETER ( NDIM    =        2560 )
+      PARAMETER ( NDIM    =        1560 )
       PARAMETER ( MAXAUTO =        2400 )
-      PARAMETER ( MAXIND  =       45000 )
+      PARAMETER ( MAXIND  =       20000 )
       PARAMETER ( MAXINDE = MAXAUTO+MAXIND )
       PARAMETER ( MAXNDR  =         200 )
       PARAMETER ( NDDIM   =          89 )
@@ -69,10 +69,6 @@
       CHARACTER*2 SYMBOL(MAXATOM)
       CHARACTER   KARTE*80, ACTPAR*10, CSTRING*8
 
-C*** untested!! Changes of DATOM, see PoWR-Memo 20230802.txt
-      CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
-      INTEGER N_WITH_DRLEVELS
-
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
 C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
       INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
@@ -121,13 +117,13 @@
      $                  SIGMATHK,SEXPOK,EDGEK,NFIRST,
      $                  NLAST,NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $                  IONAUTO,KRUDAUT,KONTNUP,KONTLOW,LASTKON,MAXKONT,
-     $                  IONGRND, KEYCBF,
+     $                  IONGRND,KODRNUP,KODRLOW,LASTKDR,MAXKODR,KEYCBF,
 C***  IRON: ADDITIONAL PARAMETERS FOR IRON-GROUP LINE BLANKETING
      >                  'STEAL   ', INDEXMAX, NFEREADMAX, MAXFEIND,
      >                  LASTFE, SIGMAFE, INDRB, INDRF,
      >                  IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY, 
-     >                  VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL,
-     >         LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >                  VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL)
+ 
 
       CALL PLOTANF (42, '', 'Collision strength #W#&Tup-low&M',
      >              '\CENTER\log T / K', 
diff -bur ./plotdep.f ../../powr-refactor/src/plotdep.f
--- ./plotdep.f	2024-07-28 13:13:58.000000000 +0200
+++ ../../powr-refactor/src/plotdep.f	2024-07-22 09:27:16.104033925 +0200
@@ -11,7 +11,15 @@
       REAL, DIMENSION(NDMAX) :: X, Y
       REAL, DIMENSION(ND) :: ENTOT
       REAL, DIMENSION(ND,N) :: DEPART, POPNUM, POPLTE
-      CHARACTER HEADER*100,MODHEAD*100,LEVEL(N)*10,CENTER*8
+C*** ISU
+C array boundaries are exceeded below, so I am extending the
+C array size
+C     CHARACTER HEADER*60,MODHEAD*100,LEVEL(N)*10,CENTER*8
+      CHARACTER HEADER*70,MODHEAD*100,LEVEL(N)*10,CENTER*8
+C*** ISU
+C array boundaries are exceeded below, so I am extending the
+C array size
+C     CHARACTER(5) :: MORE
       CHARACTER(50) :: MORE
       CHARACTER*10 LEVELPLDEP(MAXSETS,N), ACTLEV
       INTEGER, DIMENSION(MAXSETS) :: LI, ISYMBOL
diff -bur ./plotflu.f ../../powr-refactor/src/plotflu.f
--- ./plotflu.f	2024-07-28 13:13:58.000000000 +0200
+++ ../../powr-refactor/src/plotflu.f	2024-02-06 08:35:56.972155714 +0100
@@ -20,7 +20,7 @@
 
       REAL, PARAMETER :: PARSEC = 3.08561E18    !1 PARSEC IN CM
 
-      IF (TOTOUT .EQ. -999. ) THEN
+      IF (TOTOUT == 6HUNDEF. ) THEN
          PRINT 7
     7    FORMAT (//'WARNING: OPTION "PLOT FLUX" IGNORED - ',
      >           'EMERGENT CONT. FLUX NOT YET CALCULATED ',//)
diff -bur ./plotgamma.f ../../powr-refactor/src/plotgamma.f
--- ./plotgamma.f	2024-07-28 13:13:59.000000000 +0200
+++ ../../powr-refactor/src/plotgamma.f	2024-02-06 09:58:14.155414656 +0100
@@ -3,12 +3,13 @@
      >                     ATHOM, WORKRATIO, VELO, RADIUS, ND, ATMEAN,
      >                     ENTOT, RNE, RCON, T, TEFF, RSTAR, XMU, 
      >                     XMSTAR, Rcritical, bFULLHYDROSTAT, 
-     >                     QIONMEAN, GAMMARADMEAN,
+     >                     QIONMEAN, GAMMARADMEAN, bNoArad,
      >                     MODHEAD, JOBNUM, hPLOT)
 C******************************************************************************
+C***  DIRECT TRANSFER OF HSUM PLOT
 C***  Plot EDDINGTON GAMMA versus DEPTH INDEX, RADIUS, VELOCITY or TAUROSS
-C***  for full radiation force, continuum contribution, and Thomson part
-C***  (created by ansander in 2014 in analogy to PLOTACC)
+C***  for full radiation, continuum, and thomson
+C***  (created by ansander in 2014 as a spin-off from PLOTACC)
 C******************************************************************************
  
       IMPLICIT NONE
@@ -25,7 +26,7 @@
       REAL, INTENT(IN) :: WORKRATIO, RCON, ATMEAN, XMSTAR, RSTAR, TEFF, 
      >                    Rcritical
      
-      LOGICAL, INTENT(IN) :: bFULLHYDROSTAT
+      LOGICAL, INTENT(IN) :: bFULLHYDROSTAT, bNoArad
 
       CHARACTER(110) :: MODHEAD, HEADLINE
       CHARACTER(8) :: CENTER, CNORM
@@ -58,6 +59,14 @@
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
 
+      IF (bNoARAD) THEN
+         WRITE (hCPR,'(A)') 'PLOTGAMMA: Radiative acceleration ' //
+     >      'not yet calculated ***'
+         WRITE (hCPR,'(3A)') 'PLOTGAMMA: ', PLOTOPT(:IDX(PLOTOPT)),
+     >      ' SKIPPED'
+         RETURN
+      ENDIF      
+
       IF (NDMAX < ND) THEN
          WRITE (hCPR,'(A)') 'PLOTACC: NON-FATAL ERROR ******'
          WRITE (hCPR,'(A)') 'PLOTACC: DIMENSION INSUFFICIENT'
diff -bur ./plothsum.f ../../powr-refactor/src/plothsum.f
--- ./plothsum.f	2024-07-28 13:13:59.000000000 +0200
+++ ../../powr-refactor/src/plothsum.f	2023-09-27 10:14:15.117755680 +0200
@@ -1,6 +1,7 @@
-      SUBROUTINE PLOTHSUM (HTOTL, HTOTM, HTOTG, HTOTOBS, HTOTCMF0,
-     >                     ND, MODHEAD, JOBNUM, KANAL, TEFF, BHTOTERR,
-     >                     FLUXEPS)
+      SUBROUTINE PLOTHSUM (HTOTL, HTOTND, EDDIHOUTJMEAN, XJTOTL, HTOTM,
+     >                     HTOTG, HTOTOBS, HTOTCMF0, HTOTCMF0ADV, 
+     >                     FLUXEPS, ND, MODHEAD, JOBNUM, KANAL, TEFF, 
+     >                     BHTOTERR, bINCADV)
 C******************************************************************************
 C***  DIRECT TRANSFER OF HSUM PLOT
 C***  TOTAL (FREQUENCY-INTEGRATED) FLUX versus DEPTH INDEX
@@ -13,32 +14,35 @@
       INTEGER, PARAMETER :: NDMAX = 200
 
       INTEGER, INTENT(IN) :: ND, KANAL, JOBNUM
-      REAL, INTENT(IN) :: TEFF, FLUXEPS
+      REAL, INTENT(IN) :: TEFF
 
       CHARACTER(100) :: MODHEAD 
       CHARACTER(110) :: HEADLINE
       CHARACTER(8) :: CENTER
 
-      REAL, DIMENSION(NDMAX) :: X, Y
-      REAL, DIMENSION(ND) :: HTOTL, HTOTM, HTOTG, HTOTOBS, HTOTCMF0
-      LOGICAL :: BHTOTERR
+      REAL, DIMENSION(NDMAX) :: X, X1, Y, YEPS
+      REAL, DIMENSION(ND) :: HTOTL, HTOTM, HTOTG, HTOTOBS, HTOTCMF0, 
+     >                       HTOTCMF0ADV, XJTOTL
+      REAL, INTENT(IN) :: HTOTND, EDDIHOUTJMEAN, FLUXEPS
+      LOGICAL :: BHTOTERR, bINCADV
 
       INTEGER :: L
-      REAL :: XMIN, XMAX, YMIN, YMAX, TRAD, HSUM
+      REAL :: XMIN, XMAX, YMIN, YMAX, TRAD, HSUM, HTOTOUT
 
 C***  STEBOL = STEFAN-BOLTZMANN CONSTANT / PI (ERG/CM**2/SEC/STERAD/KELVIN**4
-      REAL, PARAMETER :: STEBOL = 1.8046E-5
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5
+
 
       IF (BHTOTERR) THEN
          WRITE (*, '(A)')
-     >         'PLOTHTOT: WARNING: HTOTL  not present in MODEL file'
-     >         //' --  PLOT disabled!'
+     >         'PLOTHSUM: WARNING: HTOTL  not present in MODEL file'
+     >         //' --  PLOT HTOT disabled!'
          RETURN
       ENDIF 
 
 
       IF (ND .GT. NDMAX) THEN
-        WRITE (0, '(A)') 'DIMENSION INSUFFICIENT - HSUM PLOT SUPPRESSED'       
+        WRITE (0, '(A)') 'DIMENSION INSUFFICIENT - HTOT PLOT SUPPRESSED'       
         WRITE (0, '(A)') 'NON-FATAL ERROR IN SUBROUTINE PLOTHSUM'
         RETURN
       ENDIF
@@ -49,12 +53,17 @@
       HEADLINE = 'HSUM: M'//MODHEAD(13:)
       WRITE (HEADLINE(90:), '(A8,I7)') ' JOB No.', JOBNUM
 
+      WRITE (KANAL, '(A)') '*NEXTPLOT: PLOT HTOT'
+      WRITE (KANAL, '(A)') 'PLOT: ' // HEADLINE
+      WRITE (KANAL, '(A)') '\FONT=HELVET'      
+      WRITE (KANAL, '(A)') '\DEFINECOLOR 9 0.6 0.60 0.6'
+      WRITE (KANAL, '(A)') '\PEN=1'     !needed to get rid of definecolor pen bug 
 
 C***  HTOTOBS: Conversion into radiation temperatures
       DO L=1, ND-1
          X(L) = FLOAT(L)
          HSUM = HTOTOBS(L)
-         TRAD = (4. * ABS(HSUM) / STEBOL)**0.25
+         TRAD = (4. * ABS(HSUM) / STEBOLDPI)**0.25
          IF (HSUM .LT. .0) TRAD = -TRAD
          Y(L) = TRAD / 1000.
       ENDDO
@@ -84,45 +93,77 @@
 cc      ENDDO
 cc      CALL PLOTCONS (KANAL,X,Y,ND-1,'COLOR= 3') 
 
-      WRITE (KANAL,'(A)') 'PLOT: ' // HEADLINE
-      WRITE (KANAL,'(A)') '\DEFINECOLOR 8 = 0.8 0.8 0.8'      
 C***  HTOTCMF0: Conversion into radiation temperatures
-      DO L=1, ND-1
+      DO L=1, ND
+        IF (L /= ND) THEN
+          X1(L) = FLOAT(L)+0.5
          Y(L) = HTOTCMF0(L) 
-         TRAD = (4. * ABS(Y(L)) / STEBOL)**0.25
+        ELSE
+          X1(L) = FLOAT(ND)
+          Y(L) = HTOTCMF0(ND-1) 
+        ENDIF
+        TRAD = (4. * ABS(Y(L)) / STEBOLDPI)**0.25
          IF (Y(L) .LE. .0) TRAD = -TRAD
          Y(L) = TRAD / 1000.
       ENDDO      
-
+cc      CALL PLOTCONS (KANAL,X,Y,ND-1,'COLOR= 1 PEN = 3') 
       CALL PLOTANFS (KANAL,HEADLINE, '&E'//HEADLINE,
      $        CENTER//'DEPTH INDEX L',
-     $        CENTER//'T&Trad&M / kK',
-     >             0., 0., 0.,0., 0., 0.,
-     >             0., 0., 0.,0., 0., 0.,
-     $        X,Y,ND-1, 'PEN=8')
-      
-      IF (FLUXEPS .GT. 0.) THEN
-         DO L=1, ND-1
-            X(L) = FLOAT(L)
-            Y(L) = Y(L) * ((1. + FLUXEPS)**0.25)
+     $        CENTER//'T&Trad&M / KK',
+     >             0., 0., 0., 0., 0., 0.,
+     >             0., 0., 0., 0., 0., 0.,
+     $        X1,Y,ND, 'PEN=8')
+
+C***  HTOTCMF0 +- FLUXEPS in TRAD      
+      IF (FLUXEPS > 0.) THEN
+        DO L=1, ND
+          YEPS(L) = ABS(Y(L)) * (1. + FLUXEPS)**0.25
          ENDDO
-         CALL PLOTCONS (KANAL,X,Y,ND-1,'COLOR= 8 PEN = 3') 
-         DO L=1, ND-1
-            X(L) = FLOAT(L)
-            Y(L) = Y(L) *(((1. - FLUXEPS)/(1. + FLUXEPS))**0.25)
+        CALL PLOTCONS (KANAL,X1,YEPS,ND,'COLOR=9 PEN=1') 
+        DO L=1, ND
+          YEPS(L) = ABS(Y(L)) * (1. - FLUXEPS)**0.25
          ENDDO
-         CALL PLOTCONS (KANAL,X,Y,ND-1,'COLOR= 8 PEN = 3') 
+        CALL PLOTCONS (KANAL,X1,YEPS,ND,'COLOR=9 PEN=1') 
       ENDIF
 
+C***  HTOTCMF0 (ADV) in TRAD
+cc      DO L=1, ND
+cc        IF (L /= ND) THEN
+cc          X1(L) = FLOAT(L)+0.5
+cc          Y(L) = HTOTCMF0ADV(L) 
+cc        ELSE
+cc          X1(L) = FLOAT(ND)
+cc          Y(L) = HTOTCMF0ADV(ND-1) 
+cc        ENDIF
+cc        TRAD = (4. * ABS(Y(L)) / STEBOLDPI)**0.25
+cc        IF (Y(L) .LE. .0) TRAD = -TRAD
+cc        Y(L) = TRAD / 1000.
+cc      ENDDO
+
+C***  HTOTCMF0ADV in TRAD      
+cc      CALL PLOTCONS (KANAL,X1,Y,ND,'COLOR=4 PEN = 3') 
+     
 C***  HTOTL: Conversion into radiation temperatures
-      DO L=1, ND-1
-         X(L) = FLOAT(L)
-         Y(L) = HTOTL(L) 
-         TRAD = (4. * ABS(Y(L)) / STEBOL)**0.25
-         IF (Y(L) .LE. .0) TRAD = -TRAD
-         Y(L) = TRAD / 1000.
+      HTOTOUT = EDDIHOUTJMEAN * XJTOTL(1)
+c      WRITE (0,*) 'HTOTOUT = ', HTOTOUT, HTOTL(1)
+      DO L=0, ND
+        IF (L == 0) THEN
+          X(1) = FLOAT(1)
+          Y(1) = HTOTOUT
+        ELSEIF (L == ND) THEN
+          X(ND+1) = FLOAT(ND)
+          Y(ND+1) = HTOTND
+        ELSE
+          X(L+1) = 0.5 * ( FLOAT(L) + FLOAT(L+1) )
+          Y(L+1) = HTOTL(L) 
+        ENDIF
+        TRAD = (4. * ABS(Y(L+1)) / STEBOLDPI)**0.25
+        IF (Y(L+1) .LE. .0) TRAD = -TRAD
+        Y(L+1) = TRAD / 1000.
       ENDDO
-      CALL PLOTCONS (KANAL,X,Y,ND-1,'COLOR= 2 PEN = 3') 
+            
+C***  HTOTL in TRAD      
+      CALL PLOTCONS (KANAL,X,Y,ND+1,'COLOR= 2 PEN = 3') 
 
 C***  Continuum
       X(1) = 1.
diff -bur ./plotopa.f ../../powr-refactor/src/plotopa.f
--- ./plotopa.f	2024-07-28 13:14:00.000000000 +0200
+++ ../../powr-refactor/src/plotopa.f	2023-09-27 10:14:15.117755680 +0200
@@ -6,7 +6,7 @@
      $           LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
      $           SIGMATHK,SEXPOK,EDGEK,
      $           K,NF,SIGMAKI,RADIUS,
-     $           KONTNUP,KONTLOW,LASTKON,XDATA)
+     $           KONTNUP,KONTLOW,LASTKON,XDATA,POPMIN)
 C***********************************************************************
 C***  PLOT of opacity over radius at given wavelength
 C***  CALLED FROM: COMO
@@ -17,7 +17,8 @@
       DIMENSION OPA(ND), RADIUS(ND), FILLFAC(ND), ENTOT(ND)
       DIMENSION ABXYZ(MAXATOM), ATMASS(MAXATOM)
       CHARACTER MODHEAD*100, YTEXT*60
-      CHARACTER OPTIONPLOTOPA(NPLOTOPA)*(80), XLAMSTR*20, ACTPAR*20
+      CHARACTER XLAMSTR*20, ACTPAR*20
+      CHARACTER(80), DIMENSION(NPLOTOPA) :: OPTIONPLOTOPA
       LOGICAL BPERMASS
 C***  Atomic Mass Unit
       DATA AMU /1.66E-24/
@@ -55,7 +56,7 @@
         CYCLE
   100   CONTINUE  
 
-      CALL COOP (XLAM, ND,T,RNE,POPNUM,ENTOT,RSTAR,
+      CALL COOP (XLAM, ND,T,RNE,POPNUM,POPMIN,ENTOT,RSTAR,
      $           OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,
      $           NOM,KODAT,NDIM,N,MAXATOM,
      $           LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
diff -bur ./plot_secondmodel_grid.f ../../powr-refactor/src/plot_secondmodel_grid.f
--- ./plot_secondmodel_grid.f	2024-07-28 13:13:55.000000000 +0200
+++ ../../powr-refactor/src/plot_secondmodel_grid.f	2023-09-27 10:14:15.113755615 +0200
@@ -8,13 +8,12 @@
       DIMENSION PHIARR(NPHIMAX,NPDIM)
       PARAMETER ( MAXPLOT = 1000 )
       DIMENSION XPLOT(MAXPLOT), YPLOT(MAXPLOT)
-      DIMENSION ZINTER (4, NPDIM, NPHIMAX)
+      DIMENSION ZINTER (2,NPDIM, NPHIMAX)
 
       WRITE (66,*) 'PLOT: Grid for second-model geometry'
       WRITE (66,*) '\NOBOX'
       WRITE (66,*) '\OFS 4 2'
-cc      IF (2*NP .GT. 99) WRITE (66,'(A,I4)') '\SET_NSETMAX ',  2*NP+1  
-      IF (4*NP .GT. 99) WRITE (66,'(A,I4)') '\SET_NSETMAX ',  4*NP+1  
+      IF (2*NP .GT. 99) WRITE (66,'(A,I4)') '\SET_NSETMAX ',  2*NP+1  
     
       SCALE = 9./ P(JPLAST)
       DO JP=1, JPLAST
@@ -42,7 +41,6 @@
          LPHIEND = MAX(LPHIEND, LPHISTA)
 
 C***     Red dots: intersecting with SECONDMODEL domain
-C***         in the first interval          
          NCOUNT = 0
          DO LPHI= LPHISTA, LPHIEND
             IF (ZINTER(1,JP,LPHI) .NE. ZINTER(2,JP,LPHI)) THEN
@@ -54,24 +52,10 @@
          IF (NCOUNT .GT. 0) CALL PLOTCONS (66, XPLOT, YPLOT,
      >            NCOUNT, 'SYMBOL=8 SIZE=-0.1 COLOR=2')
 
-C***     Black crosses: intersecting with SECONDMODEL domain
-C***         in the second interval          
-         NCOUNT = 0
-         DO LPHI= LPHISTA, LPHIEND
-            IF (ZINTER(3,JP,LPHI) .NE. ZINTER(4,JP,LPHI)) THEN
-               NCOUNT = NCOUNT + 1 
-               XPLOT(NCOUNT) = P(JP) * COS(PHIARR(LPHI,JP))
-               YPLOT(NCOUNT) = P(JP) * SIN(PHIARR(LPHI,JP))
-            ENDIF
-         ENDDO
-         IF (NCOUNT .GT. 0) CALL PLOTCONS (66, XPLOT, YPLOT,
-     >            NCOUNT, 'SYMBOL=1 SIZE=0.1 PEN=2')
-
 C***     Blue dots: not intersecting with SECONDMODEL domain
          NCOUNT = 0
          DO LPHI= LPHISTA, LPHIEND
-            IF ((ZINTER(2,JP,LPHI) .EQ. ZINTER(1,JP,LPHI)) .AND.
-     >          (ZINTER(3,JP,LPHI) .EQ. ZINTER(4,JP,LPHI))) THEN
+            IF (ZINTER(1,JP,LPHI) .EQ. ZINTER(2,JP,LPHI)) THEN
               NCOUNT = NCOUNT + 1
               XPLOT(NCOUNT) = P(JP) * COS(PHIARR(LPHI,JP))
               YPLOT(NCOUNT) = P(JP) * SIN(PHIARR(LPHI,JP))
diff -bur ./plotsigmafe.f ../../powr-refactor/src/plotsigmafe.f
--- ./plotsigmafe.f	2024-07-28 13:14:01.000000000 +0200
+++ ../../powr-refactor/src/plotsigmafe.f	2023-09-27 10:14:15.117755680 +0200
@@ -1,48 +1,70 @@
       SUBROUTINE PLOTSIGMAFE(PLOTOPT, MODHEAD, JOBNUM,
-     >                       SIGMAFE, INDRB, MAXFEIND, 
-     >                       LASTIND, LASTFE, IFRBSTA, IFRBEND, 
-     >                       LEVEL, N, INDNUP, INDLOW,
-     >                       INDEXMAX, NFEREADMAX,
-     >                       VDOPFE, DXFE, XLAM0FE, bOwn)
+     >                       SIGMAFE, SIGMAFEUL, SIGNU3FE, 
+     >                       INDRB, MAXFEIND, 
+     >                       LASTINDALL, LASTFE, IFRBSTA, IFRBEND, 
+     >                       LASTKON, INDRF, KONTLOW, KONTNUP,
+     >                       LEVEL, N, INDNUP, INDLOW, NOM,
+     >                       ELEVEL, EION,
+     >                       INDEXMAX, NFEREADMAX, MAXATOM, KODAT,
+     >                       VDOPFE, DXFE, XLAM0FE, bFEULSEP, bOwn)
+C***  TODO: Update routine to plot also bound-free sections
       
       IMPLICIT NONE
       
-      INTEGER, INTENT(IN) :: MAXFEIND, INDEXMAX, NFEREADMAX,
-     >                       LASTIND, LASTFE, N, JOBNUM
+      INTEGER, INTENT(IN) :: MAXFEIND, INDEXMAX, NFEREADMAX, MAXATOM,
+     >                       LASTINDALL, LASTFE, LASTKON, N, JOBNUM
       REAL, INTENT(IN) :: XLAM0FE, DXFE, VDOPFE
-      INTEGER, DIMENSION(LASTIND), INTENT(IN) :: INDNUP, INDLOW
-      REAL, DIMENSION(INDEXMAX), INTENT(IN) :: SIGMAFE
+      INTEGER, DIMENSION(LASTINDALL), INTENT(IN) :: INDNUP, INDLOW
+      INTEGER, DIMENSION(LASTKON), INTENT(IN) :: KONTNUP, KONTLOW
+      REAL, DIMENSION(INDEXMAX), INTENT(IN) :: SIGMAFE, SIGMAFEUL, 
+     >                                         SIGNU3FE
+      REAL, DIMENSION(N) :: ELEVEL, EION
+      INTEGER, DIMENSION(N), INTENT(IN) :: NOM
+      INTEGER, DIMENSION(MAXATOM), INTENT(IN) :: KODAT
       CHARACTER(10), DIMENSION(N) :: LEVEL
       CHARACTER PLOTOPT*(*)
       
-      INTEGER, DIMENSION(MAXFEIND) :: INDRB, IFRBEND, IFRBSTA
+      INTEGER, DIMENSION(MAXFEIND) :: INDRB, IFRBEND, IFRBSTA, INDRF
       
-      REAL, DIMENSION(NFEREADMAX) :: X, Y
+      INTEGER, PARAMETER :: LAMDIMMAX =  500000         !should have the size of NFEREADMAX
+      REAL, DIMENSION(LAMDIMMAX) :: X, Y, Y2
 
       CHARACTER(5) :: CIFE, CIND
       CHARACTER(10) :: LEV1, LEV2
       CHARACTER(100) :: MODHEAD
       CHARACTER(110) :: HEADLINE
       
-      REAL :: XLOGSTEP
-      INTEGER :: NPTS, IndexFE, IndexFELAM, I, ILAM, IND,
-     >           hPLOT, ILEV1, ILEV2, IERR, NPAR, LOW, NUP
+      REAL :: XLOGSTEP, XLAMEDGE, EDGE, XLAMNULL
+      INTEGER :: NPTS, IndexFE, IndexFELAM, I, J, ILAM, IND, KON,
+     >           hPLOT, ILEV1, ILEV2, IERR, NPAR, LOW, NUP, 
+     >           ILAMSTART, ILAMEND, IndexSIGMAINT, IndexFELAMstart
       
-      LOGICAL :: bOwn
+      LOGICAL :: bOwn, bFEULSEP
       
       INTEGER, EXTERNAL :: IDX
 
       !Physical constants
-      REAL, PARAMETER :: CLIGHT = 2.9979E10     !Speed of Light in cm/s
+      REAL, PARAMETER :: CLIGHT = 2.99792458E10     !Speed of Light in cm/s
 
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
       
+      IF (LAMDIMMAX < NFEREADMAX) THEN
+        WRITE (hCPR,*) '**** PLOTSIGMAFE: LAMDIMMAX too small '
+     >    // '--> code might crash'
+      ENDIF
 
+      WRITE (0,*) 'PLOTSIGMAFE called'
 C***  DECODE LEVELS (can be index number or name)      
       ILEV1 = 0
       ILEV2 = 0
+      
+C***  Debug output: list of levels      
+c      DO I=1, N
+c        WRITE (0,*) 'LEVEL: ', I, LEVEL(I)
+c      ENDDO
+      
       CALL SARGC (PLOTOPT, NPAR)
       IF (NPAR == 4) THEN
         CALL SARGV (PLOTOPT, 3, LEV1)
@@ -83,8 +105,9 @@
         RETURN
       ENDIF
       
+C***  TODO: Update for SIGMAFEUL, SIGNU3FE case      
       IND = 0
-      DO I=1, LASTIND
+      DO I=1, LASTINDALL
         IF (INDNUP(I) == ILEV1 .AND. INDLOW(I) == ILEV2) THEN
           LOW = ILEV2
           NUP = ILEV1
@@ -98,8 +121,41 @@
         ENDIF
       ENDDO
       
+      IF (IND == 0) THEN
+        KON = 0
+        DO I=1, LASTKON
+          IF (KONTNUP(I) == ILEV1 .AND. KONTLOW(I) == ILEV2) THEN
+            LOW = ILEV2
+            NUP = ILEV1
+            KON = I
+            EXIT
+          ELSEIF (KONTNUP(I) == ILEV2 .AND. KONTLOW(I) == ILEV1) THEN
+            LOW = ILEV1
+            NUP = ILEV2
+            KON = I
+            EXIT
+          ENDIF
+        ENDDO
+        IF (KON == 0) THEN
+          WRITE (hCPR,*) 'PLOTSIGMAFE: Invalid transition ************'
+          WRITE (hCPR,*) '***** The following plot was aborted:'
+          WRITE (hCPR,*) PLOTOPT(:IDX(PLOTOPT))        
+          RETURN
+        ELSEIF (NOM(LOW) /= KODAT(26)) THEN
+          WRITE (hCPR,*) 'PLOTSIGMAFE: Non-iron transition ************'
+          WRITE (hCPR,*) '***** The following plot was aborted:'
+          WRITE (hCPR,*) PLOTOPT(:IDX(PLOTOPT))        
+          RETURN
+        ELSE
+          EDGE=ELEVEL(NUP)+EION(LOW)-ELEVEL(LOW)
+          XLAMEDGE = 1.E8/EDGE
+          WRITE (hCPR,*) 'Transition found: ', KON, XLAMEDGE
+        ENDIF        
+      ENDIF
+                  
+      
 C***  Check if transition is found and really an iron bound-bound transition
-      IF (IND < (LASTIND - LASTFE)) THEN
+      IF (IND < (LASTINDALL - LASTFE) .AND. KON == 0) THEN
         WRITE (hCPR,*) 'PLOTSIGMAFE: Invalid transition ************'
         WRITE (hCPR,*) '***** The following plot was aborted:'
         WRITE (hCPR,*) PLOTOPT(:IDX(PLOTOPT))        
@@ -129,16 +185,46 @@
       WRITE (hPLOT,'(A)') '\PEN=1'
       
       XLOGSTEP = LOG10(1. + VDOPFE*1.E5*DXFE/CLIGHT)
-      IndexFE = IND - (LASTIND - LASTFE)        !convert total IND to fe-only IND number
+      IF (IND > 0) THEN
+        IndexFE = IND - (LASTINDALL - LASTFE)     !convert total IND to fe-only IND number
       IndexFELAM = INDRB(IndexFE)               !starting index inside SIGMAFE for current FeIND
+        ILAMSTART = IFRBSTA(IndexFE)              !starting wavelength index
+        ILAMEND   = IFRBEND(IndexFE)              !last wavelength index
+        XLAMNULL = XLAM0FE
+      ELSE
+C***    Bound-free transitions are always created on a fixed grid 
+C        with VDOP = 30 and FSTEP = 30
+C        ( check ~wrh/Blanket/Data/Fgrids/coarsek_grid )
+        IndexFE = KON
+        IndexFELAM = INDRF(IndexFE) + 2
+        ILAMSTART = - INT(SIGMAFE(IndexFELAM - 2))
+        ILAMEND   = - INT(SIGMAFE(IndexFELAM - 1))
+        WRITE (hCPR,'(A,4(2X,I8))') 'Indices found: ', 
+     >              IndexFE, IndexFELAM, ILAMSTART, ILAMEND
+        XLOGSTEP = LOG10(1. + 30*1.E5*30/CLIGHT)
+        XLAMNULL = 1001.0993601
+      ENDIF
+      IndexFELAMstart = IndexFELAM
       DO 
-        I = IndexFELAM - INDRB(IndexFE) + 1
-        ILAM = IFRBSTA(IndexFE) + I - 1
+        I = IndexFELAM - IndexFELAMstart + 1
+        ILAM = ILAMSTART + I - 1
 C        WRITE (hCPR, *) I, ILAM, XLAM0FE * 10.**(ILAM*XLOGSTEP)
-        X(I) = XLAM0FE * 10.**(ILAM*XLOGSTEP)       !lambda from index
+        X(I) = XLAMNULL * 10.**(ILAM*XLOGSTEP)       !lambda from index
         Y(I) = SIGMAFE(IndexFELAM) / 1.E-15          !plot in 10^(-15) cm^2
+        IF (KON > 0) THEN
+          IF (X(I) > XLAMEDGE) THEN
+            Y2(I) = 0.
+          ELSE
+            Y2(I) = (X(I)/XLAMEDGE)**3
+          ENDIF
+        ENDIF
 C        Y(I) = SIGMAFE(IndexFELAM)
-        IF (ILAM == IFRBEND(IndexFE)) EXIT
+        IF (ILAM == ILAMEND) THEN
+          IF (KON > 0) THEN
+            IndexSIGMAINT = IndexFELAM + 1
+          ENDIF
+          EXIT
+        ENDIF
         IndexFELAM = IndexFELAM + 1
       ENDDO
       NPTS = I      
@@ -160,6 +246,14 @@
      >        .0, .0, .0, .0, .0, .0,
      >        X, Y, NPTS, 'COLOR=4')
      
+       IF (KON > 0) THEN
+C***     Plot hydrogenic slope for comparison
+         DO J=1, NPTS
+           Y2(J) = Y2(J) * SIGMAFE(IndexSIGMAINT) / 1.E-15
+         ENDDO
+         CALL PLOTCONS (hPLOT, X, Y2, NPTS, 'COLOR=1')
+       ENDIF
+     
 C      CALL PLOTCONS (hPLOT, X, TCORR,  ND,   'PEN=4 COLOR=2')
 
 C      IF (bOwn) THEN
diff -bur ./plott.f ../../powr-refactor/src/plott.f
--- ./plott.f	2024-07-28 13:14:02.000000000 +0200
+++ ../../powr-refactor/src/plott.f	2023-09-27 10:14:15.117755680 +0200
@@ -1,10 +1,10 @@
-      SUBROUTINE PLOTT (TPLOTOPT,ND,R,TAUROSS,T,MODHEAD,JOBNUM,KANAL,
-     >                  BINBOX,UNLUTECLINE)
-C******************************************************************************
+      SUBROUTINE PLOTT (TPLOTOPT,ND,R,TAUROSS,T,ENTOT,
+     >                  MODHEAD,JOBNUM,KANAL,BINBOX,UNLUTECLINE)
+C***********************************************************************
 C***  DIRECT TRANSFER OF THE TEMPERATURE STRATIFICATION
 C***  DEFAULT: T(R) VERSUS LOG(R/R*-1)
 C***  TPLTAU=.TRUE.: T(R) VERSUS LOG(TAUROSS)
-C******************************************************************************
+C***********************************************************************
  
       IMPLICIT NONE
 
@@ -12,12 +12,12 @@
       INTEGER, INTENT(IN) :: ND, JOBNUM, KANAL
 
       REAL, DIMENSION(NDMAX) :: X, Y
-      REAL, DIMENSION(ND) :: R, TAUROSS, T
-      LOGICAL :: TPLTAU, BINBOX, BCOMPARTIBLE
+      REAL, DIMENSION(ND) :: R, TAUROSS, T, ENTOT
+      LOGICAL :: TPLTAU, TPLENTOT, BINBOX, BCOMPARTIBLE
       CHARACTER(70) :: HEAD1, HEAD2
       CHARACTER(100) :: MODHEAD
       CHARACTER(8) :: CENTER, BUFFER8
-      CHARACTER(40) :: CUROPT, NEXTOPT
+      CHARACTER(40) :: CUROPT, NEXTOPT, XLABEL
       CHARACTER(*) :: UNLUTECLINE
       CHARACTER(256) :: TPLOTOPT
       INTEGER, PARAMETER :: NPARMAX = 40
@@ -36,6 +36,7 @@
       YMAX = 0.
       ACTPAR = '0.0'
       TPLTAU = .FALSE.
+      TPLENTOT = .FALSE.
       BCOMPARTIBLE = .FALSE.    !if true, the old CARDS format is also interpreted
 
 C***  READ CARDS LINE
@@ -106,6 +107,8 @@
               ENDIF
             CASE ('TAU', 'TAUR')
               TPLTAU = .TRUE.
+            CASE ('ENTOT')
+              TPLENTOT = .TRUE.
           ENDSELECT
         ENDDO
       ENDIF
@@ -193,6 +196,11 @@
           X(L)=LOG10(TAUROSS(LMIN-1+L))
           Y(L)=T(LMIN-1+L)/1.E3
         ENDDO
+      ELSEIF (TPLENTOT) THEN
+        DO L=1, NDL
+          X(L)=LOG10(ENTOT(LMIN-1+L))
+          Y(L)=T(LMIN-1+L)/1.E3
+        ENDDO
       ELSE
         DO L=1, NDL
           X(L)=LOG10(R(LMAX+1-L)-1.)
@@ -226,6 +234,9 @@
       IF (TPLTAU) THEN
          HEAD1=' WR TEMPERATURE STRATIFICATION T(R) VERSUS LOG(TAUROSS)'
          HEAD2(30:65)=' TEMPERATURE STRATIFICATION T(TAU-R)'
+      ELSEIF (TPLENTOT) THEN
+         HEAD1=' WR TEMPERATURE STRATIFICATION T(R) VS LOG(n&Ttot&M)'
+         HEAD2(30:68)=' TEMPERATURE STRATIFICATION T(n&Ttot&M)'
       ELSE
          HEAD1=' WR TEMPERATURE STRATIFICATION T(R) VERSUS LOG(R/R*-1)'
          HEAD2(30:61)=' TEMPERATURE STRATIFICATION T(R)'
@@ -281,11 +292,11 @@
 
       IF (TPLTAU) THEN
         WRITE (KANAL, '(A)') 'KASDEF COLOR=2'
-        WRITE (KANAL, '(A,F9.3,A)')
+        WRITE (KANAL, '(A,G15.7,A)')
      >    'KASDEF SYM XMAX ', T(ND)/1000., ' 0. 0. 0.3 8'
         IF (R(1) > RMAX) THEN
           !draw outer circle only if outside of plot
-          WRITE (KANAL, '(A,F9.3,A)')
+          WRITE (KANAL, '(A,G15.7,A)')
      >      'KASDEF SYM XMIN ', T(1)/1000., ' 0. 0. 0.3 8'
         ENDIF
         WRITE (KANAL, '(A)') 'KASDEF COLOR=1'
@@ -298,18 +309,23 @@
       ELSE
 C***  MARKIERUNG DER TIEFENPUNKTE 10, 20, 30, USW. 
         WRITE (KANAL, '(A)') 'KASDEF COLOR=2'
-        WRITE (KANAL, '(A,F9.3,A)')
+        WRITE (KANAL, '(A,G15.7,A)')
      >    'KASDEF SYM XMIN ', T(ND)/1000., ' 0. 0. 0.3 8'
         IF (R(1) > RMAX) THEN
           !draw outer circle only if outside of plot
-          WRITE (KANAL, '(A,F9.3,A)')
+          WRITE (KANAL, '(A,G15.7,A)')
      >      'KASDEF SYM XMAX ', T(1)/1000., ' 0. 0. 0.3 8'
         ENDIF
         WRITE (KANAL, '(A)') 'KASDEF COLOR=1'
 C***        
+        IF (TPLENTOT) THEN
+          XLABEL = 'log (n&Ttot&M)'
+        ELSE
+          XLABEL = 'log (R/R&T*&M - 1)'
+        ENDIF
 
          CALL PLOTANF (KANAL,HEAD1,HEAD2
-     $        ,CENTER//'log (R/R&T*&M - 1)'
+     $        ,CENTER// XLABEL
      $        ,CENTER//'T / kK'
      $        ,XSCALE,XMIN,XMAX,XTICK,XABST,.0
      $        ,YSCALE,YMIN,YMAX,YTICK,YABST,.0
diff -bur ./plotunlu.f ../../powr-refactor/src/plotunlu.f
--- ./plotunlu.f	2024-07-28 13:14:02.000000000 +0200
+++ ../../powr-refactor/src/plotunlu.f	2023-09-27 10:14:15.117755680 +0200
@@ -1,14 +1,16 @@
       SUBROUTINE PLOTUNLU (KANAL, PLOTOPT, MODHEAD, JOBNUM, 
-     >                    ND, T, TNEW, DUNLU_LOC, DUNLU_TB, bTDIFFUS,
-     >                    DTLOCAL, DTINT, DTRMAX, DTKUBAT)
-C*****************************************************************
+     >                    ND, T, TNEW, bKUBAT, bLOCAL, 
+     >                    bINT, bRMAX, bTDIFFUS, DTLOCAL, DTINT,
+     >                    DTRMAX, DTKUBAT, EXPTAUTCL)
+C***********************************************************************
 C***  PLOT of temperature corrections from UNSOELD-LUCY procedure
-C*****************************************************************
+C***********************************************************************
 
       IMPLICIT NONE
 
       INTEGER, PARAMETER :: NDMAX = 200
       INTEGER, INTENT(IN) :: ND, KANAL, JOBNUM
+      REAL, INTENT(IN) :: EXPTAUTCL
 
       CHARACTER PLOTOPT*(*)
       CHARACTER(100) :: MODHEAD
@@ -17,16 +19,21 @@
       CHARACTER(8) :: CENTER
 
       REAL, DIMENSION(NDMAX) :: X, TCORR
-      REAL, DIMENSION(ND) :: DTLOCAL, DTINT, DTRMAX, DTKUBAT, T, TNEW
+      REAL, DIMENSION(ND) :: DTLOCAL, DTINT, DTRMAX, DTKUBAT,
+     >                       T, TNEW
 
       INTEGER :: L, I, NPAR, NDin
-      REAL :: XLABOFF, DUNLU_LOC, DUNLU_TB
+      REAL :: XLABOFF
       
-      LOGICAL :: bTDIFFUS, bPlotKUBAT, bPlotLOCAL
+      LOGICAL :: bKUBAT, bLOCAL, bUNLU, bINT, bRMAX,
+     >           bPlotKUBAT, bPlotLOCAL, bPlotINT, 
+     >           bPlotRMAX, bTDIFFUS
 
 C***  STEBOL = STEFAN-BOLTZMANN CONSTANT / PI (ERG/CM**2/SEC/STERAD/KELVIN**4
       REAL, PARAMETER :: STEBOL = 1.8046E-5
 
+      bUNLU = .TRUE.
+      
       IF (ND > NDMAX) THEN
         WRITE (0, '(A)') 'DIMENSION INSUFFICIENT - UNLU-PLOT SUPPRESSED'
         WRITE (0, '(A)') 'NON-FATAL ERROR IN SUBROUTINE PLOTUNLU'
@@ -34,8 +41,10 @@
       ENDIF
 
 C***  Decode possible options
-      bPlotKUBAT = DUNLU_TB  .GT. .0
-      bPlotLOCAL = DUNLU_LOC .GT. .0
+      bPlotKUBAT = bKUBAT
+      bPlotLOCAL = bLOCAL
+      bPlotINT = bINT
+      bPlotRMAX = bRMAX
       CALL SARGC (PLOTOPT, NPAR)
       IF (NPAR > 2) THEN
         parloop: DO I=3, NPAR
@@ -43,11 +52,17 @@
           SELECTCASE(CUROPT)
             CASE ('LOCAL', 'TE')
               bPlotLOCAL = .TRUE.
+            CASE ('INT', 'STROM', 'FLUXCON')
+              bPlotINT = .TRUE.
+            CASE ('RMAX', 'OUT')
+              bPlotRMAX = .TRUE.
             CASE ('TBALANCE', 'TB', 'KUBAT')
               bPlotKUBAT = .TRUE.
             CASE ('ALLTERMS', 'ALL')
               bPlotKUBAT = .TRUE.
               bPlotLOCAL = .TRUE.
+              bPLotINT = .TRUE.
+              bPlotRMAX = .TRUE.
           ENDSELECT
         ENDDO parloop
       ENDIF
@@ -72,7 +87,16 @@
       WRITE (KANAL, '(A)') 
      >         'KASDEF LINUN XMIN 0. XMAX 0.  0. 0.'
 
-        IF (bPlotKUBAT .AND. bPlotLOCAL) THEN
+C***  PLOT EXPTAU value from TEMPCORR if used
+      IF (EXPTAUTCL > 0.) THEN
+         WRITE (KANAL,'(A)') '\COLOR=2'
+         WRITE (KANAL,'(A,F8.4,A)')           
+     >     '\SYM ', EXPTAUTCL, ' YMAX 0. 0. 1. 11 CFILL=2'
+      ENDIF
+
+      IF (bUNLU) THEN
+        !Unsoeld-Lucy-Terms
+        IF (bKUBAT .AND. bLOCAL) THEN
           WRITE (KANAL,'(A)') '\COLOR=4'
           WRITE (KANAL,'(A,F8.4,A)') 
      >      '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, ' 3.0'
@@ -80,14 +104,15 @@
           WRITE (KANAL,'(A,F8.4,A)') 
      >     '\LINUN 0. YMIN 2.5 YMIN  ', XLABOFF, ' 3.0'
           WRITE (KANAL,'(A,F8.4,A)') 
-     >      '\LUN   7. YMIN ', XLABOFF, ' M3.0 0.3 &1Local (&9TB&1,&4TE&1)'
-        ELSEIF (bPlotKUBAT) THEN
+     >      '\LUN   7. YMIN ', XLABOFF, 
+     >                     ' M3.0 0.3 &1Local (&9TB&1,&4TE&1)'
+        ELSEIF (bKUBAT) THEN
           WRITE (KANAL,'(A)') '\COLOR=9'
           WRITE (KANAL,'(A,F8.4,A)') 
      >      '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, ' 3.0'
           WRITE (KANAL,'(A,F8.4,A)') 
      >      '\LUN   7. YMIN ', XLABOFF, ' M3.0 0.3 Local (TB)'
-        ELSEIF (bPlotLOCAL) THEN
+        ELSEIF (bLOCAL) THEN
         WRITE (KANAL,'(A)') '\COLOR=4'
           WRITE (KANAL,'(A,F8.4,A)') 
      >      '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, ' 3.0'
@@ -97,15 +122,18 @@
         
         WRITE (KANAL,'(A)') '\COLOR=1'
         WRITE (KANAL,'(A,F8.4,A)') 
-     >    '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, ' 2.4 SYMBOL=9 SIZE=0.2'
+     >    '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, 
+     >                                ' 2.4 SYMBOL=9 SIZE=0.2'
         WRITE (KANAL,'(A,F8.4,A)') 
      >    '\LUN   7. YMIN          ', XLABOFF, ' M2.4 0.3 Int'
 
         WRITE (KANAL,'(A)') '\COLOR=1'
         WRITE (KANAL,'(A,F8.4,A)') 
-     >    '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, ' 1.8 SYMBOL=10 SIZE=0.2'
+     >    '\LINUN 0. YMIN  5. YMIN  ', XLABOFF, 
+     >                               ' 1.8 SYMBOL=10 SIZE=0.2'
         WRITE (KANAL,'(A,F8.4,A)') 
      >    '\LUN   7. YMIN          ', XLABOFF, ' M1.8 0.3 Rmax'
+      ENDIF
 
       WRITE (KANAL,'(A)') '\COLOR=2'
       WRITE (KANAL,'(A)') '\PEN=4'
@@ -135,8 +163,12 @@
       IF (bPlotKUBAT) THEN
         CALL PLOTCONS (KANAL, X, DTKUBAT, NDin, 'SYMBOL=5 COLOR=9')
       ENDIF
+      IF (bPlotINT) THEN
       CALL PLOTCONS (KANAL, X, DTINT , NDin, 'SYMBOL=9 SIZE=0.2')
+      ENDIF
+      IF (bPlotRMAX) THEN
       CALL PLOTCONS (KANAL, X, DTRMAX, NDin, 'SYMBOL=10 SIZE=0.2')
+      ENDIF 
 
       RETURN
       END
diff -bur ./popmin_nulling.f ../../powr-refactor/src/popmin_nulling.f
--- ./popmin_nulling.f	2024-07-28 13:14:03.000000000 +0200
+++ ../../powr-refactor/src/popmin_nulling.f	2023-11-21 10:10:55.293269795 +0100
@@ -1,4 +1,4 @@
-      SUBROUTINE POPMIN_NULLING (ZERO_RATES, POPNUM, ND, N)
+      SUBROUTINE POPMIN_NULLING (ZERO_RATES, POPNUM, POPMIN, ND, N)
 C***********************************************************************
 C***  Sets all POPNUMS that were flagged by ZERO_RATES to zero 
 C***  Reason: these level populations have been set to POPMIN in steal 
@@ -7,17 +7,19 @@
 C***      emissivities and opacities 
 C***  Called from: WRCONT, COMO, COLI, FORMAL  
 C***********************************************************************
+      IMPLICIT NONE
 
       INTEGER, INTENT(IN) :: ND, N
+      REAL, INTENT(IN) :: POPMIN
 
       REAL,    DIMENSION(ND, N) :: POPNUM
       LOGICAL, DIMENSION(N, ND) :: ZERO_RATES
     
-      INTEGER :: L
+      INTEGER :: L, J
 
       DO L=1, ND
         DO J=1, N
-          IF (ZERO_RATES(J,L)) THEN
+          IF (ZERO_RATES(J,L) .OR. POPNUM(L,J) < 1.1 * POPMIN) THEN
             POPNUM(L,J) = .0
           ENDIF
         ENDDO        
Only in ../../powr-refactor/src/: popsmall.f
diff -bur ./popzero.f ../../powr-refactor/src/popzero.f
--- ./popzero.f	2024-07-28 13:14:04.000000000 +0200
+++ ../../powr-refactor/src/popzero.f	2024-02-06 09:57:06.375536053 +0100
@@ -9,7 +9,7 @@
      $                   KODAT,NFIRST,NLAST,NATOUT,
      $                   NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $                   RDIEL,RAUTO,IONAUTO,IONGRND,
-     $                   INDNUP, INDLOW, LASTIND, LASTINDALL,
+     $                   INDNUP,INDLOW,LASTIND, LASTINDALL, MAXION,
      $                   KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,
      $                   LASTKDR,KEYCBF,MAXATOM,SIGMATHK,SEXPOK,EDGEK,
      $                   LASTINDAUTO, KRUDAUT, ZERO_RATES, POPMIN,
@@ -25,13 +25,15 @@
 C***  CALLED FROM: STEAL
 C*******************************************************************************
  
+      INTEGER, INTENT(IN) :: ND, LASTIND, LASTINDALL, LASTINDAUTO, 
+     >                       MAXION
       DIMENSION T(ND),ENTOT(ND),RNE(ND),POPNUM(ND,N),ITNE(ND)
       DIMENSION DEPART(ND,N)
       DIMENSION NCHARG(NDIM),EN(NDIM),ENLTE(NDIM)
-      DIMENSION ABXYZ(NATOM),KODAT(NATOM),NFIRST(NATOM),NLAST(NATOM)
+      DIMENSION ABXYZ(NATOM),KODAT(MAXATOM),NFIRST(NATOM),NLAST(NATOM)
       LOGICAL KONVER
       CHARACTER JOB*7, PRILEVRA*10
-      LOGICAL ZERO_RATES(N,ND)
+      LOGICAL, DIMENSION(N, ND) :: ZERO_RATES
       CHARACTER STRING3*3, STRING15*15, LEVEL(N)*(*)
       DIMENSION NZERORATES(NDIM), LMINZERORATES(NDIM), LMAXZERORATES(NDIM)
 
@@ -90,11 +92,11 @@
 
       CALL NLTEPOP (NDIM,N,ENLTE,TL,ENE,WEIGHT,NCHARG,EION,ELEVEL,EN,
      $             EINST,XLAMBDA,FWEIGHT,XJC,NF,L,LEVEL,XJL,ND,
-     $             CRATE,RRATE,RATCO,SIGMAKI,ALTESUM,COCO,KEYCBB,NOM,
-     $             NATOM,ABXYZ,KODAT,NFIRST,NLAST,
+     $             CRATE,RRATE,RATCO,SIGMAKI,ALTESUM,COCO,
+     $             KEYCBB,NOM,NATOM,ABXYZ,KODAT,NFIRST,NLAST,
      $             NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $             RDIEL,RAUTO,IONAUTO,IONGRND,
-     $             INDNUP, INDLOW, LASTIND, LASTINDALL,
+     $             INDNUP,INDLOW,LASTIND, LASTINDALL, MAXION,
      $             KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,LASTKDR,
      $             KEYCBF,MAXATOM,SIGMATHK,SEXPOK,EDGEK,
      >             LASTINDAUTO, KRUDAUT, ZERO_RATES, POPMIN)
@@ -142,7 +144,7 @@
               IF  (((LM1)/LSRAT)*LSRAT.EQ.(LM1).OR.L.EQ.ND)
      $        CALL PRIRAT (DUMMY  ,N,LEVEL,NDIM,L,CRATE,RRATE,RATCO,EN,
      $           IFRRA,MODHEAD,JOBNUM,NETTO,NFIRST,NLAST,NATOM,NATOUT,
-     $           NAUTO,RDIEL,RAUTO,IONGRND,KODRLOW,LASTKDR)
+     $           NAUTO,RDIEL,RAUTO,IONGRND,KODRLOW,LASTKDR,NDIM)
             ENDIF
          ENDIF
       ENDIF
diff -bur ./preform.f ../../powr-refactor/src/preform.f
--- ./preform.f	2024-07-28 13:14:04.000000000 +0200
+++ ../../powr-refactor/src/preform.f	2023-09-27 10:14:15.117755680 +0200
@@ -2,8 +2,7 @@
      $                   CLIGHT, VDOP, INDLAP, XLAMLAP, DELXLAP, ALN,
      $                   XLAM, NBLINE, MAXLAP, MAXIND, MAXATOM, 
      $                   LEVEL, WEIGHT, EINST, NDIM, POPNUM,
-     >                   T, ND, NOM, NCHARG, EION, ENTOT, RNE, 
-     >                   MAXNSUBLEVEL, MAXNSUBLINE,
+     >                   T, ND, NOM, NCHARG, EION, ENTOT, RNE, MAXSUBL,
      $                   NSUBLOW, NSUBNUP, BROAD, LINPRO,
      >                   AVOIGT, NMOD, NDDIM, MAXMOD, DENSCON, MAINQN,
      >                   MULTIIND, NMULTI, DD_VDOP, NATOM, IND_ORIGLEV)
@@ -28,7 +27,7 @@
       INTEGER, DIMENSION(NDIM) :: NOM
       DIMENSION ELEVEL(N)
       DIMENSION INDNUP(LASTIND),INDLOW(LASTIND), MULTIIND(LASTIND)
-      INTEGER, DIMENSION(MAXNSUBLINE) :: NSUBLOW, NSUBNUP
+      INTEGER, DIMENSION(MAXSUBL) :: NSUBLOW, NSUBNUP
       DIMENSION INDLAP(MAXLAP),XLAMLAP(MAXLAP),DELXLAP(MAXLAP)
       DIMENSION AVOIGT(MAXLAP,NDDIM,MAXMOD)
       DIMENSION EINST(NDIM,NDIM), IND_ORIGLEV(NDIM)
@@ -149,8 +148,7 @@
      >                 DELXLAP, NBLINE,MAXLAP,INDLOW,INDNUP,INDNEW,MAXIND,
      >                 LEVEL,WEIGHT,ELEVEL,NNEW,EINST,NDIM,
      >                 POPNUM, T, ND, ALN, VDOP,
-     >                 MAXNSUBLEVEL, MAXNSUBLINE, 
-     >                 NSUBLOW, NSUBNUP, BROAD, LINPRO, 
+     >                 MAXSUBL, NSUBLOW, NSUBNUP, BROAD, LINPRO, 
      >                 AVOIGT, NMOD, MAXMOD, NDDIM, 
      >                 MAINQN, NCHARG, EION, NOM, IND_ORIGLEV)
 
@@ -173,7 +171,7 @@
      >                 LEVEL, WEIGHT, ELEVEL, NNEW, EINST, NDIM,
      >                 POPNUM, T, ND,
      >                 ALN, VDOP, EION, ENTOT, RNE,
-     >                 MAXNSUBLEVEL, NSUBLOW, BROAD, LINPRO, 
+     >                 MAXSUBL, NSUBLOW, BROAD, LINPRO, 
      >                 AVOIGT, DENSCON, NMOD, MAXMOD, NDDIM, 
      >                 MAINQN, NCHARG, NOM, IND_ORIGLEV) 
 
@@ -189,17 +187,6 @@
 
    20 CONTINUE
 
-C***  Informative output for current range:
-c     find highest level index
-      nmax = max(maxval(indlow), maxval(indnup)) 
-      WRITE (0,'(A,I8,A,I8)') 
-     >    '*** NUMBER OF LEVELS incl. sublevels:', nmax,
-     >    '  DIMENSIONED:', MAXNSUBLEVEL
-      WRITE (0,'(A,I8,A,I8)') 
-     >    '*** NUMBER OF LINES  incl. sublines :', INDNEW, 
-     >    '  DIMENSIONED:', MAXIND
-
-
       RETURN
 
   100 WRITE (0,*) '*** UNEXPECTED E-O-F in FORMAL_CARDS ***'
diff -bur ./prep_drlines.f ../../powr-refactor/src/prep_drlines.f
--- ./prep_drlines.f	2024-07-28 13:14:05.000000000 +0200
+++ ../../powr-refactor/src/prep_drlines.f	2023-11-21 10:10:55.293269795 +0100
@@ -7,7 +7,7 @@
 C***  This depends on the CARDS line DRLINES
 C***  called from: WRSTART, COLI, STEAL
 C******************************************************************
-      CHARACTER*80 DRLINES_CARD
+      CHARACTER*120 DRLINES_CARD
       CHARACTER*4 ACTPAR
       DIMENSION KRUDAUT(NAUTO), EAUTO(NAUTO)
 
diff -bur ./prepkubat.f ../../powr-refactor/src/prepkubat.f
--- ./prepkubat.f	2024-07-28 13:14:06.000000000 +0200
+++ ../../powr-refactor/src/prepkubat.f	2023-09-27 10:14:15.117755680 +0200
@@ -9,7 +9,10 @@
      >                     LASTKON, LASTIND, LASTINDAUTO, LASTINDALL, 
      >                     OPAROSS, TOLD, RADIUS,
      >                     RSTAR, OPALAMBDAMEAN, OPASMEANTC, 
-     >                     DTKUBAT, BCOLLIDONE)
+     >                     MAXKONT, ADDCON1, ADDCON2, ADDCON3,
+     >                     IGAUNT, ALPHA, SEXPO, MAXION, 
+     >                     DTKUBAT, BCOLLIDONE, ZERO_RATES,
+     >                     bKUBATDEBUG)
 C***********************************************************************
 C***  calculates the Q values for the THERMAL BALANCE method 
 C***  cf. Kubat et al. (1999), Kubat (2001) 
@@ -21,13 +24,16 @@
       IMPLICIT NONE
                     
       INTEGER, INTENT(IN) :: ND, NF, N, NDIM, NATOM, MAXIND, MAXATOM,
-     >                       LASTKON, LASTIND, LASTINDAUTO, LASTINDALL
+     >                       MAXION, LASTKON, MAXKONT, LASTIND,
+     >                       LASTINDAUTO, LASTINDALL
       INTEGER, DIMENSION(N), INTENT(IN) :: NOM
       INTEGER, DIMENSION(NDIM), INTENT(IN) :: IONGRND, NCHARG
       INTEGER, DIMENSION(MAXIND), INTENT(IN) :: INDNUP, INDLOW
       INTEGER, DIMENSION(LASTKON), INTENT(IN) :: KONTNUP, KONTLOW,
      >                                           KEYCBF
-      INTEGER, DIMENSION(NATOM), INTENT(IN) :: NFIRST, NLAST, KODAT
+      INTEGER, DIMENSION(NATOM), INTENT(IN) :: NFIRST, NLAST
+      INTEGER, DIMENSION(MAXATOM), INTENT(IN) :: KODAT
+      CHARACTER(8), DIMENSION(MAXKONT), INTENT(IN) :: IGAUNT      
       
       REAL, INTENT(IN) :: RSTAR
       REAL, DIMENSION(NDIM,NDIM), INTENT(IN) :: EINST
@@ -44,8 +50,10 @@
       REAL, DIMENSION(NF), INTENT(IN) :: XLAMBDA, FWEIGHT
       REAL, DIMENSION(ND, NF), INTENT(IN) :: XJC
       REAL, DIMENSION(NF, LASTKON), INTENT(IN) :: SIGMAKI
-      REAL, DIMENSION(MAXATOM, MAXATOM), INTENT(IN) :: 
+      REAL, DIMENSION(MAXATOM, MAXION), INTENT(IN) :: 
      >                                        SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXKONT), INTENT(IN) :: 
+     >                ALPHA, SEXPO, ADDCON1, ADDCON2, ADDCON3
 
       CHARACTER(4), DIMENSION(LASTIND), INTENT(IN) :: KEYCBB      
       
@@ -57,8 +65,10 @@
       REAL, DIMENSION(ND) :: DELTAQ, DELTAQDT
       REAL, DIMENSION(ND, 2) :: QFF, QBF, QC, QFFDT, QBFDT, QCDT   !H is 1, C is 2
       
-      LOGICAL, DIMENSION(N,N) :: bCOLLIDONE 
-      LOGICAL :: bKSHELL
+      LOGICAL, INTENT(IN) :: bKUBATDEBUG
+      LOGICAL, DIMENSION(N, ND), INTENT(IN) :: ZERO_RATES
+      LOGICAL, DIMENSION(N,N), INTENT(INOUT) :: bCOLLIDONE 
+      LOGICAL :: bKSHELL, bPrintQTable
       
       INTEGER :: L, NUP, LOW, I, J, K, IND, KON, KONEDGE, NCHARGE, 
      >           NA, ISTATE, NOMJ
@@ -67,7 +77,7 @@
      >        AFF, W3, W, ABF, ABFINT1, ABFINT2, ABFINT2d, RL, RCML,
      >        ENE, ETRANSIT, TL, EDGELAM, EDGE, ENTOTL, DTB, OPAMEAN,
      >        DGDT, GIIITP, AFFDGDT, AFFINT1d, AFFINT2dd, POPSUM2dd,
-     >        WK, SIGMAK, TLmod
+     >        WK, SIGMAK, TLmod, POPLOW, POPNUP, POPLJ, XJCLK
      
       INTEGER, EXTERNAL :: ISRCHFGT
 
@@ -76,15 +86,19 @@
       REAL, PARAMETER :: HPLANCK = 6.625E-27     !PLANCK's CONSTANT (erg s)
       REAL, PARAMETER :: C1 = 1.4388             !C1 = H * C / K    ( CM * K )
       REAL, PARAMETER :: C2 = 3.9724E-16         !C2 = 2 * H * C    ( G * CM**3 / S**2 
-      REAL, PARAMETER :: CLIGHT = 2.9979E10      !Speed of Light in cm/s
+      REAL, PARAMETER :: CLIGHT = 2.99792458E10      !Speed of Light in cm/s
       REAL, PARAMETER :: CFF = 1.370E-23         !COEFFICIENT FOR FREE-FREE CROSS SECTION ( ALLEN PAGE 100 )
       REAL, PARAMETER :: COM = 5.465E-11         !Com = a0**2 * sqrt( 8 * Pi * k / m )
       REAL, PARAMETER :: STEBOL = 5.6705E-5         !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS)
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5   !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS) / PI      
+      REAL, PARAMETER :: BOLTZ = 1.38E-16        !BOLTZMANN CONSTANT (ERG/DEG)
       
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
 
+      bPrintQTable = bKUBATDEBUG            !print out table if debug option is set
+      
       bKSHELL = .FALSE.
       bksloop: DO NA=1, MAXATOM
         DO ISTATE=1, MAXATOM
@@ -120,39 +134,43 @@
           AFFINT2d = 0.  
           AFFINT2dd = 0.
           NCHARGE = NCHARG(J)
+          POPLJ = POPNUM(L, J)
+          IF (ZERO_RATES(J, L))  POPLJ = 0.
           DO K=1, NF-1
             W = 1.E8/XLAMBDA(K)
             W3 = W*W*W         
+            XJCLK = MAX(0., XJC(L,K))
             IF (NCHARGE > 0) THEN
               CALL GAUNTFF (GIII,NCHARGE,XLAMBDA(K),TL)
               CALL GAUNTFF (GIIITP,NCHARGE,XLAMBDA(K),1.01*TL)
               DGDT = (GIIITP - GIII) / (0.01 * TL)              
-              AFF = CFF/W3/SQRT(TOLD(L)) * NCHARGE**(2.) * GIII   !AlphaFF for Kubat method
-              AFFDGDT = CFF/W3/SQRT(TOLD(L)) * NCHARGE**(2.) * DGDT
+              AFF = CFF/W3/SQRT(TL) * NCHARGE**(2.) * GIII   !AlphaFF for Kubat method
+              AFFDGDT = CFF/W3/SQRT(TL) * NCHARGE**(2.) * DGDT
             ELSE
               GIIITP = 0.
               GIII = 0.
               AFF = 0.
               AFFDGDT = 0.
             ENDIF
-            AFFINT1 = AFFINT1 + FWEIGHT(K) * AFF * XJC(L, K)
-            AFFINT1d = AFFINT1d + FWEIGHT(K) * AFFDGDT * XJC(L, K)
+            AFFINT1 = AFFINT1 + FWEIGHT(K) * AFF * XJCLK
+            AFFINT1d = AFFINT1d + FWEIGHT(K) * 
+     >                                   AFFDGDT * XJCLK
             AFFINT2 = AFFINT2 + FWEIGHT(K) * AFF
-     >        * ( XJC(L,K) + C2 * W3) * EXP(-C1*W/TL)
+     >        * ( XJCLK + C2 * W3) * EXP(-C1*W/TL)
             AFFINT2d = AFFINT2d + FWEIGHT(K) * AFF
-     >        * ( XJC(L,K) + C2 * W3) * EXP(-C1*W/TL) * W
+     >        * ( XJCLK + C2 * W3) * EXP(-C1*W/TL) * W
             AFFINT2dd = AFFINT2dd + FWEIGHT(K) * AFFDGDT
-     >        * ( XJC(L,K) + C2 * W3) * EXP(-C1*W/TL)
+     >        * ( XJCLK + C2 * W3) * EXP(-C1*W/TL)
           ENDDO
-          POPSUM1 = POPSUM1 + ENTOTL*POPNUM(L, J) * AFFINT1
-          POPSUM1d = POPSUM1d + ENTOTL*POPNUM(L, J) * AFFINT1d
-          POPSUM2 = POPSUM2 + ENTOTL*POPNUM(L, J) * AFFINT2
-          POPSUM2d = POPSUM2d + ENTOTL*POPNUM(L, J) * AFFINT2d
-          POPSUM2dd = POPSUM2dd + ENTOTL*POPNUM(L, J) * AFFINT2dd
+          POPSUM1 = POPSUM1 + ENTOTL*POPLJ * AFFINT1
+          POPSUM1d = POPSUM1d + ENTOTL*POPLJ * AFFINT1d
+          POPSUM2 = POPSUM2 + ENTOTL*POPLJ * AFFINT2
+          POPSUM2d = POPSUM2d + ENTOTL*POPLJ * AFFINT2d
+          POPSUM2dd = POPSUM2dd + ENTOTL*POPLJ * AFFINT2dd
         ENDDO
         QFF(L,1) = PI4 * ENE * POPSUM1        
         QFF(L,2) = PI4 * ENE * POPSUM2 
-        QFFDT(L,1) = - 1. / ( 2 * TL) * QFF(L,1) 
+C        QFFDT(L,1) = - 1. / ( 2 * TL) * QFF(L,1) 
         QFFDT(L,1) = - 1. / ( 2 * TL) * QFF(L,1) + PI4 * ENE * POPSUM1d
         QFFDT(L,2) = - 1. / ( 2 * TL) * QFF(L,2) 
      >               + PI4 * ENE * (C1 / TL**2 * POPSUM2d + POPSUM2dd)
@@ -163,9 +181,20 @@
 C****** BOUND-FREE transitions *****************************************
         CALL LTEPOP (N,ENLTE,TL,ENE,WEIGHT,NCHARG,EION,ELEVEL,
      >               NOM,ABXYZ,NFIRST,NLAST,NATOM)
+        CALL BFCROSS (SIGMAKI,NF,N,ELEVEL,EION,EINST,NDIM,
+     >                XLAMBDA,ALPHA,SEXPO,ADDCON1,ADDCON2,ADDCON3,
+     >                IGAUNT,KONTNUP,KONTLOW,LASTKON)
+     
         DO KON=1, LASTKON
           NUP=KONTNUP(KON)
           LOW=KONTLOW(KON)
+          POPLOW = POPNUM(L,LOW)
+          POPNUP = POPNUM(L,NUP) 
+          IF (ZERO_RATES(LOW,L)) POPLOW = 0.
+          IF (ZERO_RATES(NUP,L)) THEN
+            POPNUP = 0.
+            POPLOW = 0.
+          ENDIF
           IF (NCHARG(NUP) == NCHARG(LOW)) THEN
             STOP 'FATAL ERROR in PREPKUBAT (KON)'
           ENDIF
@@ -180,27 +209,29 @@
             W = 1.E8/XLAMBDA(K)
             W3 = W*W*W
             ABF = SIGMAKI(K, KON)
-            IF (W < EDGE .AND. ABS(ABF) > 0) THEN
+C            XJCLK = MAX(0., XJC(L,K))
+            XJCLK = XJC(L,K)
+            IF (W < EDGE .AND. ABS(ABF) > 0.) THEN
               STOP 'FATAL ERROR in PREPKUBAT: SIGMAKI should be Zero!'
             ENDIF
             
             ABFINT1 = ABFINT1 
-     >           + FWEIGHT(K) * ABF * XJC(L, K) 
+     >           + FWEIGHT(K) * ABF * XJCLK
      >               * (1. - EDGE / W)
 
             ABFINT2 = ABFINT2
      >           + FWEIGHT(K) * ABF * EXP(-C1*W/TL) *
-     >             (XJC(L,K)  + C2 * W3) *
+     >             (XJCLK  + C2 * W3) *
      >             (1. -  EDGE / W)
 
             ABFINT2d = ABFINT2d
      >           + FWEIGHT(K) * ABF * EXP(-C1*W/TL) *
-     >             (XJC(L,K)  + C2 * W3) *
+     >             (XJCLK  + C2 * W3) *
      >             (1. -  EDGE / W) * W
           ENDDO
 
-          POPSUM1 = POPSUM1 + ENTOTL*POPNUM(L,LOW) * ABFINT1
-          PADD2 = ENTOTL*POPNUM(L,NUP) 
+          POPSUM1 = POPSUM1 + ENTOTL*POPLOW * ABFINT1
+          PADD2 = ENTOTL*POPNUP
      >                     * ENLTE(LOW)/ENLTE(NUP) 
           POPSUM2 = POPSUM2 + PADD2 * ABFINT2
           POPSUM2d = POPSUM2d + C1 / (TL*TL) * PADD2 * ABFINT2d
@@ -222,19 +253,20 @@
             DO K=1, NF
               IF (XLAMBDA(K) > WK) EXIT  !Stop if radiation is too soft for K-SHELL ionization
               W = 1.E8 / XLAMBDA(K)
+              XJCLK = MAX(0., XJC(L,K))
               CALL KSIGMA (SIGMAK, SIGMATHK(NOMJ,ISTATE), 
      >                     EDGEK(NOMJ,ISTATE), W, SEXPOK(NOMJ,ISTATE))
               ABFINT1 = ABFINT1 
-     >             + FWEIGHT(K) * SIGMAK * XJC(L, K) 
+     >             + FWEIGHT(K) * SIGMAK * XJCLK
      >                 * (1. - WK / W)
 
               ABFINT2 = ABFINT2
      >             + FWEIGHT(K) * SIGMAK * EXP(-C1*W/TL) *
-     >                 (XJC(L,K)  + C2 * W3) *
+     >                 (XJCLK  + C2 * W3) *
      >                 (1. -  WK / W)
               ABFINT2d = ABFINT2d
      >           + FWEIGHT(K) * SIGMAK * EXP(-C1*W/TL) *
-     >             (XJC(L,K)  + C2 * W3) *
+     >             (XJCLK  + C2 * W3) *
      >             (1. -  WK / W) * W
             ENDDO
             POPSUM1 = POPSUM1 + ENTOTL*POPNUM(L,LOW) * ABFINT1
@@ -263,11 +295,11 @@
         CALL COLLI (NDIM,N,ENLTE,TLmod,ENE,NCHARG,ELEVEL,EINST,DCRATEDT,
      >          EION,COCO,KEYCBB,WEIGHT,ALTESUM,NATOM,NOM,KODAT,
      >          INDNUP, INDLOW, LASTIND, LASTINDAUTO, LASTINDALL, 
-     >          KONTNUP, KONTLOW, LASTKON, KEYCBF, IONGRND)
+     >          KONTNUP, KONTLOW, LASTKON, KEYCBF, IONGRND, MAXATOM)
         CALL COLLI (NDIM,N,ENLTE,TL,ENE,NCHARG,ELEVEL,EINST,CRATE,
      >          EION,COCO,KEYCBB,WEIGHT,ALTESUM,NATOM,NOM,KODAT,
      >          INDNUP, INDLOW, LASTIND, LASTINDAUTO, LASTINDALL, 
-     >          KONTNUP, KONTLOW, LASTKON, KEYCBF, IONGRND)
+     >          KONTNUP, KONTLOW, LASTKON, KEYCBF, IONGRND, MAXATOM)
         DO I=1, N
           DO J=1, N
             !calculate temperature derivative
@@ -362,6 +394,13 @@
         DO KON=1, LASTKON
             NUP=KONTNUP(KON)
             LOW=KONTLOW(KON)
+            POPLOW = POPNUM(L,LOW)
+            POPNUP = POPNUM(L,NUP) 
+            IF (ZERO_RATES(LOW,L)) POPLOW = 0.
+            IF (ZERO_RATES(NUP,L)) THEN
+              POPNUP = 0.
+              POPLOW = 0.
+            ENDIF
             IF (NCHARG(NUP) == NCHARG(LOW)) THEN
               STOP 'FATAL ERROR in PREPKUBAT (COLLI - KON)'
             ENDIF
@@ -371,23 +410,23 @@
 C            ETRANSIT = EDGE * HPLANCK
             ETRANSIT = EDGE * CLIGHT * HPLANCK
             
-            PADD1 = ENTOTL * POPNUM(L,NUP) * ETRANSIT
+            PADD1 = ENTOTL * POPNUP * ETRANSIT
             POPSUM1 = POPSUM1 + PADD1 * CRATE(NUP,LOW)
             POPSUM1d = POPSUM1d 
      >        + PADD1 * ENLTE(LOW)/ENLTE(NUP) * DCRATEDT(LOW,NUP)
      >        - PADD1 * (3./(2.*TL) + C1*EDGE/(TL*TL)) * CRATE(NUP,LOW)
             
-C            PADD1 = ENTOTL * POPNUM(L,NUP) * CRATE(NUP,LOW) * ETRANSIT
-C            PADD1 = ENTOTL * POPNUM(L,NUP) * CRATE(LOW,NUP) 
+C            PADD1 = ENTOTL * POPNUP * CRATE(NUP,LOW) * ETRANSIT
+C            PADD1 = ENTOTL * POPNUP * CRATE(LOW,NUP) 
 C     >                        * ENLTE(LOW)/ENLTE(NUP) * ETRANSIT
 C            POPSUM1 = POPSUM1 + PADD1
 C            POPSUM1d = POPSUM1d - PADD1 * (1./TL)
 
-            PADD2 = ENTOTL * POPNUM(L,LOW) * ETRANSIT
+            PADD2 = ENTOTL * POPLOW * ETRANSIT
             POPSUM2 = POPSUM2 + PADD2 * CRATE(LOW,NUP)
             POPSUM2d = POPSUM2d + PADD2 * DCRATEDT(LOW,NUP)
 
-C            PADD2 = ENTOTL * POPNUM(L,LOW) * CRATE(LOW,NUP) * ETRANSIT
+C            PADD2 = ENTOTL * POPLOW * CRATE(LOW,NUP) * ETRANSIT
 C            POPSUM2 = POPSUM2 + PADD2
 C            POPSUM2d = POPSUM2d + PADD2 * (1./(2.*TL) + C1*EDGE/(TL*TL))
 C            POPSUM2d = POPSUM2d + PADD2 * (1./TL)
@@ -428,40 +467,51 @@
         
       ENDDO
       
-      
-C      useful test output: terms and derivatives of thermal-balance       
-c      WRITE (hCPR,*)
-c      WRITE (hCPR,*) 'TESTAUSGABE ZUR KUBAT-METHODE:'
-c      WRITE (hCPR,'(5X,4(3(A10,2X),3X),A7)') 
-c     >    '   QFF_H  ', '   QFF_C  ', ' DELTA QFF', 
-c     >    '   QBF_H  ', '   QBF_C  ', ' DELTA QBF', 
-c     >    '   QC_H   ', '   QC_C   ', ' DELTA QC ', 
-c     >    '  DELTA Q ', '  DDQDT   ', '   N-R    ', 'Planck '
-c      DO L=1, ND
-c        OPAMEAN = OPASMEANTC(L) - OPALAMBDAMEAN(L)
+      IF (bPrintQTable) THEN
+        WRITE (hCPR,*)
+        WRITE (hCPR,*) 'TESTAUSGABE ZUR KUBAT-METHODE:'
+        WRITE (hCPR,'(5X,4(3(A10,2X),3X),A7)') 
+     >    '   QFF_H  ', '   QFF_C  ', ' DELTA QFF', 
+     >    '   QBF_H  ', '   QBF_C  ', ' DELTA QBF', 
+     >    '   QC_H   ', '   QC_C   ', ' DELTA QC ', 
+     >    '  DELTA Q ', '  DDQDT   ', '   N-R    ', 'Planck '
+        DO L=1, ND
+          OPAMEAN = OPASMEANTC(L)
 c        DTB = PI4 / 
 c     >       (16. * TOLD(L)**(3.) * STEBOL * OPAMEAN * 1000.)
-c        WRITE (hCPR,FMT='(I3,3(3(2X,G10.3),2X,"#"),4(2X,G10.3))') 
-c     >    L, QFF(L,1), QFF(L,2), QFF(L,1)- QFF(L,2), 
-c     >    QBF(L,1), QBF(L,2), QBF(L,1) - QBF(L,2),
-c     >    QC(L,1), QC(L,2), QC(L,1)-QC(L,2),      
-c     >    DELTAQ(L),  DELTAQDT(L), 
-c     >    - DELTAQ(L) / DELTAQDT(L) / 1000.,
-c     >    DELTAQ(L) * DTB
-c      ENDDO
-
-c      WRITE (hCPR,*) 'maxmin: ', MAXVAL(DTKUBAT), MINVAL(DTKUBAT)
-c      WRITE (hCPR,*) 'TESTAUSGABE ZUR KUBAT-METHODE (ABLEITUNGEN):'
-c      DO L=1, ND
-c        WRITE (hCPR,FMT='(I3,3(3(2X,G10.3),2X,"#"),3(2X,G10.3))') 
-c     >    L, QFFDT(L,1), QFFDT(L,2), QFFDT(L,1)- QFFDT(L,2), 
-c     >    QBFDT(L,1), QBFDT(L,2), QBFDT(L,1) - QBFDT(L,2),
-c     >    QCDT(L,1), QCDT(L,2), QCDT(L,1)-QCDT(L,2),
-c     >    QFFDT(L,1) + QBFDT(L,1) + QCDT(L,1), 
-c     >    QFFDT(L,2) + QBFDT(L,2) + QCDT(L,2),
-c     >    QFFDT(L,1) + QBFDT(L,1) + QCDT(L,1) - 
-c     >     ( QFFDT(L,2) + QBFDT(L,2) + QCDT(L,2) )
-c      ENDDO
+          IF (L > 1. .AND. L < ND) THEN
+            DTB = RSTAR * 0.5 * (RADIUS(L-1) - RADIUS(L+1)) / 
+     >         (4. * TOLD(L)**(3.) * STEBOLDPI * 1000.)
+          ELSEIF (L==ND) THEN 
+            DTB = RSTAR * 0.5 * (RADIUS(ND-1) - RADIUS(ND)) / 
+     >         (4. * TOLD(L)**(3.) * STEBOLDPI * 1000.)            
+          ELSE
+            DTB = RSTAR * 0.5 * (RADIUS(1) - RADIUS(2)) / 
+     >         (4. * TOLD(L)**(3.) * STEBOLDPI * 1000.)            
+          ENDIF
+          WRITE (hCPR,FMT='(I3,3(3(2X,G10.3),2X,"#"),4(2X,G10.3))') 
+     >      L, QFF(L,1), QFF(L,2), QFF(L,1)- QFF(L,2), 
+     >      QBF(L,1), QBF(L,2), QBF(L,1) - QBF(L,2),
+     >      QC(L,1), QC(L,2), QC(L,1)-QC(L,2),      
+     >      DELTAQ(L),  DELTAQDT(L), 
+     >      - DELTAQ(L) / DELTAQDT(L) / 1000.,
+C     >    (2./3.*(QFF(L,2)+QBF(L,2)+QC(L,2))/BOLTZ/ENE)/1000.
+     >      DELTAQ(L) * DTB
+        ENDDO
+        WRITE (hCPR,*) 'maxmin: ', MAXVAL(DTKUBAT), MINVAL(DTKUBAT)
+        WRITE (hCPR,*) 'TESTAUSGABE ZUR KUBAT-METHODE (ABLEITUNGEN):'
+        DO L=1, ND
+          WRITE (hCPR,FMT='(I3,3(3(2X,G10.3),2X,"#"),3(2X,G10.3))') 
+     >      L, QFFDT(L,1), QFFDT(L,2), QFFDT(L,1)- QFFDT(L,2), 
+     >      QBFDT(L,1), QBFDT(L,2), QBFDT(L,1) - QBFDT(L,2),
+     >      QCDT(L,1), QCDT(L,2), QCDT(L,1)-QCDT(L,2),
+     >      QFFDT(L,1) + QBFDT(L,1) + QCDT(L,1), 
+     >      QFFDT(L,2) + QBFDT(L,2) + QCDT(L,2),
+     >      QFFDT(L,1) + QBFDT(L,1) + QCDT(L,1) - 
+     >       ( QFFDT(L,2) + QBFDT(L,2) + QCDT(L,2) )
+        ENDDO
+      ENDIF
+      
 
       RETURN
       END
diff -bur ./prepray.f ../../powr-refactor/src/prepray.f
--- ./prepray.f	2024-07-28 13:14:07.000000000 +0200
+++ ../../powr-refactor/src/prepray.f	2023-09-27 10:14:15.117755680 +0200
@@ -35,7 +35,7 @@
       DIMENSION DELXLAP(NBLINE)
 
       DIMENSION VDU(NDDIM,MAXMOD), R(ND)
-      DIMENSION Z(ND),P(NP), ZINTER(4)
+      DIMENSION Z(ND),P(NP), ZINTER(2)
       REAL, DIMENSION (NDDIM,NFLDIM,MAXMOD) :: ETACK, ETACCK, OPACK
       REAL, DIMENSION(NFLDIM,MAXMOD) :: BCORE, DBDR
       DIMENSION POROLENGTH(ND), POROLENGTHRAY(NDADDIM)
@@ -75,9 +75,9 @@
 C***    Check if current point lies in second-model domain
         IMOD=1
         IF (NMOD .EQ. 2) THEN
-           IF ( (ZRAY(LL)-ZINTER(1))*(ZRAY(LL)-ZINTER(2)) .LT. .0
-     >          .OR. (ZRAY(LL)-ZINTER(3))*(ZRAY(LL)-ZINTER(4)) .LT. .0
-     >         ) IMOD=2
+           IF ( (ZRAY(LL)-ZINTER(1))*(ZRAY(LL)-ZINTER(2)) .LT. .0) THEN
+              IMOD=2
+           ENDIF
         ENDIF
 
         RRECIP = 1. / R(L)
diff -bur ./pricolr.f ../../powr-refactor/src/pricolr.f
--- ./pricolr.f	2024-07-28 13:14:10.000000000 +0200
+++ ../../powr-refactor/src/pricolr.f	2024-02-05 13:25:03.842990918 +0100
@@ -8,30 +8,24 @@
 C***  X-RAYS: EINSTEIN IPC / ROSAT PSPC (COUNT RATES)
 C***********************************************************************
 
+      PARAMETER ( MAXIPC = 20 ) 
       PARAMETER ( MAXPSPC = 30 ) 
       PARAMETER ( MAXBAND = 3 )
       DIMENSION XLAMBDA(NF),EMFLUX(NF)
-      DIMENSION CENTER (12), COLOR(12), CALCON(12)
-      CHARACTER*8 IBAND(12), IDIFF(12), ITCOL
-
-      PARAMETER ( NFIPC2 = 18 )
-      DIMENSION PHIIPC2(NFIPC2), XNUIPC2(NFIPC2), XEVIPC2(NFIPC2)
-
-      PARAMETER ( NFIPC8 = 9 )
-      DIMENSION PHIIPC8(NFIPC8), XNUIPC8(NFIPC8), XEVIPC8(NFIPC8)
-
+      DIMENSION CENTER (12), IBAND(12), COLOR(12), CALCON(12), IDIFF(12)
+      DIMENSION PHIIPC2(MAXIPC), XNUIPC2(MAXIPC), XEVIPC2(MAXIPC)
+      DIMENSION PHIIPC8(MAXIPC), XNUIPC8(MAXIPC), XEVIPC8(MAXIPC)
       DIMENSION PHIPSPC(MAXPSPC), XNUPSPC(MAXPSPC), XEVPSPC(MAXPSPC)
       DIMENSION KCNPSPC(MAXBAND+1), FCNPSPC(MAXBAND+1)
       CHARACTER STRING*10
 
 C***  DATA: MAGNITUDES AND COLOR INIDCES  ------------------------------
 C***  NAMES OF THE CONSIDERED COLOR BANDS
-      DATA IBAND /'UV1', 'UV2',
-     $            'SMITH U', 'SMITH B', 'SMITH V', 'MASSEY R',
-     $            'J WE=.02', 'H WE=.02', 'K WE=.02', 'L WE=.02', 
-     >            'M WE=.02', '(10) BSW'/ 
-c      DATA IDIFF /1H ,7HUV1-UV2,1H ,3HU-B,3HB-V,3HV-R,6*1H /
-      DATA IDIFF /'' , 'UV1-UV2' , '', 'U-B', 'B-V', 'V-R', 6*'' /
+      DATA IBAND /3HUV1,3HUV2,
+     $            7HSMITH U,7HSMITH B,7HSMITH V,8HMASSEY R,
+     $            8HJ WE=.02,8HH WE=.02,8HK WE=.02,8HL WE=.02,8HM WE=.02
+     $           ,8H(10) BSW/ 
+      DATA IDIFF /1H ,7HUV1-UV2,1H ,3HU-B,3HB-V,3HV-R,6*1H /
 C***  CENTER FREQUENCIES OF THE COLOR BANDS
       DATA CENTER /1445.,1940.,
      $             3650.,4270.,5160.,6000.,1.26E4,1.60E4,2.22E4,
@@ -45,19 +39,21 @@
  
 C***  DATA: X-RAY VIEW OF W-R STARS  -----------------------------------
 C***  EFFECTIVE AREA OF EINSTEIN IPC (0.2 - 4.0 KEV)
+      NFIPC2=18
+      IF (NFIPC2 .GT. MAXIPC) STOP 'NFIPC2'
 C***  ENERGY VALUES [EV]
       DATA XEVIPC2 /4001.,4000.,3150.,2300.,2000.,1600.,1200.,800.,680.,
      $              510.,509.,440.,405.,260.,259.,210.,200.,199./
 C***  EFFECTIVE AREA [CM^2]
       DATA PHIIPC2 /0.1, 31.3, 73.1, 140., 140., 120., 75., 15.4, 1.,
      $             0.1, 7.3, 1.3, 0.1, 0.1, 54., 7.3, 7.1, 0.1/
-
 C***  EFFECTIVE AREA OF EINSTEIN IPC (0.8 - 4.0 KEV)
+      NFIPC8=9
+      IF (NFIPC8 .GT. MAXIPC) STOP 'NFIPC8'
 C***  ENERGY VALUES [EV]
       DATA XEVIPC8 /4001.,4000.,3150.,2300.,2000.,1600.,1200.,800.,799./
 C***  EFFECTIVE AREA [CM^2]
       DATA PHIIPC8 /0.1, 31.3, 73.1, 140., 140., 120., 75., 15.4, 0.1/
-
 C***  EFFECTIVE AREA OF ROSAT PSPC (0.07 - 2.4 KEV)
       NFPSPC=30
       IF (NFPSPC .GT. MAXPSPC) STOP 'NFPSPC'
@@ -113,7 +109,7 @@
          STRING = '  * ZERO *'
         ENDIF
       IF (CENTER(I) .LE. 10000.) THEN
-         IF (IDIFF(I) .EQ. ''  .OR. FCENTER .LE. .0) THEN
+         IF (IDIFF(I) .EQ. 1H  .OR. FCENTER .LE. .0) THEN
             PRINT 3, IBAND(I), CENTER(I), STRING
     3       FORMAT (10X, A8, F10.0, ' A ', A)
            ELSE
diff -bur ./pricorr.f ../../powr-refactor/src/pricorr.f
--- ./pricorr.f	2024-07-28 13:14:10.000000000 +0200
+++ ../../powr-refactor/src/pricorr.f	2023-09-27 10:14:15.121755744 +0200
@@ -1,25 +1,31 @@
-      SUBROUTINE PRICORR (POPNUM, POP1, LEVEL, N, ND, MODHEAD, LSPOP, 
-     $                   CORMAX, RTCMAX, JOBNUM, REDUCE, 
-     >                   GAMMAC, GAMMAL, GAMMAR, GAMMAD, 
+      SUBROUTINE PRICORR (POPNUM,POP1,LEVEL,N,ND,MODHEAD,LSPOP,
+     >                    CORMAX,RTCMAX,JOBNUM,REDUCE,CKONVER,
+     >                    GAMMAC,GAMMAL,GAMMAR, GAMMAD, 
      >                   TOLD, TNEW, EPSILON, DELTAC, SMALLPOP, BUNLU, 
-     $                   DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB,
-     >                   BTDIFFUS, TNDCORR, HNDCORFAC, GAHIST, MAXGAHIST, 
-     >                   STHLP, IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP,
-     >                   TBTAU, TAUINT)
+     >                    DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB,
+     >                    BTDIFFUS, TNDCORR, HNDCORFAC, GAHIST,  
+     >                    MAXGAHIST, STHLP, ICMMODE, IWARN_NEG_XJCAPP, 
+     >                    IWARN_NEG_XJLAPP, TBTAU, TAUINT, NDOUT, 
+     >                    NATOM, NOM, TRACEELEM)
 C*******************************************************************************
 C***  PRINTOUT OF CORRECTION FACTORS OF POPULATION NUMBERS
 C***  RELATIVE TO THE LAST ITERATION
 C***  Called from: STEAL, EXTRAP
 C*******************************************************************************
+      INTEGER, INTENT(IN) :: ND, N, NDOUT, NATOM
  
+      INTEGER, DIMENSION(N) :: NOM
       DIMENSION POPNUM(ND,N),  POP1(ND,N)
       DIMENSION TOLD(ND), TNEW(ND)
       DIMENSION GAHIST(26,MAXGAHIST)
-      CHARACTER LEVEL(N)*10
+      CHARACTER(1), DIMENSION(ND) :: CKONVER
+      CHARACTER(10), DIMENSION(N) :: LEVEL
       CHARACTER MODHEAD*100
       CHARACTER PRILINE*130,NUMBER*12
       CHARACTER*10 LEVMAX,LEVMIN,LEVMA2,LEVMI2
-      LOGICAL BUNLU, BTDIFFUS, STHLP
+      LOGICAL, DIMENSION(NATOM) :: TRACEELEM
+      LOGICAL BUNLU, BTDIFFUS, STHLP, bConsiderDepth
+      INTEGER :: NDMIN, ICMMODE
 C***  COMMON /GIIIERR/ COUNTS THE ERROR MESSAGES FROM SUBR. GAUNTFF
       COMMON / GIIIERR /  NTUP,NTLOW,NFUP,NFLOW,NHELP
 C***  NEGINTL COUNTS THE ERROR MESSAGES  FROM SUBR. LINPOP
@@ -30,14 +36,22 @@
 C***  SUBR. LINPOP
       COMMON / COMITWA / ITWARN, ITMAX
 
+C***  File and channel handles (=KANAL)
+      INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
+      INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
  
 C*********************************************************
 C***  SET NDMIN = FIRST DEPTH INDEX WHICH IS ACCOUNTED FOR
 C***               IN THE CONVERGENCE CRITERION
 C**********************************************************
+      IF (NDOUT > 0) THEN
+C***  CARDS option added which allows manual adjustment of NDMIN, by ansander at 02-Oct-2016
+        NDMIN = NDOUT
+      ELSE
 C***      NDMIN = 9
 C***  New Version, Lars 30-Jul-1998 10:15:26
       NDMIN = ND / 8 + 1
+      ENDIF
 
 C**********************************************************************
 C***  SET SMALLPOP : SMALLER POPNUMBERS ARE NOT ACCOUNTED FOR
@@ -63,13 +77,11 @@
  
       DO 3 L=1,ND
       IF(((L-1)/LSPOP)*LSPOP.NE.(L-1) .AND. L.NE.ND) GOTO 3
-         WRITE(PRILINE,6) L
-    6 FORMAT (I6)
+      WRITE (UNIT=PRILINE, FMT='(I6)') L
  
       DO 12 J=J1,J2
       IF (POP1(L,J) .NE. .0) THEN
-            WRITE(NUMBER,11)  POPNUM(L,J)/POP1(L,J)
-   11       FORMAT (F12.4)
+          WRITE (UNIT=NUMBER, FMT='(F12.4)') POPNUM(L,J)/POP1(L,J)
             ELSE
             NUMBER='    INFINITE'
             ENDIF
@@ -116,10 +128,17 @@
       LMIN=0
       LMI2=0
       NSMALL = 0
+      NTRACE = 0
 
       DO 7 L=NDMIN,ND
       DO 7 J = 1, N
       POP1LJ=POP1(L,J)
+C***  CHECK IF CURRENT LEVEL BELONGS TO TRACE ELEMENTS => not considered
+      IF (TRACEELEM(NOM(J))) THEN
+        NTRACE = NTRACE + 1
+        CYCLE
+      ENDIF
+      
 C***  TOO SMALL OR NEGATIVE POPNUMBERS ARE CONSIDERED AS BEEING = SMALLPOP  **
       IF (POP1LJ .LT. SMALLPOP) POP1LJ = SMALLPOP
       POPLJ=POPNUM(L,J)
@@ -129,6 +148,16 @@
         POPLJ = SMALLPOP
         NSMALL = NSMALL + 1
       ELSE
+        SELECTCASE (ICMMODE)
+          CASE (0)
+            bConsiderDepth = .TRUE.                    
+          CASE (1)
+            bConsiderDepth = (CKONVER(L) == 'C')
+          CASE DEFAULT
+            WRITE (hCPR,*) 'Invalid CORMAX-MODE, please change CARDS'
+            STOP 'FATAL ERROR IN PRICORR'
+        ENDSELECT
+        IF (bConsiderDepth) THEN
         Q=POPLJ/POP1LJ
         IF (Q .GT. QMA2) THEN
            IF (Q .GT. QMAX) THEN
@@ -163,6 +192,7 @@
            ENDIF
         ENDIF
       ENDIF
+      ENDIF
     7 CONTINUE
 
 C***********************************************************************
@@ -201,11 +231,11 @@
 
         IF (DUNLU_TB .GT. .0) PRINT 36, TBTAU 
    36    FORMAT 
-     >   (15X, 'Thermal Balance term suppressed for tau_Ross >', F6.3)
+     >   (15X, 'Thermal Balance term suppressed for tau_Ross >', G12.5)
 
         IF (TAUINT > .0) PRINT 37, TAUINT
    37    FORMAT 
-     >   (15X, 'INT and RMAX term damped depth-dependent, TAUINT=', F5.1)
+     >   (15X, 'INT and RMAX term damped depth-dependent, TAUINT=', F8.2)
 
         PRINT *     
 
@@ -238,6 +268,10 @@
    27 FORMAT ( 8X, I6, 
      >  ' WARNINGS: POP. NUMBERS .LT.', 1PE8.1, 
      >  ' NOT ACCOUNTED FOR IN THE MAX. CORRECTIONS')
+      IF (NTRACE > 0) THEN
+        WRITE (hOUT, FMT='(A,I6,A)') 'NOTE: ', NTRACE, 
+     >   ' TRACE LEVELS NOT ACCOUNTED FOR IN THE MAX. CORRECTIONS'
+      ENDIF
 
 C***  PRINTOUT OF WARNINGS FROM SUBROUTINE LINPOP  *********************
 
diff -bur ./pridat.f ../../powr-refactor/src/pridat.f
--- ./pridat.f	2024-07-28 13:14:10.000000000 +0200
+++ ../../powr-refactor/src/pridat.f	2023-09-27 10:14:15.121755744 +0200
@@ -2,7 +2,7 @@
      $                   KEY,NF,ALPHA,SEXPO,
      $                   ADDCON1, ADDCON2, ADDCON3, 
      $                   IGAUNT, SIGMATHK, SEXPOK, EDGEK, MAXATOM,
-     >                   COCO,KEYCBB, ALTESUM,
+     >                   MAXION, COCO,KEYCBB, ALTESUM,
      $                   NATOUT,NATOM,ELEMENT,NOM,ABXYZ,ATMASS,
      $                   NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $                   IONAUTO,
@@ -21,8 +21,7 @@
       DIMENSION ADDCON1(LASTKON), ADDCON2(LASTKON), ADDCON3(LASTKON)
       DIMENSION KONTNUP(LASTKON),KONTLOW(LASTKON),KEYCBF(LASTKON)
       DIMENSION INDNUP(LASTIND),INDLOW(LASTIND)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION NOM(N)
       DIMENSION ABXYZ(NATOM),ATMASS(NATOM)
       DIMENSION COCO(4,LASTIND)
@@ -178,7 +177,7 @@
      $'   ELEMENT       SIGMA         EXPONENT    IONISATION-ENERGY ',/,
      $'            (10**-18 CM**2)                    (KAYSER) ',/)
 
-      DO ISTATE=1, MAXATOM
+      DO ISTATE=1, MAXION
          IF (EDGEK(NA,ISTATE) .NE. .0) 
      >     PRINT 51, ELEMENT(NA), ISTATE, SIGMATHK(NA,ISTATE), 
      >                                    SEXPOK  (NA,ISTATE),
diff -bur ./pri_epsg.f ../../powr-refactor/src/pri_epsg.f
--- ./pri_epsg.f	2024-07-28 13:14:08.000000000 +0200
+++ ../../powr-refactor/src/pri_epsg.f	2023-11-21 10:10:55.293269795 +0100
@@ -21,16 +21,16 @@
      >    '   BEMIXFIX=', BEMIXFIX, 
      >    '      Note: Lines containing only zero are omitted'
         IF (ITMAX .EQ. 3) THEN
-          WRITE (0,'(8X,5A8)') 
+          WRITE (0,'(8X,2A8,3A13)') 
      >      'DEPTH', 'JOBNUM', 'IT=1', 'IT=2', 'IT=3'
         ELSE
-          WRITE (0,'(8X,5A8)') 
+          WRITE (0,'(8X,2A8,3A13)') 
      >      'DEPTH', 'JOBNUM', 'IT=1', 'IT=2'
         ENDIF
           DO L=1, ND
             EMAX = AMAX1(EPSG(L,1), EPSG(L,2), EPSG(L,3))
           IF (EMAX .EQ. 0.) CYCLE
-            WRITE (0,'(A6,4X,I2,6X,I7,2X,3(1X,F7.2))')
+            WRITE (0,'(A6,4X,I2,6X,I7,2X,3(1X,G12.4))')
      >        'EMIX: ', 
      >        L, JOBNUM, (EPSG(L,ITLOCAL), ITLOCAL=1, ITMAX)
           ENDDO
diff -bur ./priflux.f ../../powr-refactor/src/priflux.f
--- ./priflux.f	2024-07-28 13:14:11.000000000 +0200
+++ ../../powr-refactor/src/priflux.f	2023-09-27 10:14:15.121755744 +0200
@@ -4,11 +4,10 @@
 C***   PRINTOUT OF THE EMERGENT CONTINUUM FLUX
 C***********************************************************************
  
-      DIMENSION XLAMBDA(NF),EMFLUX(NF),FWEIGHT(NF), EMCOLI(NF)
+      DIMENSION XLAMBDA(NF),EMFLUX(NF),FWEIGHT(NF),KEY(NF), EMCOLI(NF)
       CHARACTER*30 MODHEAD*100
       CHARACTER*8 ITCOL, IFSUM, JUMP
-      CHARACTER(8), DIMENSION(NF) :: KEY 
-      CHARACTER*5 NEDGE
+ 
       LOGICAL BEMCOLI
 
 C***  CLIGHT = SPEED OF LIGHT ( CM/SEC )
@@ -64,23 +63,20 @@
       FSUM=FSUM+FK*FWEIGHT(K)
       IF (FSUM .GT. .0) THEN
          FSUMLOG=ALOG10(FSUM)
-ccc         ENCODE (8,5,IFSUM) FSUMLOG
-         WRITE (IFSUM,5) FSUMLOG
+         ENCODE (8,5,IFSUM) FSUMLOG
     5    FORMAT (F8.3)
          ELSE
          IFSUM='    -INF'
          ENDIF
 C***  CONTINUUM JUMPS AT EDGE FREQUENCIES
       JUMP=' '
-c      DECODE (5,99,KEY(K)) NEDGE
-c   99 FORMAT (A5)
-      NEDGE = KEY(K)(1:5)
-      IF (NEDGE .EQ. 'EDGE+' .OR. NEDGE .EQ. 'K-ED+') THEN
+      DECODE (5,99,KEY(K)) NEDGE
+   99 FORMAT (A5)
+      IF (NEDGE .EQ. 5HEDGE+ .OR. NEDGE .EQ. 5HK-ED+) THEN
          IF (EMFLUX(K-1) .LE. .0 .OR. EMFLUX(K) .LE. .0) THEN
             JUMP='   UNDEF'
             ELSE
-c            ENCODE (8,8,JUMP) ALOG10(EMFLUX(K)/EMFLUX(K-1))*2.5
-            WRITE (JUMP,8) ALOG10(EMFLUX(K)/EMFLUX(K-1))*2.5
+            ENCODE (8,8,JUMP) ALOG10(EMFLUX(K)/EMFLUX(K-1))*2.5
     8       FORMAT (F8.3)
             ENDIF
          ENDIF
diff -bur ./primod.f ../../powr-refactor/src/primod.f
--- ./primod.f	2024-07-28 13:14:14.000000000 +0200
+++ ../../powr-refactor/src/primod.f	2023-09-27 10:14:15.121755744 +0200
@@ -133,6 +133,8 @@
 C***  MESSAGES CONCERNING THE VELOCITY FIELD 
       IF (RCON == 1.) THEN
          PRINT *, 'VELOCITY FIELD: NO HYDROSTATIC DOMAIN ENCOUNTERED'
+      ELSEIF (RCON > RADIUS(1) .AND. bStartCall) THEN
+         PRINT *, 'VELOCITY FIELD: OLD STRATIFICATION USED'
       ELSE 
          PRINT '(2A,G10.3,A,1PG12.3,A)', 
      >         ' VELOCITY FIELD: HYDROSTATIC DOMAIN ',
@@ -143,8 +145,8 @@
          IF (VTURB .GT. .0) PRINT '(A, F6.1)',
      >      ' TURBULENCE PRESSURE TAKEN INTO ACCOUNT, VTURB=', VTURB
          ENDIF
-      IF (BETA .GT. .0) PRINT '(A,F4.1,A,3PG12.6,A,1PG12.3)',
-     >  ' OUTER PART: BETA=', BETA, ' LAW, VPAR1=', VPAR1
+      IF (ABS(BETA) .GT. .0) PRINT '(A,F4.1,A,3PG12.6,1(A,1PG12.3))',
+     >  ' OUTER PART: BETA=', ABS(BETA), ' LAW, VPAR1=', VPAR1
      >  ,' , VPAR2=', VPAR2
       IF (BETA2FRACTION .GT. .0) PRINT '(13X,A,F4.2,A,F5.2)',
      >  '2-BETA-LAW:  BETA2FRACTION=', BETA2FRACTION,
diff -bur ./printmodelsummary.f ../../powr-refactor/src/printmodelsummary.f
--- ./printmodelsummary.f	2024-07-28 13:14:15.000000000 +0200
+++ ../../powr-refactor/src/printmodelsummary.f	2023-09-27 10:14:15.121755744 +0200
@@ -20,6 +20,7 @@
      >                              INCRIT,     !Rgrid depth point criterion per depth point
      >                              VELOCRIT,   !Vgrid calculation criterion per depth point
      >                              VTURB,      !Turbulence velocity in km/s
+     >                              VMACH,      !Sound speed in km/s (w/o turbulence)
      >                              bThinWind,  !determines if HYDROSTATIC INTEGRATION was used
      >                              bHYDROSOLVE,!determines if HYDROSOLVE was used
      >                              WORKRATIO,  !current work ratio of the model
@@ -34,10 +35,13 @@
      >                              ELEMENT,    !Element corresponding to atom integer index
      >                              SYMBOL,     !same as above but only symbol instead of full name
      >                              bFULLHYDROSTAT,
+     >                              MAXATOM,
+     >                              KODAT,
      >                              GEDDRAD,
      >                              ARAD,
      >                              APRESS,
      >                              AGRAV,
+     >                              HTOTOBS,
      >                              GAMMARADMEAN,
      >                              QIONMEAN,
      >                              bFixGEFF
@@ -50,18 +54,22 @@
       IMPLICIT NONE
       INCLUDE 'interfacebib.inc'
 
-      INTEGER, INTENT(IN) :: ND, NATOM
+      INTEGER, INTENT(IN) :: ND, NATOM, MAXATOM
       REAL, DIMENSION(ND), INTENT(IN) :: DENSCON, FILLFAC, RADIUS, VELO,
-     >                                   GRADI, RNE, ENTOT, T, TAUROSS
+     >                                   GRADI, RNE, ENTOT, T, TAUROSS, 
+     >                                   VMACH, VTURB, HTOTOBS
       REAL, DIMENSION(ND-1), INTENT(IN) :: ARAD, APRESS, AGRAV
       REAL, DIMENSION(ND), INTENT(INOUT) :: XMU
-      REAL, DIMENSION(ND) :: AMACH, VSCRATCH
+      REAL, DIMENSION(ND) :: VSCRATCH
       REAL, DIMENSION(ND-1) :: RI
       REAL, DIMENSION(NATOM), INTENT(IN) :: ABXYZ, ATMASS 
-      REAL, INTENT(IN) :: TEFF, RSTAR, VDOP, RCON, LOGMDOT, VTURB, 
+      REAL, DIMENSION(NATOM) :: VTHELEM
+      REAL, INTENT(IN) :: TEFF, RSTAR, VDOP, RCON, LOGMDOT, 
      >                    WORKRATIO, GEDDRAD
       REAL, INTENT(INOUT) :: LOGL, RTRANS, GEDD, GLOG, GEFFLOG, MSTAR
       
+      INTEGER, DIMENSION(MAXATOM) :: KODAT
+      
       CHARACTER(2), DIMENSION(NATOM), INTENT(IN) :: SYMBOL
       CHARACTER(8), DIMENSION(ND), INTENT(IN) :: INCRIT, VELOCRIT
       CHARACTER(10), DIMENSION(NATOM), INTENT(IN) :: ELEMENT
@@ -72,14 +80,15 @@
 
       INTEGER, EXTERNAL :: IDX
 
-      INTEGER :: NA, L, Lcand, LCON
+      INTEGER :: NA, L, Lcand, LCON, Ltcand, NAFE
       REAL :: RSTARSU, ATMEAN, XELEM, VFINAL, VMIN, FM, VESC, VESCFULL,
      >        Dout, T1, T13, T23, R1, R13, R23, TAU1, TAU13, TAU23,
      >        Tindex, Rtindex, RL1, RL2, LOGQ, gammaIon, MDOTNL, GEDDe,
      >        LOGMDOTTRANS, LOGDMOM, Rsonic, Vsonic, XMUsonic, Tsonic,
      >        GAMMARAD, LOGLINF, QIONMEAN, GAMMARADMEAN, fdummy, q,
      >        G23LOG, GEFF23LOG, ASTAR, ETA, Rscrit, Vscrit, VTH, VTEST,
-     >        TAUsonic, TAUscrit, VMICND, LOGLINFTEST, LWINDSUB
+     >        TAUsonic, TAUscrit, VMICND, LOGLINFTEST, LWINDSUB,
+     >        VESC23, VESCFULL23
       CHARACTER(2) :: VCRIT
       CHARACTER(100) :: CTABLINE
 
@@ -117,6 +126,7 @@
       ATMEAN = .0
       DO NA=1, NATOM
         ATMEAN = ATMEAN + ABXYZ(NA)*ATMASS(NA)
+        VTHELEM(NA) = -1.
       ENDDO
       DO L=1, ND
         XMU(L) = ATMEAN / (1. + RNE(L))
@@ -137,11 +147,12 @@
           RI(L) = 0.5 * (RADIUS(L) + RADIUS(L+1))
         ENDDO
         !This updates MSTAR, GLOG, GEDD, GAMMARADMEAN
+        WRITE (hCPR,*) 'calcmassfromgeff called'
         CALL CALCMASSFROMGEFF(bFixGEFF, bFULLHYDROSTAT,
      >                        MSTAR, GLOG, GEFFLOG, 
      >                        ARAD, APRESS, AGRAV, RADIUS, ND,
-     >                        RSTAR, RCON, RI, TAUROSS,
-     >                        GAMMARADMEAN, GEDD,
+     >                        RSTAR, RCON, RI, VELO, TAUROSS,
+     >                        VMACH, GAMMARADMEAN, GEDD,
      >                        LOGL, QIONMEAN, fdummy)
       ENDIF
       
@@ -149,20 +160,39 @@
       !Find sonic point parameters
       Lcand = 0
       DO L=1, ND
-        AMACH(L) = SQRT( RGAS * T(L) / XMU(L) ) / 1.E5      !a_mach in km/s
-        VSCRATCH(L) = VELO(L) - AMACH(L)        
+        VSCRATCH(L) = VELO(L) - VMACH(L)        
         IF ((VSCRATCH(L) < 0) .AND. (Lcand == 0)) THEN
           Lcand = L
         ENDIF
+        DO NA=1, NATOM        
+          VTH = SQRT(2.*RGAS*T(L)/ATMASS(NA)) / 1.E5
+          VTEST = VELO(L) - VTH 
+          IF (VTEST < 0. .AND. VTHELEM(NA) < 0.) THEN
+            VTHELEM(NA) = VTH      !thermal speed per element (neglecting electron masses for ions)
+          ENDIF
+        ENDDO
       ENDDO
       IF (Lcand > 0) THEN
         CALL SPLINPOX(Rsonic,0.,RADIUS,VSCRATCH,ND,.FALSE.,Lcand)
-        CALL SPLINPOX(Vsonic,Rsonic,AMACH,RADIUS,ND)
+        CALL SPLINPOX(Vsonic,Rsonic,VMACH,RADIUS,ND)
         CALL SPLINPOX(Tsonic,Rsonic,T,RADIUS,ND)
         CALL SPLINPOX(XMUsonic,Rsonic,XMU,RADIUS,ND)
         CALL SPLINPOX(gammaIon,Rsonic,RNE,RADIUS,ND)
+        CALL SPLINPOX(TAUsonic,Rsonic,TAUROSS,RADIUS,ND)
+      ENDIF
+      !Current critical point
+      Ltcand = 0
+      DO L=1, ND
+        VSCRATCH(L) = VELO(L) - SQRT(VMACH(L)**2  + VTURB(L)**2)
+        IF ((VSCRATCH(L) < 0) .AND. (Ltcand == 0)) THEN
+          Ltcand = L
+        ENDIF
+      ENDDO
+      IF (Ltcand > 0) THEN
+        CALL SPLINPOX(Rscrit,0.,RADIUS,VSCRATCH,ND,.FALSE.,Ltcand)
+        CALL SPLINPOX(Vscrit,Rscrit,VELO,RADIUS,ND)
+        CALL SPLINPOX(TAUscrit,Rscrit,TAUROSS,RADIUS,ND)
       ENDIF
-            
         
       Dout = DENSCON(1)
       RTRANS = 
@@ -171,9 +201,9 @@
 
 
       WRITE(hSUMMARY,'(A,F10.2)') '\VAR TEFF    = ', TEFF
-      WRITE(hSUMMARY,'(A,1PG14.4)') '\VAR RSTAR   = ', RSTAR   !in cm
-      WRITE(hSUMMARY,'(A,F8.3)') '\VAR RSTARSU = ', RSTARSU  !in Rsun
-      WRITE(hSUMMARY,'(A,F5.3)') '\VAR LOGL    = ', LOGL     !log L/Lsun
+      WRITE(hSUMMARY,'(A,F20.2)') '\VAR RSTAR   = ', RSTAR   !in cm
+      WRITE(hSUMMARY,'(A,F12.4)') '\VAR RSTARSU = ', RSTARSU  !in Rsun
+      WRITE(hSUMMARY,'(A,F8.4)') '\VAR LOGL    = ', LOGL     !log L/Lsun
       WRITE(hSUMMARY,'(A,F12.4)') '\VAR RTRANS  = ', RTRANS   !Rtrans in solar radii
       WRITE(hSUMMARY,'(A,F9.3)') '\VAR VFINAL  = ', VFINAL   !v_inf in km/s
       WRITE(hSUMMARY,'(A,F9.3)') '\VAR VMIN    = ', VMIN     !v_min in km/s
@@ -182,13 +212,22 @@
         WRITE(hSUMMARY,'(A,F9.3)') '\VAR RSONIC  = ', Rsonic   !Rsonic in Rstar
         WRITE(hSUMMARY,'(A,F9.3)') '\VAR RSONICSU = ', Rsonic * RSTARSU  !Rsonic in Rsun
       ENDIF
+      IF (Ltcand > 0) THEN
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR VSCRIT  = ', Vscrit   !v_sonic in km/s
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR RSCRIT  = ', Rscrit   !Rsonic in Rstar
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR RSCITSU = ', Rscrit * RSTARSU  !Rsonic in Rsun
+      ENDIF
       WRITE(hSUMMARY,'(A,F7.3)') '\VAR LOGMDOT = ', LOGMDOT  !log Mdot/(Msol/yr)
       WRITE(hSUMMARY,'(A,F6.2)') '\VAR DENSCON = ', 
      >                                 MAXVAL(DENSCON(1:ND)) !maximum D value
       WRITE(hSUMMARY,'(A,F9.3)') '\VAR VDOP    = ', VDOP
-      WRITE(hSUMMARY,'(A,F8.2)') '\VAR RMAX    = ', RADIUS(1)        !in Rstar (als Kontrolle fuer RMAX)
+      NAFE = KODAT(26)
+      IF (NAFE > 0 .AND. VTHELEM(NAFE) > 0.) THEN
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR VTHFE    = ', VTHELEM(NAFE)
+      ENDIF
+      WRITE(hSUMMARY,'(A,F12.3)') '\VAR RMAX    = ', RADIUS(1)        !in Rstar (als Kontrolle fuer RMAX)
       IF (RCON > 0.) THEN
-        WRITE(hSUMMARY,'(A,F10.5)') '\VAR RCON    = ', RCON     !in Rstar
+        WRITE(hSUMMARY,'(A,F12.5)') '\VAR RCON    = ', RCON     !in Rstar
       ENDIF
       
       ETA = 10**(LOGMDOT) * XMSUNPYR * VFINAL * 1.E5 * CLIGHT 
@@ -255,18 +294,26 @@
       ELSE 
         VESCFULL = -99.
       ENDIF
+      IF (HTOTOBS(1) > 0.) THEN
+        LOGLINFTEST = LOG10( PI4*PI4 * (RADIUS(1)*RSTAR)**2.
+     >                           * HTOTOBS(1)  / XLSUN )
+      ELSE 
+        LOGLINFTEST = -99.
+      ENDIF
       LWINDSUB = 10**(LOGMDOT) * XMSUNPYR/XLSUN * 1.E10 *
      >                    ( VFINAL**2 + VESC**2 ) / 2.
       IF (LWINDSUB < 10**LOGL) THEN
         LOGLINF = LOG10( 10**(LOGL) 
      >                 - LWINDSUB )
+        WRITE(hCPR,'(A,F8.3,1X,F8.3)') 'Linf, Linftest ',
+     >                                LOGLINF, LOGLINFTEST
       ELSE
         WRITE(hCPR,'(A)')
      >    '*** WARNING: WIND CONSUMES MORE LUMINOSITY THAN PROVIDED'
         WRITE(hOUT,'(A)')
      >    '*** WARNING: WIND CONSUMES MORE LUMINOSITY THAN PROVIDED'
         WRITE(hCPR,'(A,3(1X,F8.3))') 'L, Lsub, Linftest ',
-     >                      LOGL, LOG10(LWINDSUB)
+     >                      LOGL, LOG10(LWINDSUB), LOGLINFTEST        
       ENDIF
 
       WRITE(hSUMMARY,'(A,F8.3)') '\VAR MSTAR   = ', MSTAR
@@ -276,9 +323,9 @@
       ENDIF
       WRITE(hSUMMARY,'(A,F6.3)') '\VAR GEDD    = ', GEDDe     !Eddington Gamma_e (Thomson only)
       WRITE(hSUMMARY,'(A,F6.3)') '\VAR GAMMARAD = ', GAMMARAD !Eddington Gamma with full a_rad
-      WRITE(hSUMMARY,'(A,F9.3)') '\VAR VTURB   = ', VTURB     !Turbulence velocity
-      VMICND = VTURB * SQRT(2.)
-      WRITE(hSUMMARY,'(A,F9.3)') '\VAR VMIC   = ', VMICND     !literature microturbulence value
+      WRITE(hSUMMARY,'(A,F9.3)') '\VAR VTURB   = ', VTURB(ND) !Turbulence velocity
+      VMICND = VTURB(ND) * SQRT(2.)
+      WRITE(hSUMMARY,'(A,F9.3)') '\VAR VMIC   = ', VMICND !Turbulence velocity
       IF (VESC >= 0.) THEN
         WRITE(hSUMMARY,'(A,F9.3)') '\VAR VESC    = ', VESC    !Escape velocity at Rstar
       ELSE 
@@ -301,9 +348,9 @@
         !calculate mass fraction of current element
         !note: ELEMENT(NA) returns the Name, SYMBOL(NA) just He, C, ...
         XELEM = ABXYZ(NA)*ATMASS(NA) / ATMEAN
-        WRITE(hSUMMARY,'(A8,A2,A5,F7.5)')
+        WRITE(hSUMMARY,'(A8,A2,A5,G12.6)')
      >     '\VAR Xn_',ADJUSTL(SYMBOL(NA)), '   = ', ABXYZ(NA)      !by number
-        WRITE(hSUMMARY,'(A8,A2,A5,F7.5)') 
+        WRITE(hSUMMARY,'(A8,A2,A5,G12.6)') 
      >     '\VAR Xm_',ADJUSTL(SYMBOL(NA)), '   = ', XELEM          !by mass
       ENDDO
 
@@ -376,8 +423,34 @@
         GEFF23LOG = GEFFLOG - 2. * LOG10(R23)
         WRITE(hSUMMARY,'(A,F8.4)') '\VAR GEFF23LOG = ', GEFF23LOG
       ENDIF
+      IF (GEDDe < 1.) THEN
+        VESC23 = SQRT(2*GCONST*MSTAR*MSUN * (1. - GEDDe) / (R23*RSTAR)) / 1.E5
+      ELSE 
+        VESC23 = -99.
+      ENDIF
+      IF (GAMMARAD < 1.) THEN
+        VESCFULL23 = SQRT(2*GCONST*MSTAR*MSUN*(1.-GAMMARAD)/(R23*RSTAR)) / 1.E5
+      ELSE 
+        VESCFULL23 = -99.
+      ENDIF
+      IF (VESC23 >= 0.) THEN
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR VESC23  = ', VESC23    !Escape velocity at R23
+      ELSE 
+        WRITE(hSUMMARY,'(A)')    '\VAR VESC23  = invalid'     !supereddington, no escape velocity at R23
+      ENDIF
+      IF (VESCFULL23 >= 0.) THEN
+        WRITE(hSUMMARY,'(A,F9.3)') '\VAR VESCFULL23 = ', VESCFULL23 !Escape velocity at R23 w/ full GAMMARAD
+      ELSE 
+        WRITE(hSUMMARY,'(A)')    '\VAR VESCFULL23 = invalid'      !supereddington, no escape velocity at R23
+      ENDIF
 
       WRITE(hSUMMARY,'(A,F10.4)') '\VAR TAUMAX  = ', TAUROSS(ND)
+      IF (Lcand > 0) THEN
+        WRITE(hSUMMARY,'(A,F10.4)') '\VAR TAUSONIC  = ', TAUsonic     !Tau_sonic (full Tau)
+      ENDIF
+      IF (Ltcand > 0) THEN
+        WRITE(hSUMMARY,'(A,F10.4)') '\VAR TAUSCRIT  = ', TAUscrit     !Tau_scrit (full Tau)
+      ENDIF
       WRITE(hSUMMARY,'(A,F6.3)')  '\VAR WORKRATIO = ', WORKRATIO    !calculated in INITFCORR
       
       !Grid index calculation
diff -bur ./priopa.f ../../powr-refactor/src/priopa.f
--- ./priopa.f	2024-07-28 13:14:15.000000000 +0200
+++ ../../powr-refactor/src/priopa.f	2023-09-27 10:14:15.121755744 +0200
@@ -7,12 +7,9 @@
       DIMENSION OPA(ND),ETA(ND),THOMSON(ND),R(ND),IWARN(ND)
       CHARACTER*10 MAINPRO(ND),MAINLEV(ND)
       CHARACTER MODHEAD*100
-      DATA IHELP / 0 /
-
-C***  Header shold be printed only at first call
-      IF (IHELP .NE. 0) GOTO 1
-      IHELP = 1
 
+      IF (IHELP.EQ.5HIHELP) GOTO 1
+      IHELP=5HIHELP
       PRINT 2,MODHEAD,JOBNUM
     2 FORMAT (1X,A,20X,'JOB NO.',I3,//,10X,
      $ 'CONTINUOUS OPACITY, EMISSIVITY AND SOURCE FUNCTION',
diff -bur ./pripop.f ../../powr-refactor/src/pripop.f
--- ./pripop.f	2024-07-28 13:14:16.000000000 +0200
+++ ../../powr-refactor/src/pripop.f	2023-09-27 10:14:15.121755744 +0200
@@ -62,14 +62,12 @@
       DO 23 I=NFIRNA,NLANA
    23 RNESUM=RNESUM+NCHARG(I)*POPNUM(L,I)
       RELRNE=RNESUM/ABNA
-c      ENCODE (130,9,PRILINE) L,RELRNE,ITNE(L)
-      WRITE (PRILINE,9) L,RELRNE,ITNE(L)
+      ENCODE (130,9,PRILINE) L,RELRNE,ITNE(L)
     9 FORMAT(I3,F7.3,I3)
  
       DO 5 J=J1,J2
       IF (POPNUM(L,J) .NE. .0) THEN
-c          ENCODE(16,8,NUMBER) ALOG10(ABS(POPNUM(L,J)))-ABLOG,DEPART(L,J)
-          WRITE (NUMBER,8) ALOG10(ABS(POPNUM(L,J)))-ABLOG,DEPART(L,J)
+          ENCODE(16,8,NUMBER) ALOG10(ABS(POPNUM(L,J)))-ABLOG,DEPART(L,J)
     8     FORMAT (F6.2,G10.3)
       ELSE
           NUMBER='****  ZERO  ****'
diff -bur ./prirat.f ../../powr-refactor/src/prirat.f
--- ./prirat.f	2024-07-28 13:14:16.000000000 +0200
+++ ../../powr-refactor/src/prirat.f	2023-09-27 10:14:15.121755744 +0200
@@ -61,8 +61,7 @@
       WRITE (11,4)
     4 FORMAT (1X)
       DO 5 I=NFIRNA,NLANA
-c      ENCODE (120,40,NUMBERS) (RATCO(I,J),J=J1,J2)
-      WRITE (NUMBERS,40) (RATCO(I,J),J=J1,J2)
+      ENCODE (120,40,NUMBERS) (RATCO(I,J),J=J1,J2)
       DO 43 M=1,10
       IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
    43 CONTINUE
@@ -84,8 +83,7 @@
       DO 66 J=J1,J2
       M=1+J-J1
       IF (RRATE(I,J) .NE. .0) THEN
-c         ENCODE (12,40,NUMBERS(M)) CRATE(I,J)/RRATE(I,J)
-         WRITE (NUMBERS(M),40) CRATE(I,J)/RRATE(I,J)
+         ENCODE (12,40,NUMBERS(M)) CRATE(I,J)/RRATE(I,J)
          IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
          ELSE
          NUMBERS(M)=' '
@@ -114,8 +112,7 @@
       IF ((I .GT. J) .AND. (I .EQ. IONGRND(J))) DRRATE=RDIEL(J)
       M=1+J-J1
       IF (RRATE(I,J)+CRATE(I,J) .NE. .0) THEN
-c         ENCODE (12,40,NUMBERS(M)) DRRATE/(CRATE(I,J)+RRATE(I,J))
-         WRITE (NUMBERS(M),40) DRRATE/(CRATE(I,J)+RRATE(I,J))
+         ENCODE (12,40,NUMBERS(M)) DRRATE/(CRATE(I,J)+RRATE(I,J))
          IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
          ELSE
          NUMBERS(M)=' '
@@ -142,8 +139,7 @@
      $       I3,//,11X,10(2X,A10))
       WRITE (11,4)
       DO 22 I=NFIRNA,NLANA
-c      ENCODE (120,40,NUMBERS) (RATCO(I,J),J=J1,J2)
-      WRITE (NUMBERS,40) (RATCO(I,J),J=J1,J2)
+      ENCODE (120,40,NUMBERS) (RATCO(I,J),J=J1,J2)
       DO 44 M=1,10
       IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
    44 CONTINUE
@@ -160,8 +156,7 @@
      $       I3,//,11X,10(2X,A10))
       WRITE (11,4)
       DO 8 I=NFIRNA,NLANA
-c      ENCODE (120,40,NUMBERS) (RATCO(I,J)-RATCO(J,I),J=J1,J2)
-      WRITE (NUMBERS,40) (RATCO(I,J)-RATCO(J,I),J=J1,J2)
+      ENCODE (120,40,NUMBERS) (RATCO(I,J)-RATCO(J,I),J=J1,J2)
    40 FORMAT (1P,10E12.2)
       DO 41 M=1,10
       IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
@@ -184,8 +179,7 @@
    30       SCALE=SCALE+ABS(RATCO(I,J)-RATCO(J,I))
          SCALE=SCALE/2.
          IF (SCALE.LE.0.) SCALE=1.
-c      ENCODE (120,40,NUMBERS) ((RATCO(I,J)-RATCO(J,I))/SCALE,J=J1,J2)
-      WRITE (NUMBERS,40) ((RATCO(I,J)-RATCO(J,I))/SCALE,J=J1,J2)
+      ENCODE (120,40,NUMBERS) ((RATCO(I,J)-RATCO(J,I))/SCALE,J=J1,J2)
       DO 45 M=1,10
       IF (NUMBERS(M) .EQ. '    0.00E+00') NUMBERS(M)='    0       '
    45 CONTINUE
diff -bur ./radio.f ../../powr-refactor/src/radio.f
--- ./radio.f	2024-07-28 13:14:18.000000000 +0200
+++ ../../powr-refactor/src/radio.f	2023-09-27 10:14:15.121755744 +0200
@@ -4,7 +4,7 @@
      >                  RDIEL,RAUTO,IONAUTO,IONGRND,
      >                  INDNUP,INDLOW,LASTIND,KONTNUP,KONTLOW,LASTKON,
      >                  NATOM,MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-     >                  NFIRST,NLAST,NCHARG,KRUDAUT)
+     >                  NFIRST,NLAST,NCHARG,KRUDAUT,MAXION)
  
 C*******************************************************************************
 C***  RADIATIVE RATES ARE CALCULATED AT ONE DEPTH POINT L FROM THE GIVEN
@@ -18,11 +18,10 @@
 C*******************************************************************************
  
 C***  Dimension of the core-charge data locally provided here
-      PARAMETER ( MAXATOMDIM = 26)
+      PARAMETER ( MAXATOMDIM = 30)
 
       DIMENSION KODAT(MAXATOM)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION NFIRST(NATOM),NLAST(NATOM)
       DIMENSION NCHARG(NDIM)
       DIMENSION RRATE(NDIM,NDIM),EINST(NDIM,NDIM)
diff -bur ./radnet.f ../../powr-refactor/src/radnet.f
--- ./radnet.f	2024-07-28 13:14:18.000000000 +0200
+++ ../../powr-refactor/src/radnet.f	2023-09-27 10:14:15.121755744 +0200
@@ -5,8 +5,8 @@
      $                  DRRATEN,RDIEL,RAUTO,DRJLW,DRJLWE,DRLJW,
      $                  INDNUP,INDLOW,LASTIND,KONTNUP,KONTLOW,LASTKON,
      $                  NFEDGE,NATOM,MAXATOM,SIGMATHK,SEXPOK,EDGEK,
-     $                  KODAT,NFIRST,NLAST, KRUDAUT,L,ND, 
-     >                  NRB_CONT, EXPFAC, WCHARM)
+     $                  KODAT,NFIRST,NLAST, KRUDAUT,L,ND, NRB_CONT, 
+     >                  EXPFAC, WCHARM, MAXION)
 C*******************************************************************************
 C***  RADIATIVE RATE COEFFICIENT MATRIX RRATE IS CALCULATED AT DEPTH POINT L
 C***  FROM THE GIVEN RADIATION FIELD
@@ -16,12 +16,11 @@
 C*******************************************************************************
 
 C***  Dimension of the core-charge data locally provided here
-      PARAMETER ( MAXATOMDIM = 26)
+      PARAMETER ( MAXATOMDIM = 30)
       
 c      character*10 level(n) 
       DIMENSION KODAT(MAXATOM)
-      DIMENSION SIGMATHK(MAXATOM,MAXATOM),SEXPOK(MAXATOM,MAXATOM)
-      DIMENSION EDGEK(MAXATOM,MAXATOM)
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
       DIMENSION NFIRST(NATOM),NLAST(NATOM)
       DIMENSION RRATE(NDIM,NDIM),EINST(NDIM,NDIM)
       DIMENSION XJC(NF), XJL(LASTIND)
diff -bur ./readoldt.f ../../powr-refactor/src/readoldt.f
--- ./readoldt.f	2024-07-28 13:14:20.000000000 +0200
+++ ../../powr-refactor/src/readoldt.f	2023-09-27 10:14:15.121755744 +0200
@@ -1,6 +1,6 @@
       SUBROUTINE READOLDT (ICH, ND, NDDIM, T, RADIUS,
      $                     TOLD, ROLD, MODOLD, JOBNOLD, TEFF, TEFFOLD,
-     >                     TAURCONT, TAURCONTOLD, BTAUR, DTDRIN_OLD)
+     >                     TAURCONT, TAURCONTOLD, BTAUR)
 C**********************************************************************
 C***  CALLED FROM: WRSTART
 C***  READS TEMPEREATURE STRUCTURE FROM OLD MODEL FILE, IF REQUESTED
@@ -25,6 +25,10 @@
          ENDIF
       CALL READMS (ICH,JOBNOLD,     1, 'JOBNUM  ' , IERR)
       CALL READMS (ICH,NDOLD  ,     1, 'ND      ' , IERR)
+      CALL READMS (ICH,TEFFOLD,     1, 'TEFF    ' , IERR)
+      CALL READMS (ICH,TOLD   , NDOLD, 'T       ' , IERR)
+      CALL READMS (ICH,ROLD   , NDOLD, 'R       ' , IERR)
+
 C***  ARRAY BOUND CHECK
       IF (NDOLD .GT. NDDIM) THEN
          CALL REMARK (' OLD MODEL HAS TOO MANY DEPTH POINTS')
@@ -32,10 +36,7 @@
          STOP 'ERROR'
       ENDIF
 
-      CALL READMS (ICH,TEFFOLD,     1, 'TEFF    ' , IERR)
-      CALL READMS (ICH,TOLD   , NDOLD, 'T       ' , IERR)
-      CALL READMS (ICH,ROLD   , NDOLD, 'R       ' , IERR)
-
+C***  OLD T TAU: CHECK IF TAURCONT IS ON MODEL OR FALLBACK NEEDED
       IF (BTAUR) THEN
          CALL READMS (ICH,TAURCONTOLD, NDOLD, 'TAURCONT' , IERR)
          IF (IERR .EQ. -10) THEN
@@ -51,17 +52,14 @@
          ENDIF
       ENDIF
 
-      CALL READMS (ICH,DTDRIN_OLD,1,   'DTDRIN  ' , IERR)
-      ! DTDRIN_OLD only used if OLD T + OLD STRAT/V is set
-
       CALL CLOSMS (ICH, IERR)
 
 
 C***  INTERPOLATION ***************************************************
-      BTAUR_INTERPO = BTAUR_INTERPO .AND. (TAURCONT(ND) .NE. 0.)
+cc      BTAUR_INTERPO = BTAUR_INTERPO .AND. (TAURCONT(ND) .NE. 0.)
+      BTAUR_INTERPO = BTAUR_INTERPO .AND. (TAURCONT(ND) > 0.)
 
       IF (BTAUR_INTERPO) THEN
-
          WRITE (0,*) 'Interpolation of Temperature on Tau-Grid'
 
 cC***     scale TAUROLD
@@ -99,9 +97,12 @@
       IF (TEFF .NE. TEFFOLD) THEN
          Q = TEFF / TEFFOLD
          DO L=1, ND
-         FTAU = EXP(-TAURCONT(L)*2.)
-C         FTAU = 1.-MIN(TAURCONT(L), 1.)
-         T(L) = T(L) * (FTAU + (1.-FTAU) * Q)
+C***  NOTE: THIS DOES NO LONGER GUARANTEE TMIN
+C***        and can lead to non-monotonic situations
+c           FTAU = EXP(-TAUROSS(L)*2.)
+C           FTAU = 1.-MIN(TAUROSS(L), 1.)
+c           T(L) = T(L) * (FTAU + (1.-FTAU) * Q)
+           T(L) = T(L) * Q
          ENDDO
       ENDIF
 
diff -bur ./regridoldpop.f ../../powr-refactor/src/regridoldpop.f
--- ./regridoldpop.f	2024-07-28 13:14:20.000000000 +0200
+++ ../../powr-refactor/src/regridoldpop.f	2023-09-27 10:14:15.121755744 +0200
@@ -4,7 +4,7 @@
      >                        RNE, RNEorg, ABXYZ, NFIRST, NLAST, 
      >                        NATOM, WEIGHT, NCHARG, EION, ELEVEL, NOM, 
      >                        TAUROSScont, TAUSCALorg,
-     >                        ENLTE, DEPARTNDorg, bUseENTOT)
+     >                        ENLTE, DEPARTNDorg, bUseENTOT, bKeepTTAU)
 C***********************************************************************      
 C***  Adjusts old population numbers (i.e. POP1, etc. from older 
 C***  STEAL jobs) to a new stratification (R, V)
@@ -24,11 +24,12 @@
       
       INTEGER, INTENT(IN) :: ND, N, NATOM
       REAL, INTENT(IN) :: POPMIN, TAUTHICK
-      LOGICAL, INTENT(IN) :: bNoRGrid, bUseENTOT
+      LOGICAL, INTENT(IN) :: bNoRGrid, bUseENTOT, bKeepTTAU
       
-      REAL, DIMENSION(ND), INTENT(IN) :: RNEorg, RNE, ENTOT, ENTOTorg, 
+      REAL, DIMENSION(ND), INTENT(IN) :: RNEorg, ENTOT, ENTOTorg, 
      >                                   RADIUSorg, RADIUS, T, Told,
      >                                   TAUROSScont, TAUSCALorg
+      REAL, DIMENSION(ND), INTENT(INOUT) :: RNE
       REAL, DIMENSION(N), INTENT(IN) :: WEIGHT, ELEVEL, EION
       REAL, DIMENSION(NATOM) :: ABXYZ
 
@@ -42,10 +43,12 @@
       INTEGER :: L, J
       
       CALL BACKUPPOPNUM(ND, N, POPNUM, SCRATCH)      
-      IF (.NOT. bNoRGrid) THEN
+      IF ((.NOT. bNoRGrid) .OR. bUseENTOT) THEN
         CALL INTERPOLATEPOPNUM(POPNUM, SCRATCH, POPMIN,
      >                         RADIUS, RADIUSorg, ENTOT, ENTOTorg,
-     >                         N, ND, ABXYZ, NFIRST, NLAST, NATOM,
+     >                         RNE, RNEorg, T, Told, N, ND,
+     >                         ABXYZ, NFIRST, NLAST, NATOM,
+     >                         NCHARG, WEIGHT, EION, ELEVEL, NOM,
      >                         bUseENTOT)
       ENDIF     
 C***  Calculate departure coefficients for the innermost
@@ -58,6 +61,7 @@
         DEPARTNDorg(J) = SCRATCH(ND,J)/ENLTE(J)
       ENDDO      
       DO L=1, ND        
+        IF (.NOT. bKeepTTAU) EXIT
         IF (TAUROSScont(L) < TAUTHICK) CYCLE
         IF (TAUROSScont(L) <= TAUSCALorg(ND)) THEN
           DO J=1, ND
@@ -76,5 +80,7 @@
         ENDIF        
       ENDDO      
       
+      CALL POP_RENORM(POPNUM, ND, N, NATOM, NFIRST, NLAST, ABXYZ)
+      
       RETURN
       END
diff -bur ./remoco.f ../../powr-refactor/src/remoco.f
--- ./remoco.f	2024-07-28 13:14:21.000000000 +0200
+++ ../../powr-refactor/src/remoco.f	2023-09-27 10:14:15.121755744 +0200
@@ -1,26 +1,30 @@
       SUBROUTINE REMOCO (ND, NDDIM, RADIUS, ENTOT,T , RNE, NF, NFDIM,
-     $                  XLAMBDA, FWEIGHT, KEY, XJC, 
+     $                  XLAMBDA, FWEIGHT, KEY, XJC, bNoARAD,
      $                  N, POPNUM, RSTAR,
      $                  MODHEAD, LAST, MAXHIST, MODHIST, JOBNUM,
      $                  NOTEMP, TEFF, HEDDI, EDDI, MAXXDAT, XDATA, 
-     >                  DENSCON, FILLFAC, OPARND, ABXYZ, NATOM, 
-     >                  ZERO_RATES, NDIM)
+     >                  DENSCON, FILLFAC, OPARND, 
+     >                  ABXYZ, NATOM, POPMIN, ZERO_RATES, NDIM)
 C*******************************************************************************
 C***  READING THE MODEL FILE FOR MAIN PROGRAM "COMO"
 C*******************************************************************************
  
+      INTEGER, INTENT(IN) :: ND, NDDIM, NF, NFDIM
       DIMENSION XJC(2), KEY(2),HEDDI(2),EDDI(2)
       DIMENSION ABXYZ(NATOM)
       DIMENSION XDATA(MAXXDAT)
-      INTEGER :: ND, NDDIM, NF, NFDIM
-      REAL, DIMENSION(NDDIM) :: RADIUS, ENTOT, T
-      LOGICAL NOTEMP
-      LOGICAL ZERO_RATES (NDIM*NDDIM)
+      INTEGER :: LAST
+      REAL, DIMENSION(NDDIM) :: RADIUS, ENTOT, T, ARAD
+      LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES
+      LOGICAL :: NOTEMP, bNoARAD
+      
+      REAL :: POPMIN
+      
 C*** tiefenabh. clumping nach goetz
-      DIMENSION DENSCON(NDDIM),FILLFAC(NDDIM)
+      REAL, DIMENSION(ND) :: DENSCON, FILLFAC
 
 C *** NOTE: ASSURE 64-BIT TYPE FOR USE IN WRITMS
-      CHARACTER NAME*8   
+      CHARACTER(8) :: NAME
 
       CALL OPENMS (3, IDUMMY, IDUMMY, 1, IERR)
       CALL READMS (3,ND,1,      'ND      ', IERR)
@@ -46,6 +50,9 @@
             FILLFAC(L) = 1. / DENSCON(L)
          ENDIF
       ENDDO
+c      CALL READMS (3,DENSCON,ND, 'DENSCON ', IERR)
+c      IF (IERR .EQ. -10) DENSCON(1:ND) = 1.
+c      FILLFAC(1:ND) = 1. / DENSCON(1:ND)
       CALL READMS (3,T,ND,      'T       ', IERR)
       CALL READMS (3,RNE,ND,    'RNE     ', IERR)
       CALL READMS (3,NF,1,      'NF      ', IERR)
@@ -57,8 +64,19 @@
       CALL READMS (3,FWEIGHT,NF,'FWEIGHT ', IERR)
       CALL READMS (3,KEY,NF,    'KEY     ', IERR)
       CALL READMS (3,POPNUM,ND*N,'POPNUM  ', IERR)
+      CALL READMS (3,POPMIN,1,   'POPMIN  ', IERR)
+      IF (IERR < 0) THEN
+C***  POPMIN not on MODEL file => read from CARDS      
+        POPMIN = 1.E-100
+      ENDIF
       CALL READMS (3,RSTAR,1,   'RSTAR   ', IERR)
 
+      CALL READMS (3,ARAD,ND-1, 'ARAD    ', IERR)
+      IF (IERR == -10) THEN
+        bNoARAD = .TRUE.
+      ELSE 
+        bNoARAD = .FALSE.
+      ENDIF
 
 C***  READ 'XDATA' AND CHECK WHETHER THE RECORD EXISTS
       IERR=1
diff -bur ./remost.f ../../powr-refactor/src/remost.f
--- ./remost.f	2024-07-28 13:14:21.000000000 +0200
+++ ../../powr-refactor/src/remost.f	2023-09-27 10:14:15.121755744 +0200
@@ -7,34 +7,40 @@
      >                 GLOG, GEFFLOG, bFixGEFF, GEDD, bGEddFix, 
      >                 ENTOTDENS, XMDOT, Rcritical, GEDDRAD,
      >                 XMSTAR, NAUTO, DRXJL, MAXXDAT,XDATA, 
-     >                 HTOTL, BHTOTERR, HTOTND, DTDRIN,
+     >                 HTOTL, BHTOTERR, HTOTND, HTOTCUT, DTDRIN,
      >                 DENSCON, FILLFAC, 
      >                 LASTFE, ARAD, bNoARAD, WFELOW, WFENUP, NCOLIP,
-     >                 FTCOLI, EMCOLI, GAHIST, 
-     >                 MAXGAHIST, MAXIND, MAXINDE, MAXKONT, LASTKON,
-     >                 XJTOTL, XKTOTL, XNTOTL, WJC, GF, OPARND,
+     >                 FTCOLI, EMCOLI, ARADELEM, ACONTELEM, 
+     >                 MAXION, ARADION, ACONTION,
+     >                 GAHIST, MAXGAHIST, MAXIND, MAXINDE, MAXKONT, 
+     >                 LASTKON, XJTOTL, XKTOTL, XNTOTL, WJC, GF, OPARND,
      >                 OPASMEAN, OPASMEANTC, QFJMEAN, OPAJMEAN, SMEAN,
-     >                 OPAJMEANTC, OPAPMEAN, QOPAHMEAN, EDDIHOUTJMEAN, 
-     >                 XLAMBDA2, NF2, HTOTOUTMINUS, 
+     >                 OPAJMEANTC, OPAPMEAN, QOPAHMEAN,
+     >                 EDDIHOUTJMEAN, HMEAN, XLAMBDA2, NF2,
+     >                 HTOTOUTMINUS, HTOTMINUSND, HTOTNDCOR, 
      >                 FF_INFO, IFF_DK, IFF_MAX_MS, IFF_N_MS, 
      >                 OPALAMBDAMEAN, TAUROSS, TAUROSScont, VMIN, N, 
      >                 POPNUM, SIGMAKI, ATMASS, ACONT, ATHOM, OPAROSS,
-     >                 RHO, XMU, ALPHAF, NEXTHYDRO, LASTHYDRO, VTURB,
-     >              GRSTATIC, LASTBACKUP, LASTTAU, GEFFKEY, ZERO_RATES)  
+     >                 RHO, XMU, ALPHAF, ARMDRESP, HYDROF, NEXTHYDRO,
+     >                 LASTHYDRO, VTURB, VMIC, POPMIN, ZERO_RATES,
+     >                 GRSTATIC, GRDYN, LASTBACKUP, LASTTAU, GEFFKEY,
+     >                 XLAMAPPMEAN, XLAMAPPUMEAN, XLAMAPPLMEAN,
+     >                 iALOentry, bHDNoAG, CORDELTAHDLAST, TAUHDRAW)  
 C*******************************************************************************
 C***  READING THE MODEL FILE FOR MAIN PROGRAM "STEAL"
 C*******************************************************************************
  
-ccc      IMPLICIT NONE
+      IMPLICIT NONE
 
       INTEGER, PARAMETER :: TINYINT = SELECTED_INT_KIND(2)
 
       INTEGER :: ND, NDDIM, NP, NPDIM, NF, NFDIM, N, NDDENSCON,
      >           JOBNUM, NF2, NCOLIP, MAXHIST, LAST, MAXINDE,
-     >           IND, NUP, INDNUP, LOW, INDLOW, INDFE, LASTFE,
+     >           IND, NUP, LOW, INDFE, LASTFE,
      >           LASTIND, MAXXDAT, NATOM, NDIM, MAXAUTO, NAUTO,
      >           INDDR, IFF_N_MS, IFF_MAX_MS, MAXGAHIST, MAXIND,
-     >           MAXKONT, LASTKON, KON, LASTBACKUP, LASTTAU
+     >           MAXKONT, LASTKON, KON, LASTBACKUP, LASTTAU, NDVT,
+     >           LASTHYDGA, MAXION, iALOentry
  
       REAL, DIMENSION(NDDIM), INTENT(OUT) :: RNE
       CHARACTER(8), DIMENSION(NDDIM) :: INCRIT, VCRIT
@@ -42,41 +48,48 @@
       REAL, DIMENSION(NDIM,NDIM) :: EINST
       REAL, DIMENSION(NFDIM,MAXKONT) :: SIGMAKI
       REAL, DIMENSION(NATOM) :: ABXYZ, ATMASS
+      REAL, DIMENSION(NATOM*NDDIM) :: ARADELEM, ACONTELEM
+      REAL, DIMENSION(NDDIM*NATOM*MAXION) :: ARADION, ACONTION
       REAL, DIMENSION(MAXXDAT) :: XDATA
-      DIMENSION INDNUP(LASTIND),INDLOW(LASTIND)
-      REAL, DIMENSION(ND) :: HTOTL, ENTOT, ENTOTDENS, ARAD,
+      INTEGER, DIMENSION(LASTIND) :: INDNUP, INDLOW
+      REAL, DIMENSION(NDDIM) :: HTOTL, ENTOT, ENTOTDENS, ARAD,
      >                       XJTOTL, XKTOTL, XNTOTL, SMEAN,
      >                       RADIUS, VELO, GRADI, T, FTCOLI,
      >                       OPASMEAN, OPASMEANTC, QFJMEAN,
-     >                       OPAJMEAN, OPAJMEANTC, OPAPMEAN, 
-     >                       QOPAHMEAN, OPALAMBDAMEAN, OPAROSS, 
-     >                       GRSTATIC
+     >                          OPAJMEAN, OPAJMEANTC, HMEAN,
+     >                          QOPAHMEAN, QOPAHMEANL, OPAPMEAN,
+     >                          OPALAMBDAMEAN, OPAROSS, VTURB,
+     >                          GRSTATIC, GRDYN, HYDROF, VMIC,
+     >                          HTOTCUT
       REAL, DIMENSION(NF) :: EMCOLI, EMFLUX, FWEIGHT
       REAL, DIMENSION(NDDIM * MAXIND) :: WFELOW, WFENUP
-      REAL, DIMENSION(NDDIM * MAXINDE) :: XJL
+      REAL, DIMENSION(NDDIM * MAXINDE) :: XJL, XLAMAPPMEAN,
+     >                                    XLAMAPPUMEAN, XLAMAPPLMEAN
       REAL, DIMENSION(NDDIM * NFDIM) :: XJC, WJC
       REAL, DIMENSION(26,MAXGAHIST) :: GAHIST
+      LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES
       LOGICAL, DIMENSION(MAXAUTO) :: DRXJL
-      LOGICAL :: STHLP, BHTOTERR, bGEddFix, bFixGEFF, bNoARAD
+      LOGICAL :: STHLP, BHTOTERR, bGEddFix, bFixGEFF, 
+     >           bNoARAD, bHDNoAG, bSMOCO, bNoALOfile
       REAL, DIMENSION(10) :: FF_INFO
       INTEGER (KIND=TINYINT), DIMENSION(IFF_MAX_MS) :: IFF_DK
       CHARACTER(8*MAXHIST) :: MODHIST
 
-      INTEGER :: I, J, K, L, IERR, IDUMMY, NA
+      INTEGER :: I, J, K, L, IERR, IDUMMY, NA, LARM,
+     >           LASTINDAUTO, LASTINDALL
       REAL, INTENT(OUT) :: GF, RSTAR, VDOP, XLAMBDA, XLAMBDA2, GEDD,
-     >                     TEFF, XMDOT, Rcritical
+     >                     TEFF, XMDOT, Rcritical, TAUHDRAW
       REAL, INTENT(INOUT) :: GLOG, GEFFLOG, VMIN, RCON, XMSTAR
-      REAL :: ATMEAN, OPARND, EDDIHOUTJMEAN, HTOTOUTMINUS, 
-     >        TOTIN, TOTOUT, FM, RSTARSU, GEDDRAD,
+      REAL :: ATMEAN, OPARND, EDDIHOUTJMEAN, HTOTOUTMINUS, HTOTMINUSND,
+     >        HTOTND, TOTIN, TOTOUT, FM, RSTARSU, GEDDRAD, HTOTNDCOR,
      >        VFINAL, VMINorg, BETA, VPAR1, VPAR2, RCONorg, HSCALE, 
-     >        BETA2, BETA2FRACTION, VPAR1_2, VPAR2_2, VTURB,
-     >        HTOTND, DTDRIN
+     >        BETA2, BETA2FRACTION, VPAR1_2, VPAR2_2, POPMIN, 
+     >        VCON, VOFF, DTDRIN, UNDEFINIT, CORDELTAHDLAST
 
       REAL, DIMENSION(NDDIM), INTENT(INOUT) :: TAUROSS, TAUROSScont
       REAL, DIMENSION(NPDIM) :: P
       REAL, DIMENSION(NDDIM,NPDIM) :: Z
       REAL, DIMENSION(NDDIM, NDIM) :: POPNUM
-      LOGICAL ZERO_RATES (NDIM*NDDIM)
 
       !Transfer RCON from MODEL file to routines needing the velocity field parameters (e.g. PLOTV)
       COMMON /VELPAR/ VFINAL,VMINorg,BETA,VPAR1,VPAR2,RCONorg,HSCALE,
@@ -84,7 +97,7 @@
 
 C***  hydro stuff
       REAL, DIMENSION(NDDIM-1) :: ATHOM, ACONT
-      REAL, DIMENSION(NDDIM) :: RHO, ALPHAF, XMU
+      REAL, DIMENSION(NDDIM) :: RHO, ALPHAF, ARMDRESP, XMU
       INTEGER, INTENT(OUT) :: NEXTHYDRO, LASTHYDRO
 
       CHARACTER(8) :: NAME, GEFFKEY
@@ -103,6 +116,14 @@
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
+      INTEGER, PARAMETER :: hALO  = 23      !integer handle of the ALO file
+
+
+      LASTINDAUTO = LASTIND + NAUTO
+      LASTINDALL  = LASTIND + NAUTO + LASTFE
+
+      bNoALOfile = .FALSE.
+      iALOentry = 1
 
 C***  Preset VMIN (if none read)
       VMIN = -1.0
@@ -118,6 +139,12 @@
 C***  Preset GF
       GF = 0.
 
+      CALL OPENEXMS (hALO, IDUMMY, IDUMMY, 'ALO', 'UNKNOWN', IERR)
+      IF (IERR .EQ. -10) THEN
+        bNoALOfile = .TRUE.
+        iALOentry = 0
+      ENDIF
+
       CALL OPENMS(3, IDUMMY, IDUMMY, 1, IERR)
       CALL READMS(3,ND,1,       'ND      ', IERR)
       IF(ND > NDDIM) THEN
@@ -186,6 +213,13 @@
       ELSE 
         bNoARAD = .FALSE.
       ENDIF
+      LARM = NATOM * (ND-1)
+      CALL READMS (3,ARADELEM, LARM, 'ARADELEM', IERR)
+      CALL READMS (3,ACONTELEM,LARM, 'ACNTELEM', IERR)
+      LARM = (ND-1) * NATOM * MAXION
+      CALL READMS (3,ARADION , LARM, 'ARADION ', IERR)
+      CALL READMS (3,ACONTION, LARM, 'ACONTION', IERR)
+      
       CALL READMS (3,FTCOLI,ND, 'FTCOLI  ', IERR)
       CALL READMS (3,OPAROSS,ND,'OPAROSS ', IERR)
       CALL READMS (3,TAUROSS,ND,'TAUROSS ', IERR)
@@ -221,7 +255,7 @@
       
       CALL READMS (3,POPNUM,ND*N,'POPNUM  ', IERR)
       IERR=1
-      CALL READMS (3,SIGMAKI,NF*LASTKON, 'SIGMAKI ', IERR)
+*      CALL READMS (3,SIGMAKI,NF*LASTKON, 'SIGMAKI ', IERR)
       IF (IERR == -10) THEN
         DO K=1, NF
           DO KON=1, LASTKON
@@ -229,6 +263,11 @@
           ENDDO
         ENDDO
       ENDIF
+      CALL READMS (3,POPMIN,1,   'POPMIN  ', IERR)
+      IF (IERR < 0) THEN
+C***  Mark if POPMIN not on MODEL file 
+        POPMIN = 1.E-100
+      ENDIF
 
 C***  Read opacity at inner boundary from MODEL file
 C**   (After the first COLI, this is the full Rosseland opacity incl. lines)
@@ -283,7 +322,8 @@
       CALL READMS(3,FWEIGHT,NF,'FWEIGHT ', IERR)
       CALL READMS (3,KEY,NF,   'KEY     ', IERR)
       CALL READMS (3,TOTOUT, 1,'TOTOUT  ', IERR)
-      IF (TOTOUT .NE. -999. ) THEN
+      UNDEFINIT = TRANSFER('UNDEF.   ', TOTOUT)
+      IF (TOTOUT .NE. UNDEFINIT) THEN
             CALL READMS (3,TOTIN , 1,'TOTIN   ', IERR)
             CALL READMS (3,EMFLUX,NF,'EMFLUX  ', IERR)
             CALL READMS (3,EMCOLI,NF,'EMCOLI  ', IERR)
@@ -293,11 +333,33 @@
       CALL READMS (3,XMSTAR, 1, 'XMSTAR  ', IERR)
       IF (IERR .EQ. -10) XMSTAR = .0
       CALL READMS (3,VDOP,1,   'VDOP    ', IERR)
-      CALL READMS (3,VTURB,1,  'VTURB   ', IERR)
-      IF (IERR .EQ. -10) VTURB = .0
+
+      
+      CALL READMS (3,VMIC, ND,  'VMIC    ', IERR)
+      IF (IERR == -10) THEN
+        !old MODEL file => only one VTURB value 
+        CALL READMS(3,VTURB(ND),1, 'VTURB   ', IERR)
+        !update MODEL file: add new variable
+        IF (IERR == -10) VTURB(ND) = 0.
+        DO L=1, ND
+          IF (L /= ND) VTURB(L) = VTURB(ND)
+          VMIC(L) = VTURB(L) * SQRT(2.)
+        ENDDO
+        CALL WRITMS(3,VMIC, ND, 'VMIC    ',-1, IDUMMY, IERR)
+      ELSE
+        DO L=1, ND
+          VTURB(L) = VMIC(L) / SQRT(2.)
+        ENDDO
+      ENDIF
 
 C***  Variables for the hydrodynamics branch (Andreas Sander)
 
+      CALL READMS (3,HYDROF,ND,'HYDROF  ', IERR)
+      IF (IERR == -10) THEN
+        DO L=1, ND
+          HYDROF(L) = -99.
+        ENDDO
+      ENDIF
       CALL READMS (3,NEXTHYDRO,1,'NXTHYDRO', IERR)
       !If NXTHYDRO does not exist in the MODEL (=old model)
       ! set value to -1 to deactivate any hydro-related stuff
@@ -310,13 +372,29 @@
       ELSE
         LASTHYDRO = LASTHYDRO + 1
       ENDIF
+      CALL READMS (3,LASTHYDGA,1,'LSTHYDGA', IERR)
+      IF (IERR == -10) THEN
+        bHDNoAG = .FALSE.
+      ELSEIF (LASTHYDGA > 0) THEN
+        bHDNoAG = .FALSE.
+      ELSE
+        bHDNoAG = .TRUE.
+      ENDIF
       CALL READMS (3,ATHOM  ,ND-1, 'ATHOM   ', IERR)
       CALL READMS (3,ACONT  ,ND-1, 'ACONT   ', IERR)
       CALL READMS (3,ALPHAF ,ND  , 'ALPHAF  ', IERR)
       IF ((IERR == -10) .AND. (NEXTHYDRO == 1)) THEN
         !Failsafe if HYDRO calculation would be this turn
         ! but no force multipliers have been calculated so far
-        NEXTHYDRO = 2
+        DO L=1, ND-1
+          ALPHAF(L) = -99.
+        ENDDO
+      ENDIF
+      CALL READMS (3,ARMDRESP, ND, 'ARMDRESP', IERR)
+      IF ((IERR == -10) .AND. (NEXTHYDRO == 1)) THEN
+        DO L=1, ND
+          ARMDRESP(L) = 1.
+        ENDDO
       ENDIF
 C      CALL READMS (3,XMU    ,ND  , 'XMU     ', IERR)      
       !IF XMU does not exist in the MODEL (=old model)
@@ -343,6 +421,10 @@
       IF (IERR == -10) THEN
         Rcritical = -1.
       ENDIF
+      CALL READMS (3, TAUHDRAW, ND, 'TAUHDRAW', IERR)
+      IF (IERR == -10) THEN
+        TAUHDRAW = -99.
+      ENDIF
 
       CALL READMS (3,MODHEAD,13,'MODHEAD ', IERR)
       CALL READMS (3,JOBNUM,1, 'JOBNUM  ', IERR)
@@ -357,7 +439,7 @@
       ENDDO
 
 C***  read all mean intensities 
-      DO IND=1, LASTIND+NAUTO+LASTFE
+      DO IND=1, LASTINDALL
 C***     Different checks apply for XJL presence:
 C***     Normal lines
          IF (IND .LE. LASTIND) THEN 
@@ -376,8 +458,24 @@
          IERR=1
          CALL READMS (3,XJL(1+ND*(IND-1)),ND,NAME, IERR)
 
+C***     ALOs from "XJLAPP COLI" are only calculated for normal lines
+         IF (IND .LE. LASTINDAUTO .AND. (.NOT. bNoALOfile)) THEN
+            WRITE (NAME, '(A3, I5)')   'ALO', IND
+            CALL READMS (hALO,XLAMAPPMEAN(1+ND*(IND-1)),ND,NAME, IERR)
+            IF (IND == 1 .AND. IERR == -10) iALOentry = 0
+            IF (iALOentry > 0) THEN
+              IF (IND == 1) iALOentry = 3
+              WRITE (NAME, '(A3, I5)')   'ALU', IND
+              CALL READMS (hALO,XLAMAPPUMEAN(1+ND*(IND-1)),ND,NAME, IERR)
+              IF (IND == 1 .AND. IERR == -10) iALOentry = 1
+              WRITE (NAME, '(A3, I5)')   'ALL', IND
+              CALL READMS (hALO,XLAMAPPLMEAN(1+ND*(IND-1)),ND,NAME, IERR)
+              IF (IND == 1 .AND. IERR == -10) iALOentry = 1
+            ENDIF
+         ENDIF
+
 C***     Check for DRTRANSITs
-         IF (IND .GT. LASTIND .AND. IND .LE. LASTIND+NAUTO) THEN
+         IF (IND .GT. LASTIND .AND. IND .LE. LASTINDAUTO) THEN
 C***      IF XJL RECORD DID NOT EXIST (IERR=-10), 
 C***      THE LOGICAL DRXJL(INDDR) IS SET TO .FALSE.
 C***      This should only be the case if that transition is rudimental; 
@@ -392,8 +490,8 @@
           ENDIF
          ENDIF
 
-C***     Check if an iron superline is missing (--> ERROR STOP)
-         IF (IND .GT. LASTIND+NAUTO) THEN
+***     Check if an iron superline is missing (--> ERROR STOP)
+         IF (IND .GT. LASTINDAUTO) THEN
             IF ((IERR .LT. 0) .AND. (IERR .NE. -10)) THEN
               CALL REMARK ('ERROR WHEN READING DR-XJL FROM MODEL FILE')
               STOP 'ERROR'
@@ -406,12 +504,12 @@
       ENDDO
  
 C***  IRON: READING WFELOW, WFENUP 
-      DO INDFE=1, LASTFE
-        IND = LASTIND+NAUTO+INDFE
+      DO INDFE=1,LASTFE
+        IND = LASTINDAUTO+INDFE
         WRITE (NAME, '(A3, I4, A1)') 'WFL', INDFE, ' '
-        CALL READMS (3,WFELOW(1+ND*(IND-1)),ND,NAME, IERR)
+        CALL READMS (hALO,WFELOW(1+ND*(IND-1)),ND,NAME, IERR)
         WRITE (NAME, '(A3, I4, A1)') 'WFU', INDFE, ' '
-        CALL READMS (3,WFENUP(1+ND*(IND-1)),ND,NAME, IERR)
+        CALL READMS (hALO,WFENUP(1+ND*(IND-1)),ND,NAME, IERR)
       ENDDO
  
       CALL READMS (3,LAST,1,'MODHIST ', IERR)
@@ -483,6 +581,16 @@
       IF (IERR == -10) THEN
         GRSTATIC = -1.0
       ENDIF
+      CALL READMS (3, GRDYN, ND  , 'GRDYN   ', IERR)
+      IF (IERR == -10) THEN
+        GRDYN = -1.0
+      ENDIF
+      
+      CALL READMS (3,CORDELTAHDLAST, 1, 'CODHDLST', IERR)
+      IF (IERR < 0) THEN
+C***  Mark if CORDELTAHDLAST not on MODEL file
+        CORDELTAHDLAST = -1.
+      ENDIF
       
 C***  TRY TO READ HTOTL ARRAY gives errormessage if there is no HTOTL
       IERR = 0
@@ -491,6 +599,15 @@
       CALL READMS(3,XJTOTL, ND, 'JTOTL   ', IERR)
       CALL READMS(3,XKTOTL, ND, 'KTOTL   ', IERR)
       CALL READMS(3,XNTOTL, ND, 'NTOTL   ', IERR)
+      CALL READMS(3, HTOTMINUSND, 1, 'HTMND   ', IERR)
+      CALL READMS(3, HTOTNDCOR, 1, 'HTNDCOR ', IERR)
+      CALL READMS(3, HMEAN, ND-1, 'HMEAN   ', IERR)
+      CALL READMS(3, HTOTCUT, ND-1, 'HTOTCUT ', IERR)
+      IF (IERR == 10) THEN
+        DO L=1, ND-1
+          HTOTCUT(L) = HMEAN(L)
+        ENDDO
+      ENDIF
 
 C***  Read NCOLIP
       CALL READMS(3, NCOLIP,        1,        'NCOLIP  ', IERR)
diff -bur ./rmodadp.f ../../powr-refactor/src/rmodadp.f
--- ./rmodadp.f	2024-07-28 13:14:22.000000000 +0200
+++ ../../powr-refactor/src/rmodadp.f	2023-09-27 10:14:15.121755744 +0200
@@ -1,7 +1,7 @@
       SUBROUTINE RMODADP (NDDIM, OLDHEAD, N, NOLD, NDIM, 
      >             NATOM, MODHEAD, ND, NDOLD, ABXYZ,LAST,MODHIST,
-     >             RADIUS,ROLD,POPHELP, POPNUM, TAURCONT, 
-     >             TAURCONTOLD, POPLTE, POPLTE_OLD, BTAUR)
+     >             RADIUS,ROLD,POPHELP, POPNUM, TAURCONT, TAURCONTOLD,
+     >             POPLTE, POPLTE_OLD, ENTOT, ENTOTOLD, BTAUR)
 C**********************************************************************
 C***  ... READS OLD AND NEW MODEL DATA FOR PROGRAM 'ADAPTER'
 C***  this routine also interpolates the population numbers 
@@ -9,6 +9,7 @@
 C**********************************************************************
 
       LOGICAL BTAUR
+      REAL, DIMENSION(NDDIM) :: ENTOT, ENTOTOLD
 
 
 C***  READING OF THE OLD MODEL FILE  -----------------------------------
@@ -55,6 +56,8 @@
          ENDIF
       ENDIF
 
+      CALL READMS (9,ENTOTOLD,    NDOLD,   'ENTOT   ', IERR)
+
       CALL CLOSMS (9, IERR)
 
 C***  READING OF THE NEW MODEL FILE  -----------------------------------
@@ -72,7 +75,9 @@
       CALL READMS (3, LAST   , 1    , 'MODHIST ', IERR)
       CALL READMS (3, MODHIST, LAST , 'MODHIST ', IERR)
       CALL READMS (3, RADIUS , ND   , 'R       ', IERR)
-      CALL READMS (3, TAURCONT,ND   , 'TAURCONT', IERR)
+      CALL READMS (3, TAURCONT, ND  , 'TAURCONT', IERR)
+      CALL READMS (3, ENTOT  , ND   , 'ENTOT   ', IERR)
+
 
       RETURN
       END
diff -bur ./rmodcoli.f ../../powr-refactor/src/rmodcoli.f
--- ./rmodcoli.f	2024-07-28 13:14:22.000000000 +0200
+++ ../../powr-refactor/src/rmodcoli.f	2024-07-22 09:27:16.104033925 +0200
@@ -1,13 +1,15 @@
       SUBROUTINE RMODCOLI(RADIUS,ENTOT,RNE,T,VELO,GRADI,XLAMBDA,FWEIGHT,
-     $                   POPNUM,RSTAR,VDOP,MODHEAD,JOBNUM,XJC,
-     $                   P,ND,NDDIM,NF,NFDIM,N,NP,NPDIM,Z,
+     $                   POPNUM,POPMIN,RSTAR,VDOP,MODHEAD,JOBNUM,XJC,
+     $                   P,ND,NDDIM,NF,NFDIM,N,NDIM,NP,NPDIM,Z,
      $                   TEFF,HEDDI,EDDI,MODHIST,MAXHIST, 
      >                   DENSCON, FILLFAC, ABXYZ, NATOM, 
-     >                   NCOLIP, NF2, XLAMBDA2,
+     >                   LASTREDISMODE, NCOLIP, NF2, XLAMBDA2,
      >                   OPARND, EPSGMAX, BEPSGMAXERR, MAXXDAT, XDATA,
-     >                   NEXTHYDRO, ZERO_RATES, NDIM, DTDRIN)
+     >                   XMSTAR, ZERO_RATES, HTOTMINUSND, HTOTNDCOR,
+     >                   HTOTLlast, TAULAST, NEXTHYDRO, DTDRIN,
+     >                   VMIC)
 C*******************************************************************************
-C***  READING OF THE MODEL FILE FOR MAIN PROGRAM "ETL" *************************
+C***  READING OF THE MODEL FILE FOR MAIN PROGRAM "COLI" ************************
 C*******************************************************************************
 
       !IMPLICIT NONE    !not yet possible - more code rework needed
@@ -17,28 +19,35 @@
       INTEGER, INTENT(OUT) :: NCOLIP, NEXTHYDRO
 
       REAL, DIMENSION(NF) :: HEDDI
-      REAL, DIMENSION(2) :: XJC, EDDI
+C*** ISU
+C array size of EDDI and XJC is actually much larger
+C     REAL, DIMENSION(2) :: XJC, EDDI
+      REAL, DIMENSION(NDDIM*NFDIM) :: XJC
+      REAL, DIMENSION(3*NDDIM) :: EDDI
       REAL, DIMENSION(ND) :: EPSGMAX
       REAL, DIMENSION(NATOM) :: ABXYZ
-      REAL, DIMENSION(NDDIM) :: ENTOT
+      REAL, DIMENSION(NDDIM) :: ENTOT, TAULAST, VMIC
       REAL, DIMENSION(MAXXDAT) :: XDATA
+      LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES
+      REAL, DIMENSION(NDDIM*NDIM) :: POPNUM
 
       CHARACTER(MAXHIST*8) :: MODHIST
 
-      REAL, DIMENSION(ND) :: RADIUS, T, VELO, GRADI
+      REAL, DIMENSION(ND) :: RADIUS, T, VELO, GRADI, HTOTLlast
 
+      REAL :: XMSTAR, POPMIN, HTOTMINUSND, HTOTNDCOR, DTDRIN, VTURBND
       LOGICAL :: BEPSGMAXERR
-      LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES 
+
 
 c*** tiefenabh. clumping nach goetz
       REAL, DIMENSION(NDDIM) :: DENSCON, FILLFAC
 
 C *** NOTE: ASSURE 64-BIT TYPE FOR USE IN WRITMS
       CHARACTER(8) :: NAME
+      CHARACTER(4) :: LASTREDISMODE
 
-      REAL :: DTDRIN
-      
-C***  Preset NCOLIP
+C***  Preset LASTREDISMODE and NCOLIP
+      LASTREDISMODE = 'UNKN'
       NCOLIP = 0
 
       CALL OPENMS (3, IDUMMY, IDUMMY, 1, IERR)
@@ -51,9 +60,12 @@
       CALL READMS (3, LAST , 1 , 'MODHIST ', IERR)
       OPARND = 0.       
       CALL READMS (3, OPARND, 1, 'OPARND  ', IERR)
-      IF (IERR .EQ. -10) OPARND = -99.
-
-C***  Read (theoretical) DTDR at inner boundary (calculated in STEAL - TEMPCORR)
+      HTOTMINUSND = 0.
+      CALL READMS(3, HTOTMINUSND, 1, 'HTMND   ', IERR)
+      HTOTNDCOR = 0.
+      CALL READMS(3, HTOTNDCOR  , 1, 'HTNDCOR ', IERR)
+C***  Read (theoretical) DTDR at inner boundary
+C***  (calculated in STEAL->CALCDTDRIN)
       CALL READMS (3, DTDRIN, 1, 'DTDRIN  ', IERR)
       IF (IERR == -10. .OR. DTDRIN < 0.) THEN
 C***    Fallback if not yet calculated or negative gradient
@@ -96,6 +108,9 @@
             FILLFAC(L) = 1. / DENSCON(L)
          ENDIF
       ENDDO
+c      CALL READMS (3, DENSCON, ND,    'DENSCON ', IERR)
+c      IF (IERR .EQ. -10) DENSCON(1:ND) = 1.
+c      FILLFAC(1:ND) = 1. / DENSCON(1:ND)
       CALL READMS (3, RNE    ,  ND , 'RNE     ', IERR)
       CALL READMS (3, T      ,  ND , 'T       ', IERR)
       CALL READMS (3, VELO   ,  ND , 'VELO    ', IERR)
@@ -105,7 +120,13 @@
       CALL READMS (3, XLAMBDA,  NF , 'XLAMBDA ', IERR)
       CALL READMS (3, XLAMBDA2, NF2, 'XLAMBD2 ', IERR)
       CALL READMS (3, FWEIGHT,  NF , 'FWEIGHT ', IERR)
+      CALL READMS (3, HTOTLlast, ND, 'HTOTL   ', IERR)
       CALL READMS (3, POPNUM , ND*N, 'POPNUM  ', IERR)
+      CALL READMS (3, POPMIN ,   1 , 'POPMIN  ', IERR)
+      IF (IERR < 0) THEN
+C***  POPMIN not on MODEL file => read from CARDS
+        POPMIN = 1.E-100
+      ENDIF
       CALL READMS (3, RSTAR  ,   1 , 'RSTAR   ', IERR)
       CALL READMS (3, MODHEAD,  13 , 'MODHEAD ', IERR)
       CALL READMS (3, VDOP   ,   1 , 'VDOP    ', IERR)
@@ -115,6 +136,8 @@
       CALL READMS (3, EPSGMAX, ND-1,    'EPSGMAX ', IERR)
       BEPSGMAXERR = IERR .EQ. -10
 
+      CALL READMS (3, TAULAST,  ND , 'TAUROSS ', IERR)
+
 C***  READ TEFF FROM MODEL FILE 
 C***  -- CAUTION: TEFF RECORD MAY NOT EXIST IN VERY OLD BERLIN MODELS
       IERR=1
@@ -125,6 +148,29 @@
          STOP 'ERROR'
          ENDIF
 
+C***  Flags for the POPMIN levels from STEAL
+      CALL READMS (3,ZERO_RATES,  N*ND, 'ZERO_RAT', IERR)
+C*    Default if variable does not exist yet
+      IF (IERR .EQ. -10) THEN
+        DO I=1, N*ND
+          ZERO_RATES(I) = .FALSE.
+        ENDDO
+      ENDIF
+
+C***  Read (micro-)turbulent velocity
+      CALL READMS (3,VMIC, ND,  'VMIC    ', IERR)
+      IF (IERR == -10) THEN
+C***    old MODEL file => only one VTURB value
+        CALL READMS(3,VTURBND,1, 'VTURB   ', IERR)
+C***    update MODEL file: add new variable
+        IF (IERR == -10) VTURBND = 0.
+        DO L=1, ND
+          VMIC(L) = VTURBND * SQRT(2.)
+        ENDDO
+        CALL WRITMS(3,VMIC, ND, 'VMIC    ',-1, IDUMMY, IERR)
+      ENDIF
+
+
 C***  READ ALL CONTINUUM INTENSITIES
       ND3=3*ND
       DO 15 K=1,NF
@@ -135,12 +181,16 @@
       ELSE
         WRITE (NAME,'(A4,I4)') 'EDDI', K
       ENDIF
+
       CALL READMS (3,EDDI,ND3,NAME, IERR)
 
       HEDDI(K)=EDDI(ND3)
    15 CONTINUE
 
 C***  Read REDISMODE and NCOLIP
+C*** ISU
+C here readms is called with character LASTREDISMODE instead of real X
+      CALL READMS(3, LASTREDISMODE, 1, 'REDISMO ', IERR)
       CALL READMS(3, NCOLIP,        1, 'NCOLIP  ', IERR)
 
 C***  READ 'XDATA' AND CHECK WHETHER THE RECORD EXISTS
@@ -150,16 +200,8 @@
          XDATA(1) = 0.
       ENDIF
 
-C***  Flags for the POPMIN levels
-      CALL READMS (3,ZERO_RATES,  N*ND, 'ZERO_RAT', IERR)
-C*    Default if variable does not exist yet
-      IF (IERR .EQ. -10) THEN
-        DO I=1, N*ND
-         ZERO_RATES(I) = .FALSE.
-        ENDDO
-      ENDIF
-
       !Read hydro stuff
+      CALL READMS (3,XMSTAR,  1, 'XMSTAR  ', IERR)
       CALL READMS (3,NEXTHYDRO,1,'NXTHYDRO', IERR)
       !If NXTHYDRO does not exist in the MODEL (=old model)
       ! set value to -1 to deactivate any hydro-related stuff
diff -bur ./rmodcon.f ../../powr-refactor/src/rmodcon.f
--- ./rmodcon.f	2024-07-28 13:14:22.000000000 +0200
+++ ../../powr-refactor/src/rmodcon.f	2023-09-27 10:14:15.121755744 +0200
@@ -1,25 +1,36 @@
       SUBROUTINE RMODCON (ND,NDDIM,RADIUS,NP,NPDIM,P,Z,ENTOT,T,RNE,NF,
      $             NFDIM,MODHIST,MAXHIST,LAST,ALTESUM,XLAMBDA,
-     $             TEFF,NOTEMP,XJCOLD,HEDDI,EDDI,NCOLIP,
-     $             FWEIGHT,KEY,POPNUM,RSTAR,MODHEAD,JOBNUM,NEXTK,N,
-     $             MAXXDAT,XDATA, DENSCON, FILLFAC, OPARND, ZERO_RATES,
-     >             NDIM)
+     $             TEFF,NOTEMP,XJCOLD,HEDDI,EDDI,NCOLIP,FWEIGHT,
+     $             KEY,POPNUM,RSTAR,MODHEAD,JOBNUM,NEXTK,N,NDIM,
+     $             MAXXDAT,XDATA, DENSCON, FILLFAC, OPARND, 
+     >             POPMIN, ZERO_RATES, bNoARAD, bNoXJC)
 C***********************************************************************
 C***  READING OF THE MODEL FILE, CALLED FROM WRCONT ****************************
 C***********************************************************************
+      INTEGER, INTENT(IN) :: NDDIM, NPDIM, NDIM
+      INTEGER, INTENT(INOUT) :: ND, NP, N
+
       DIMENSION XDATA(MAXXDAT)
       DIMENSION HEDDI(NF)
       DIMENSION XJCOLD(2),EDDI(2)
-      LOGICAL NOTEMP
-      LOGICAL ZERO_RATES (NDIM*NDDIM)
+      REAL, DIMENSION(NDDIM-1) :: ARAD
+
+      REAL, DIMENSION(NDDIM*NDIM) :: POPNUM
+      LOGICAL, DIMENSION(NDIM*NDDIM) :: ZERO_RATES
+      
+      LOGICAL :: NOTEMP, bNoARAD, bNoXJC
+
+      REAL, INTENT(INOUT) :: POPMIN      
 
 c***  tiefenabh. clumping
-      DIMENSION DENSCON(NDDIM),FILLFAC(NDDIM)
+      REAL, DIMENSION(NDDIM) :: DENSCON, FILLFAC
  
 C *** NOTE: ASSURE 64-BIT TYPE FOR USE IN WRITMS
-      CHARACTER NAME*8   
+      CHARACTER(8) :: NAME
+      
+      bNoXJC = .FALSE.
 
-      CALL OPENMSR (3, IDUMMY, IDUMMY, 1, IERR)
+      CALL OPENMS (3, IDUMMY, IDUMMY, 1, IERR)
 C***  IN CASE OF FIRST WRCONT-JOB:  SET OPTION "NOTEMP"
       CALL READMS (3,JOBNUM,1,'JOBNUM  ', IERR)
       JOBNUM=JOBNUM+1
@@ -61,13 +72,12 @@
          XDATA(1) = 0.  
       ENDIF
 
-C***  Flags for the POPMIN levels
-      CALL READMS (3,ZERO_RATES,  N*ND, 'ZERO_RAT', IERR)
-C*    Default if variable does not exist yet
-      IF (IERR .EQ. -10) THEN
-        DO I=1, N*ND
-         ZERO_RATES(I) = .FALSE.
-        ENDDO
+C***  Determine if COLI has already been run (at least once)
+      CALL READMS (3,ARAD,ND-1, 'ARAD    ', IERR)
+      IF (IERR == -10) THEN
+        bNoARAD = .TRUE.
+      ELSE 
+        bNoARAD = .FALSE.
       ENDIF
 
       CALL READMS (3,TEFF,1,'TEFF    ',IERR)
@@ -82,14 +92,32 @@
       CALL READMS (3,FWEIGHT,NF, 'FWEIGHT ', IERR)
       CALL READMS (3,KEY,NF,     'KEY     ', IERR)
       CALL READMS (3,POPNUM,ND*N,'POPNUM  ', IERR)
+      CALL READMS (3,POPMIN,1,   'POPMIN  ', IERR)
+      IF (IERR < 0) THEN
+C***  POPMIN not on MODEL file => read from CARDS      
+        POPMIN = 1.E-100
+      ENDIF
       CALL READMS (3,RSTAR,1,    'RSTAR   ', IERR)
       OPARND = 0.       
       CALL READMS (3, OPARND, 1, 'OPARND  ', IERR)
  
+C***  Flags for the POPMIN levels
+      CALL READMS (3,ZERO_RATES,  N*ND, 'ZERO_RAT', IERR)
+      IF (IERR == -10) THEN
+        DO I=1, N*ND
+          ZERO_RATES(I) = .FALSE.
+        ENDDO
+      ENDIF 
+ 
       ND3=3*ND
       DO 15 K=1,NF
       WRITE (NAME,'(A3,I4,A1)') 'XJC',K, ' '
       CALL READMS (3,XJCOLD(1+ND*(K-1)),ND,NAME, IERR)
+      IF (IERR == -10) THEN
+C***    no XJC on model file
+        bNoXJC = .TRUE.
+        GOTO 15
+      ENDIF
       IF (.NOT. NOTEMP) THEN
         IF (K <= 999) THEN
           WRITE (NAME,'(A4,I3,A1)') 'EDDI',K, ' '
diff -bur ./secondmodel_prep.f ../../powr-refactor/src/secondmodel_prep.f
--- ./secondmodel_prep.f	2024-07-28 13:14:25.000000000 +0200
+++ ../../powr-refactor/src/secondmodel_prep.f	2023-09-27 10:14:15.125755809 +0200
@@ -1,6 +1,6 @@
       SUBROUTINE SECONDMODEL_PREP (ZINTER, NPHI, P, NP, NPDIM, NPHIMAX,
      >     PHIARR, PHIWEIGHT, PHI_VEC, SECONDMODEL_LINE,
-     >     JPFIRST, JPLAST, LPHISTA_ORIG, LPHIEND_ORIG, THETA)
+     >     JPFIRST, JPLAST, LPHISTA_ORIG, LPHIEND_ORIG)
 C******************************************************************
 C***  CALCULATES THE POINTS OF INTERSECTION FOR EITHER:
 C***  - THE CONE geometry:
@@ -16,7 +16,7 @@
 C***  cone, but not wasting points outside
 C******************************************************************
 
-      DIMENSION ZINTER(4, NPDIM, NPHIMAX), P(NP)
+      DIMENSION ZINTER(2, NPDIM, NPHIMAX), P(NP)
       DIMENSION PHIARR(NPHIMAX,NPDIM), PHIWEIGHT(NPHIMAX,NPDIM)
       DIMENSION NPHI(NPDIM)
       DIMENSION PHI_VEC(NPHIMAX)
@@ -39,7 +39,6 @@
       DATA RSPHERE   / -999. /
       DATA DSPHERE   / -999. /
 
-      THETA = .0 ! used for suppressing calc of luminosity_combined
       RMAX = P(NP)
 
 C***  Decode parameters from input line
@@ -137,13 +136,12 @@
             GOTO 99
          ENDIF
 
-         CONEI_MINUS_THETA = CONEI_DEG - THETA_DEG
-         IF (ABS(CONEI_MINUS_THETA) .LT. 0.1) THEN
+         IF (CONEI_DEG - THETA_DEG .LE. .0) THEN
             WRITE (0,'(A, /, A, F6.1, A, F6.1, A)') '***** ERROR: ' //
      >       ' Invalid choice of geometry:', 'THETA=', THETA_DEG,
      >       'deg,  CONE-Inclination=', CONEI_DEG, 'deg'
             WRITE (0,'(A)') '***** ERROR: ' //
-     >       'those two angles must differ by more than 0.1 degree'
+     >       'Cone MUST be seen from the side'
             GOTO 99
          ENDIF
 
@@ -162,13 +160,10 @@
 
 C***  Preparation for the CONE case
       IF (SHAPE .EQ. 'CONE') THEN
-         SINI = SIN (CONEI)
-         COSI = COS (CONEI)
-         COST = COS (THETA)
-         ECC  = COSI / COST
-         ECC2 = ECC * ECC
-         COTMINUS = 1. / TAN (CONEI-THETA)
-         COTPLUS  = 1. / TAN (CONEI+THETA)
+         SINI = SIN(CONEI)
+         COSI = COS(CONEI)
+         COTMINUS = 1. / TAN(CONEI-THETA) 
+         COTPLUS  = 1. / TAN(CONEI+THETA) 
 
 C***  Preparation for the SPHERE case
       ELSEIF (SHAPE .EQ. 'SPHERE') THEN
@@ -183,9 +178,7 @@
       MAXNPHI = 0
       NPHISUM = 0
 
-C***************************************************************
 C***  Loop over impact parameters
-C***************************************************************
       DO JP=1, NP-1
 
 C***     The angle-points will be established
@@ -197,7 +190,7 @@
             GOTO 10
          ENDIF         
 
-C***     Preparation of angle points for JP > 1
+C***  Preparation of angle points
          IF (NPHI(JP) .EQ. 1) THEN
             PHI_VEC(1) = .0
             PHI_VEC(2) = 2.*PI
@@ -207,7 +200,7 @@
 C**     Copy pre-existing phi points (from wind rotation)
             NPHI_JP = NPHI(JP)
             DO LPHI=1, NPHI_JP
-               PHI_VEC(LPHI) = PHIARR(LPHI,JP)
+               PHI_VEC(LPHI) = PHIARR (LPHI,JP)
             ENDDO
 
 C**         mirror the list to the southern hemisphere 
@@ -218,8 +211,8 @@
      >          /, 'NPHIMAX= ', I6)
                STOP '*** FATAL ERROR in subr. SECONDMODEL_PREP'
             ENDIF
-            DO LPHI=1, NPHI_JP - 1
-               PHI_VEC(2 * NPHI_JP-LPHI) = 2. * PI - PHI_VEC(LPHI)
+            DO LPHI=1, NPHI_JP-1         
+               PHI_VEC(2*NPHI_JP-LPHI) = 2.*PI -  PHI_VEC(LPHI)
             ENDDO
             NPHI_JP = 2 * NPHI_JP - 1
          ENDIF
@@ -257,8 +250,8 @@
               STOP '*** FATAL INTERNAL ERROR in subr. SECONDMODEL_PREP'
             ENDIF
 
-            IF (PHI_VEC(LPHI + 1) .LT. PHI_NEXT .OR.
-     >          PHI_NEXT .GE. 2 * PI) THEN
+            IF (PHI_VEC(LPHI+1) .LT. PHI_NEXT .OR.
+     >          PHI_NEXT .GE. 2*PI) THEN
                LPHI = LPHI + 1
                PHI_VEC_TEMP(LPHI_TEMP) = PHI_VEC(LPHI) 
                BPHI_ORIG(LPHI_TEMP) = .TRUE.
@@ -274,61 +267,31 @@
    10    CONTINUE
 C***     Angle points are now in PHI_VEC_TEMP
 
-C***     Rays are limited to the RMAX sphere;
-         ZMAX2 = RMAX2 - P(JP)*P(JP)
-         ZMAX2 = MAX (.0, ZMAX2)
-         ZMAX = SQRT(ZMAX2)
-C***     Core Rays end at the stellar core
-         IF (P(JP) .LT. 1.) THEN
-            ZMIN = SQRT (1. - P(JP)*P(JP))
-         ELSE 
-            ZMIN = -ZMAX
-         ENDIF
-
-C***     Loop over all angle points at current JP to find intersections **
+C********Loop over all angle points at current JP to find intersections **
          DO LPHI_TEMP=1, NPHI_TEMP
             PHI = PHI_VEC_TEMP (LPHI_TEMP)
-            X0  = P(JP) * COS (PHI)
+            X0  = P(JP) * COS(PHI)
             X02 = X0 * X0
-            Y0  = P(JP) * SIN (PHI)
+            Y0  = P(JP) * SIN(PHI)
             Y02 = Y0 * Y0
 
-            Z1 = .0
-            Z2 = .0
-            Z3 = .0
-            Z4 = .0
-
-C*************************************************************
 C***        Intersection points with cone
-C*************************************************************
             IF (SHAPE .EQ. 'CONE') THEN
                ZM = 0.5 * Y0 * (COTPLUS + COTMINUS)
                AAXIS = 0.5 * Y0 * (COTPLUS - COTMINUS)
                AAXIS2 = AAXIS * AAXIS
-
-C***           GEOMETRY OF ELLIPSE
-               IF (CONEI_MINUS_THETA .GT. .0) THEN
-                  BAXIS2 = AAXIS2  - ECC2 * AAXIS2
-                  IF (X02 .LE. BAXIS2) THEN
-                    TERM2 = AAXIS2 - X02/(1. - ECC2)
+              BAXIS2 = (Y02 + ZM**2) * (TAN(THETA))**2
+              IF (X02 .GE. BAXIS2) THEN
+                 Z1 = .0
+                 Z2 = .0
+              ELSE
+                 TERM2 = AAXIS2 * (1- X02/BAXIS2)
                     TERM2 = SQRT(TERM2)
                     Z1 = ZM + TERM2
                     Z2 = ZM - TERM2
                   ENDIF
 
-C***           GEOMETRY OF HYPERBOLA
-               ELSE
-                  TERM3 = AAXIS2 + X02 / (ECC2 - 1.)
-                  TERM3 = SQRT (TERM3)
-                  Z1 = ZMAX
-                  Z2 = ZM + TERM3
-                  Z3 = ZM - TERM3
-                  Z4 = -ZMAX
-               ENDIF
-
-C*************************************************************
 C***        Intersection points with sphere
-C*************************************************************
             ELSEIF (SHAPE .EQ. 'SPHERE') THEN
                XM = DSPHERE * COSD * SINA
                YM = DSPHERE * SIND
@@ -336,55 +299,48 @@
                DX2 = (X0-XM)**2
                DY2 = (Y0-YM)**2
                TERM2 = RSPHERE2 - DX2 - DY2
-
-               IF (TERM2 .GT. .0) THEN
+              IF (TERM2 .LE. .0) THEN
+                 Z1 = .0
+                 Z2 = .0
+              ELSE
                   TERM2 = SQRT(TERM2)
                   Z1 = ZM + TERM2
                   Z2 = ZM - TERM2
                ENDIF
+      
             ELSE
-               STOP '*** Fatal ERROR in SECONDMODEL_PREP: unknown SHAPE'
+              STOP '*** Internal ERROR in SECONDMODEL_PREP: unknown SHAPE'
             ENDIF
 
-C********************************************************************
-C***        All geometries: 
-C**         Clipping the intersection line(s) to (ZMIN,ZMAX) 
-C********************************************************************
-            IF (Z1 .NE. .0 .OR. Z2 .NE. .0) THEN
-C***           First intersection interval entirely outside (ZMIN,ZMAX)
-               IF (Z2 .GE. ZMAX .OR. Z1 .LE. ZMIN) THEN
+C**         Clipping the intersection line at the RMAX sphere
+            ZMAX2 = RMAX2 - X02 - Y02
+            ZMAX2 = MAX (.0, ZMAX2)
+            ZMAX = SQRT (ZMAX2)
+            IF (Z2 .GE. ZMAX .OR. Z1 .LE. -ZMAX) THEN
+C**            Intersection interval is entirely outside RMAX sphere
                   Z1 = .0
                   Z2 = .0
                ELSE
                   Z1 = MIN (Z1, ZMAX)
-                  Z2 = MAX (Z2, ZMIN)
-               ENDIF
+               Z2 = MAX (Z2, -ZMAX)
             ENDIF
-C***        Same for second intersection interval (if existing)
-            IF (Z3 .NE. .0 .OR. Z4 .NE. .0) THEN
-               IF (Z4 .GE. ZMAX .OR. Z3 .LE. ZMIN) THEN
-                  Z3 = .0
-                  Z4 = .0
+
+C**         Core rays:
+            IF (P(JP) .LT. 1.) THEN
+C**            Intersection lines behind the stellar disc are obscured
+               ZMIN = SQRT (1. - P(JP)*P(JP))
+               IF (Z1 .LE. ZMIN) THEN
+                  Z1 = .0
+                  Z2 = .0
                ELSE
-                  Z3 = MIN (Z3, ZMAX)
-                  Z4 = MAX (Z4, ZMIN)
+                  Z2 = ZMIN
                ENDIF
             ENDIF
 
-C**************************************************************
-C***  Calculation and clipping of intersection interval(s) done       
-C**************************************************************
-
-C**************************************************************
-C***  Check if the current angle-point might be skipped 
-C**************************************************************
-
 C***        First angle point is always kept
             IF (LPHI_TEMP .LE. 1) THEN
                ZINTER(1, JP, 1) = Z1
                ZINTER(2, JP, 1) = Z2
-               ZINTER(3, JP, 1) = Z3
-               ZINTER(4, JP, 1) = Z4
                PHIARR(1,JP) = PHI_VEC_TEMP(1)
                LPHI = 1
                BPHI_ORIG_LAST = .TRUE.
@@ -394,22 +350,15 @@
 C***        else overwrite last point
 C***        "original" angle points are also kept and not overwritten
 C***        additionally, first non-intersection points are not overwritten
-              DZ1 = Z2 - Z1
-              DZ2 = Z4 - Z3
-              DZLAST1 = ZINTER(2, JP, LPHI) - ZINTER(1, JP, LPHI)
-              DZLAST2 = ZINTER(4, JP, LPHI) - ZINTER(3, JP, LPHI)
-              IF ((DZ1 .NE. .0) .OR. (DZLAST1 .NE. .0) .OR.
-     >            (DZ2 .NE. .0) .OR. (DZLAST2 .NE. .0) .OR.
-     >             BPHI_ORIG_LAST) LPHI = LPHI + 1
+              DZ = Z2 - Z1
+              DZLAST = ZINTER(2, JP, LPHI) - ZINTER(1, JP, LPHI)
+              IF (DZ .NE. .0 .OR. DZLAST .NE. .0 .OR. BPHI_ORIG_LAST) 
+     >           LPHI = LPHI + 1
               ZINTER(1, JP, LPHI) = Z1
               ZINTER(2, JP, LPHI) = Z2
-              ZINTER(3, JP, LPHI) = Z3
-              ZINTER(4, JP, LPHI) = Z4
               PHIARR(LPHI,JP) = PHI_VEC_TEMP(LPHI_TEMP)
 C**           If last point was inside cone, do not overwrite it
-              BPHI_ORIG_LAST=BPHI_ORIG(LPHI_TEMP).OR.(DZLAST1 .NE. .0)
-     >                      .OR. (DZLAST2 .NE. .0) .OR. (DZ1 .NE. .0)
-     >                      .OR. (DZ2 .NE. .0)
+              BPHI_ORIG_LAST= BPHI_ORIG(LPHI_TEMP) .OR. (DZLAST .NE. .0)
             ENDIF
 
          ENDDO ! phi-loop, index LPHI_TEMP -----------------------------
@@ -430,20 +379,13 @@
          DO LPHI = 1, NPHI(J)
             X0 = P(J)/P(NP) * COS(PHIARR(LPHI,J))
             Y0 = P(J)/P(NP) * SIN(PHIARR(LPHI,J))
-            IF ((ZINTER(1,J,LPHI) .NE. .0) .OR.
-     >          (ZINTER(2,J,LPHI) .NE. .0)) THEN
+            IF (ZINTER(1,J,LPHI) .NE. .0 .OR.
+     >          ZINTER(1,J,LPHI) .NE. .0) THEN
                   WRITE (20, *) X0, Y0, ZINTER(1,J,LPHI)/P(NP)
                   WRITE (20, *) X0, Y0, ZINTER(2,J,LPHI)/P(NP)
                   WRITE (20, *) '   '
                   WRITE (20, *) '   '
             ENDIF
-            IF ((ZINTER(3,J,LPHI) .NE. .0) .OR.
-     >          (ZINTER(4,J,LPHI) .NE. .0)) THEN
-                  WRITE (20, *) X0, Y0, ZINTER(3,J,LPHI)/P(NP)
-                  WRITE (20, *) X0, Y0, ZINTER(4,J,LPHI)/P(NP)
-                  WRITE (20, *) '   '
-                  WRITE (20, *) '   '
-            ENDIF
          ENDDO
       ENDDO
       CLOSE (20)
@@ -492,7 +434,7 @@
              PHIWEIGHT(LPHI,JP) = PHIARR(LPHI+1,JP) - PHIARR(LPHI-1,JP)
            ENDDO
            PHIWEIGHT(NPHI(JP),JP) = PHIARR(NPHI(JP),JP)
-     >                           - PHIARR(NPHI(JP) - 1,JP)
+     >                           - PHIARR(NPHI(JP)-1,JP)
         ENDIF
 
       ENDDO
diff -bur ./seqlinecl.f ../../powr-refactor/src/seqlinecl.f
--- ./seqlinecl.f	2024-07-28 13:14:26.000000000 +0200
+++ ../../powr-refactor/src/seqlinecl.f	2023-11-21 10:10:55.293269795 +0100
@@ -1,7 +1,7 @@
       SUBROUTINE SEQLINECL(NLINE, LINE, EINST, INDLOW, 
-     >             INDNUP, XLAMSOR, ELEVEL,
-     $             NDIM, VDOP, CMFBAND, CLIGHT, XLAMMIN, XLAMMAX,
-     $             VELO, EXLAM1, EXLAM2, MAXEXT, LASTIND, NAUTO, KRUDAUT)
+     >             INDNUP, XLAMSOR, ELEVEL, NDIM, VDOPUNIT,
+     >             CMFBAND, CLIGHT, XLAMMIN, XLAMMAX, VELOMAX,
+     >             EXLAM1, EXLAM2, MAXEXT, LASTIND, NAUTO, KRUDAUT)
 C**********************************************************************
 C***  "SEQUENCE OF LINES"  
 C***  THE LINES ARE SORTED IN THE SEQUENCE OF INCREASING WAVELENGTHS.
@@ -26,7 +26,7 @@
          IF (IND .LE. LASTIND) THEN
             BRUDTEST = (EINST(INDLOW(IND),INDNUP(IND)) .EQ. -2.) 
          ELSE
-            BRUDTEST = (KRUDAUT(IND-LASTIND) .EQ. 1)
+            BRUDTEST = KRUDAUT(IND-LASTIND)
          ENDIF
          IF (BRUDTEST) THEN
             NUMRUD=NUMRUD+1
@@ -56,10 +56,10 @@
       REDBAND = CMFBAND
       XLAMACT = XLAMSOR(NL)
       IF ( (XLAMACT - EXLAM1) * (XLAMACT - EXLAM2) .LT. .0 )
-     >   REDBAND = CMFBAND + 2. * VELO / VDOP
+     >   REDBAND = CMFBAND + 2. * VELOMAX / VDOPUNIT
 
-      XLAMMIN(NL) = XLAMSOR(NL) * (1 - CMFBAND * VDOP / CLIGHT)
-      XLAMMAX(NL) = XLAMSOR(NL) * (1 + REDBAND * VDOP / CLIGHT)
+      XLAMMIN(NL) = XLAMSOR(NL) * (1 - CMFBAND * VDOPUNIT / CLIGHT)
+      XLAMMAX(NL) = XLAMSOR(NL) * (1 + REDBAND * VDOPUNIT / CLIGHT)
 400   CONTINUE
 
       RETURN
diff -bur ./set_momzero.f ../../powr-refactor/src/set_momzero.f
--- ./set_momzero.f	2024-07-28 13:14:26.000000000 +0200
+++ ../../powr-refactor/src/set_momzero.f	2023-11-21 10:10:55.293269795 +0100
@@ -13,6 +13,7 @@
       XKL = 0.
       XNL = 0.
       XHO = 0.
+C***  For special treatment of inner boundary      
       XHI = 0.
       XNO = 0.
       XNI = 0.
diff -bur ./setxjfine.f ../../powr-refactor/src/setxjfine.f
--- ./setxjfine.f	2024-07-28 13:14:28.000000000 +0200
+++ ../../powr-refactor/src/setxjfine.f	2023-09-27 10:14:15.125755809 +0200
@@ -1,8 +1,9 @@
       SUBROUTINE SETXJFINE (SFINE_OLD, SFINE_NEW, MAXFINE, ITNEL, L, 
-     >                 ND, NDDIM, NDIM, N, VDOP, VELO1, 
+     >                 ND, NDDIM, NDIM, N, VDOPUNIT, VELO1, 
      >                 ENTOTL, EN, RSTAR, TL, RNEL, NCHARG, 
      >                 WEIGHT, ELEVEL, EION, EINST, NATOM, 
-     >                 KONTHLP, MAXIND, BXJLAPPCORE,
+     >                 KONTHLP, MAXIND, BXJLAPPCORE, POPMIN, 
+     >                 MAXATOM, KODAT, NOM, VDOPDD, MAXION,
 C***    CONTINUA
      >                 XLAMBDA, XLAMBDA2, NF, NF2, 
      >                 XKC, XKC2, ALPHA, 
@@ -59,6 +60,9 @@
       DIMENSION XLAMBDA(NF), XLAMBDA2(NF2), XKC(NF), XKC2(NF)
       DIMENSION EINST(NDIM,NDIM)
       CHARACTER CMODE*1, NAME*8
+      INTEGER, DIMENSION(MAXATOM) :: KODAT
+      REAL, DIMENSION(ND, NATOM), INTENT(IN) :: VDOPDD
+      INTEGER, DIMENSION(N) :: NOM, NCHARG
 
 C***  Lines: 
       DIMENSION LINE(MAXIND), XLAMSOR(MAXIND)
@@ -72,6 +76,7 @@
       DIMENSION XKRED_CORE(MAXLIN), XKBLUE_CORE(MAXLIN)
       DIMENSION XJLAPP(LASTIND), XJL(ND,2)
       DIMENSION PWEIGHT(MAXLIN), WS(MAXLIN)
+      INTEGER, DIMENSION(NDIM) :: INDRBS, IFRBSSTA, IFRBSEND, INDFESACT
 
 C***  BNEWOPER switches to new Fine Operator: Default is false
       LOGICAL BXJLAPPNEW, BXJCAPPNEW, BNEWOPER, BXJLAPPCORE
@@ -79,6 +84,9 @@
       LOGICAL BLASERL(MAXIND)
       LOGICAL BPLOT, BFIRSTITER
 
+      REAL :: POPMIN
+      INTEGER :: LASTSELF, MAXFESACT
+      
 C***  Variables to handle Fine Integration in Steal
 C***  FF_INFO : Information on the Frequency grid
 C***         (1) : XLAM0
@@ -111,7 +119,7 @@
      >              IFENUP(MAXIND), IFELOW(MAXIND),
      >              OPAFE(NDDIM), ETAFE(NDDIM),
      >              INDFEACT(MAXIND)
-      LOGICAL BFECHECK, BFEWING, BFEMODEL, BNUEFE
+      LOGICAL BFECHECK, BFEWING, BFEMODEL, BNUEFE, bFEULSEP
 
 C***  WPI = SQUARE ROOT OF PI
       DATA WPI / 1.772453851 /
@@ -121,7 +129,7 @@
       DATA WJMAX / 0.9999999999 /
 
 C***  CLIGHT = VELOCITY OF LIGHT IN KM/S
-      DATA CLIGHT /2.99792458E5/
+      DATA CLIGHT /2.9979E5/
 
 
       SAVE XLAM0, XLAM0LN, ALN, CMFBAND, CMFBANDR
@@ -140,6 +148,19 @@
 
       LOGICAL BKACTIVE, B_ACTIVE_CORE
 
+C***  needed for COLI compartibility      
+      REAL, DIMENSION(NDDIM) :: OPAKFE, 
+     >                          OPAKNOFENOTH, ETAKNOFENOTH,
+     >                          OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT
+      REAL, DIMENSION(NATOM, NDDIM) :: OPAKELEM, OPACELEM,
+     >                                 ETACELEM, ETAKELEM
+      REAL, DIMENSION(ND, NATOM, MAXION) :: OPAKION, OPACION,
+     >                                      ETACION, ETAKION
+      REAL, DIMENSION(ND, MAXION) :: OPAFEION, ETAFEION
+     
+      OPAKFE = 0.   
+       
+       
 C***  BNEWINT handles the fine frequency grid. If true, the same grid as in 
 C***    COLI is applied. This is, at least for small Model Atoms, a bit faster
       BNEWINT = .TRUE.
@@ -179,32 +200,29 @@
           ALN   = FF_INFO(2)
         ELSE
           XLAM0 = XLAMBDA(1)
-          ALN   = ALOG(1. + VDOP/CLIGHT*DXMAX)
+          ALN   = ALOG(1. + VDOPUNIT/CLIGHT*DXMAX)
         ENDIF
         XLAM0LN = ALOG(XLAM0)
 C***    Spacing when no lines and no continua are active
 C***    At the moment 500 Lambda-points per decade are default
         KSPACE = INT((LOG(10.)/ALN) / 500.)
+C***    Do not allow for KSPACE > 200
+        KSPACE = MIN(200, KSPACE)
         WRITE (0,'(A,I4)') 'KSPACE=', KSPACE
+        
 C***    Maximum Half-Bandwidth for CMF Line Transfer in Doppler Units
         CMFBAND = 4.5
-        CMFBANDR = CMFBAND + 2.*VELO1/VDOP
+        CMFBANDR = CMFBAND + 2.*VELO1/VDOPUNIT
 C***    No Opacity and Emissivity of Continuum
         OPA = 0.
         ETA = 0.
+
 C***    Reorder lines in sequence of increasing wavelengths
-C***    Next line means: DRLINES included in ALO
-ccc        NLINE_NOFE = LASTIND + NAUTO
         NLINE_NOFE = LASTIND
-
-ccc        write (0,*) 'BEFORE SEQLINE: NLINE_NOFE=', NLINE_NOFE
-
-        CALL SEQLINECL(NLINE_NOFE, LINE, EINST, INDLOW,
+        CALL SEQLINECL(NLINE_NOFE, NUMRUD, LINE, EINST, INDLOW,
      >         INDNUP, XLAMSOR, ELEVEL,
-     $         NDIM, VDOP, CMFBAND, CLIGHT, XLAMMIN, XLAMMAX,
-     $         VELO1, EXLAM1, EXLAM2, MAXEXT, LASTIND, NAUTO, KRUDAUT )
-
-ccc        write (0,*) 'AFTER SEQLINE: NLINE_NOFE=', NLINE_NOFE
+     $         NDIM, VDOPUNIT, CMFBAND, CLIGHT, XLAMMIN, XLAMMAX,
+     $         VELO1, EXLAM1, EXLAM2, MAXEXT, LASTIND, NAUTO, KRUDAUT)
 
 C***    Range of Extended Lines : All
         EXLAM1 = XLAMBDA(1)
@@ -444,7 +462,8 @@
            CALL FECHECK (XLAMK, INDRB, IFRBSTA, IFRBEND, LASTFE,
      >                    CLIGHT, VDOPFE, DXFE, XLAM0FE,
      >                    INDFEACT, MAXFEACT, BFECHECK, BFEWING,
-     >                    DFEINDR)
+     >                    DFEINDR, N, INDFESACT, MAXFESACT,
+     >                    INDRBS, IFRBSSTA, IFRBSEND, LASTSELF)
         ENDIF
 
 c        if (bfecheck) then
@@ -569,7 +588,7 @@
      >                 WEIGHT(LOW(NLNEW)), 
      >                 WEIGHT(NUP(NLNEW)), LOW(NLNEW), NUP(NLNEW), 1, 
      >                 XLAMSOR(LINECHECK), ENTOTL, EN, RSTAR, 
-     >                 OPAL(NLNEW), ETAL(NLNEW), VDOP)
+     >                 OPAL(NLNEW), ETAL(NLNEW), VDOPUNIT, POPMIN)
                 IF (BPLOT .AND. L .EQ. IPLOT .AND. 
      >              ITNEL .EQ. IPLOT_ITER) THEN
                   WRITE (38,'(A,F9.2,1X,F3.0,1X,A,I4,1X,I4,F11.3)') 
@@ -746,30 +765,35 @@
      >                    IFRBSTA, IFRBEND, IFENUP, IFELOW,
      >                    VDOPFE, DXFE, XLAM0FE,
      >                    ELEVEL, WEIGHT, RSTAR, EN, ENTOTL, TL,
-     >                    BNUEFE)
+     >                    BNUEFE, POPMIN)
         ENDIF
 
 C***  Calculate frequency Step in X
 C        DELTAX = FLOAT(K-KLAST) * DXMAX
         NDK = K - KLAST
         IF (NDK .NE. 1) THEN
-           DELTAX = (EXP(FLOAT(NDK)*ALN) - 1.)*CLIGHT/VDOP
+           DELTAX = (EXP(FLOAT(NDK)*ALN) - 1.)*CLIGHT/VDOPUNIT
         ELSE
            DELTAX = DXMAX
         ENDIF
 
         FWEIGHTOLD = FWEIGHTL
-        FWEIGHTL = DELTAX * VDOP * 1.E13 / XLAMK
+        FWEIGHTL = DELTAX * VDOPUNIT * 1.E13 / XLAMK
 
 C***  Sum up Opacities
         PARALAS = 0.01
+        LASERV = 2
         CALL ADDOPA (1, 1, MAXLIN, MAXIND, LIND, LINDS,
-     >         XK, XKMID, XKRED, DELTAX,
-     >         PARALAS, LASER,
+     >             XK, XKMID, XKRED, DELTAX, FWEIGHTL,
+     >             PARALAS, LASER, LASERV, ALN, VDOPUNIT, VDOPDD,
      >         WS, ETAL, OPAL, ETA, ETANOTH, OPA, ETAK, ETAKNOTH,
-     >         OPAK, OPAKNOTH, THOMSON,
-     >         PWEIGHT, OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW,
-     >         LEVEL)
+     >             OPAK, OPAKNOTH, THOMSON, PWEIGHT, NOM,
+     >             OPAFE, ETAFE, BFECHECK, BLASERL, NUP, LOW, N, LEVEL,
+     >             OPAKFE, NATOM, MAXATOM, KODAT, OPACELEM, OPAKELEM,
+     >             ETACELEM, ETAKELEM, MAXION, OPACION, OPAKION, 
+     >             ETACION, ETAKION, NCHARG, OPAFEION, ETAFEION, 
+     >             OPAKNOFENOTH, ETAKNOFENOTH,
+     >             OPAFEFT, ETAFEFT, OPAKFEFT, ETAKFEFT)
 
         IF (ETAKNOTH .LT. 0.) THEN
           ETAKNOTH = 0.
@@ -822,17 +846,22 @@
                 CYCLE
               ENDIF
               IF (BNEWINT .AND. BNEWOPER) THEN
-                XREL = DXMAX * (XKMID(LACTS) - FLOAT(K))
+!                 XREL = DXMAX * (XKMID(LACTS) - FLOAT(K))
+!                 PHIL = EXP(-XREL * XREL) / WPI
+!                 XJLAPP(LACT) = XJLAPP(LACT) + DS_WCHARM * PHIL * DXMAX
+                XREL = DELTAX * (XKMID(LACTS) - FLOAT(K))
                 PHIL = EXP(-XREL * XREL) / WPI
-                XJLAPP(LACT) = XJLAPP(LACT) + DS_WCHARM * PHIL * DXMAX
+                XJLAPP(LACT) = XJLAPP(LACT) + DS_WCHARM * PHIL * DELTAX
               ELSE
                 DKLEFT  = AMAX1(XKBLUE_CORE(NL), FLOAT(K-1))
                 DKRIGHT = AMIN1(XKRED_CORE(NL),  FLOAT(K+1))
                 DK = 0.5 * AMAX1(0., DKRIGHT-DKLEFT)
                 IF (DK .EQ. 0.) CYCLE
-                XREL = DXMAX * (XKMID(LACTS) - FLOAT(K))
+c                XREL = DXMAX * (XKMID(LACTS) - FLOAT(K))
+                XREL = DELTAX * (XKMID(LACTS) - FLOAT(K))
                 PHIL = EXP(-XREL * XREL) / WPI
-                XJLAPP(LACT) = XJLAPP(LACT) + DS*PHIL*DK*DXMAX*WCORE
+c                XJLAPP(LACT) = XJLAPP(LACT) + DS*PHIL*DK*DXMAX*WCORE
+                XJLAPP(LACT) = XJLAPP(LACT) + DS*PHIL*DK*DELTAX*WCORE
               ENDIF
 c           if (lact .eq. 2) then
 c             write (0,'(4(F11.5,1x), F8.5, (1x,F11.5), 1x, e20.10, 
diff -bur ./setxjl.f ../../powr-refactor/src/setxjl.f
--- ./setxjl.f	2024-07-28 13:14:28.000000000 +0200
+++ ../../powr-refactor/src/setxjl.f	2023-09-27 10:14:15.125755809 +0200
@@ -1,317 +1,210 @@
-      SUBROUTINE SETXJL (LASTIND,INDLOW,INDNUP,XRED,XBLUE,OPACIND,
-     $   SCNEIND,SCOLIND,SLNEW,SLOLD,OPAL,XJLAPP,
-     $   NF,XLAMBDA,SCNEW,OPAC,OPALOLD,ITNEL,LASTINDAUTO,
-     $   NFL,PHI,PWEIGHT,NDIM,EINST,ELEVEL,EN,WEIGHT,
-     $   ND,XJL,ENTOTL,RSTAR,VDOP,DELTAX,XMAX,L,TL,TLOLD,NOTEMP,
-     $   IBLENDS,MAXLAP,XLAMZERO,BETA,PHIL,FN,NBLENDS,KRUDAUT,MAXAUTO, 
-     >   WFELOW,WFENUP,EN1,BDIAG)
+      SUBROUTINE SETXJL (ITNEL, LASTIND, INDLOW, INDNUP, bUSEALO,
+     >                   SLNEW, SLOLD, OPAL, OPALOLD, XJLAPP, BDIAG,
+     >                   NBLENDS, IBLENDS, MAXLAP, LASTINDAUTO, NDIM,
+     >                   ND, EINST, RUDLINE, ELEVEL, EN, EN1, WEIGHT, 
+     >                   NATOM, XJL, XLAMAPPMEAN, XLAMZERO, RSTAR,
+     >                   XJC, XJCAPP, XLAMBDA, NF, L, TL, TLOLD, 
+     >                   NOTEMP, ENTOTL, VDOPUNIT, KRUDAUT, MAXAUTO,
+     >                   WFELOW, WFENUP, SCNEW, SCOLIND, SCNEIND,
+     >                   POPMIN)
 C***********************************************************************
-C***  CALLED FROM: SUBROUTINE COMA
-C***  CALCULATE LINE RADIATION FIELD WITH APPROXIMATE LAMBDA OPERATOR TERMS
+C***  CALCULATE LINE RADIATION FIELD WITH APPROXIMATE LAMBDA OPERATOR (ALO) TERMS
+C***  USING THE PRECALCULATED LINE OPERATORS CALCULATES IN COLI->FREQUINT
+C***
+C***  ALO is taken from the diagonal elements of the LAMBDA operator,
+C***  see COLI->COLIMO and its subroutine INVTRI
+C***  
 C***  THIS SUBROUTINE ALSO PROVIDES  (BY CALLING LIOP) THE LINE OPACITIES
 C***  AND THE NEW LINE SOURCE FUNCTION
 C***  ATTENTION: XJLAPP AND XJL ARE NOT DEFINED FOR RUDIMENTAL LINES!
 C***          -  OPAL AND SLNEW ARE NOT DEFINED FOR RUDIMENTAL LINES
-C***              AND FOR ZERO SCHARMER CORE (IF NO TEMP. CORRECTIONS)
-C***          - FN USES THE SCRATCH ARRAY ATEST
+C*** 
+C***    EN :  current population numbers for current depth point
+C***    EN1:  old population numbers before current STEAL
+C***
+C***  CALLED FROM: SUBROUTINE COMA
 C***********************************************************************
+      IMPLICIT NONE
  
-      DIMENSION EINST(NDIM,NDIM),ELEVEL(NDIM),EN(NDIM),WEIGHT(NDIM)
-      DIMENSION XJL(ND,2)
-      DIMENSION OPACIND(2),SCNEIND(2),SCOLIND(2),SLNEW(2),SLOLD(2)
-      DIMENSION XLAMBDA(NF),SCNEW(NF),OPAC(NF)
-      DIMENSION PHI(NFL),PWEIGHT(NFL)
-      DIMENSION INDNUP(2),INDLOW(2),XRED(2),XBLUE(2),XJLAPP(2),OPAL(2)
-      DIMENSION IBLENDS(MAXLAP,LASTIND),XLAMZERO(LASTIND)
-      DIMENSION BETA(MAXLAP),PHIL(NFL,MAXLAP),FN(NFL)
-      DIMENSION NBLENDS(LASTIND),OPALOLD(LASTIND),KRUDAUT(MAXAUTO)
-
-      LOGICAL NOTEMP, OLDOPAL
-
-      DIMENSION WFELOW(ND,LASTIND),WFENUP(ND,LASTIND),EN1(1)
-      LOGICAL BDIAG(LASTIND),BNOCORE
-
-C***  WPI = SQUARE ROOT OF PI
-      DATA WPI / 1.772453851 /
-C***  CLIGHT = VELOCITY OF LIGHT IN KM/SEC
-      DATA CLIGHT / 2.99792458E5 /
-
-      OLDOPAL = (L.GT.1) .AND. (ITNEL.EQ.1)
-
-C***  LOOP OVER ALL LINE INDICES TO PREPARE OPACITIES, ETC. ---------
-      DO 1 IND=1,LASTIND
-      IF (XRED(IND) .GE. XBLUE(IND)) THEN
-        BNOCORE=.TRUE.
-      ELSE
-        BNOCORE=.FALSE.
-      ENDIF
+      INTEGER, INTENT(IN) :: L, ND, NF, NDIM, NATOM, ITNEL,
+     >                       LASTIND, LASTINDAUTO, MAXAUTO, MAXLAP
+      REAL, INTENT(IN) :: POPMIN, ENTOTL, RSTAR, VDOPUNIT, TL, TLOLD
+ 
+      REAL, DIMENSION(NDIM) :: ELEVEL, EN, EN1, WEIGHT
+      REAL, DIMENSION(NDIM,NDIM) :: EINST
+      
+      REAL, DIMENSION(ND, LASTINDAUTO) :: XJL, XLAMAPPMEAN
+      REAL, DIMENSION(ND, LASTIND) :: WFELOW, WFENUP
+      REAL, DIMENSION(LASTIND) :: XJLAPP, SLNEW, SLOLD, 
+     >                            SCOLIND, SCNEIND,
+     >                            OPAL, OPALOLD, XLAMZERO
+      INTEGER, DIMENSION(LASTIND) :: INDNUP, INDLOW, NBLENDS
+      INTEGER, DIMENSION(MAXLAP, LASTIND) :: IBLENDS
+      REAL, DIMENSION(NF) :: XJCAPP, XLAMBDA, SCNEW
+      REAL, DIMENSION(ND,NF) :: XJC 
+            
+      INTEGER, DIMENSION(MAXAUTO) :: KRUDAUT
+
+      LOGICAL :: NOTEMP, OLDOPAL, BNOCORE
+      LOGICAL, DIMENSION(LASTIND) :: BDIAG, bUSEALO, RUDLINE
+      
+      REAL, EXTERNAL :: BNUE
+      
+      REAL :: XLAM, WAVENUM, ETAL, DELTASL, DELTASC, DPNUP, DPLOW,
+     >        XJCIND, XJCAPPIND, DELTAXJC, XSHIFT,
+     >        SUMSLNEW, SUMSLOLD, SUMOPALNEW, SUMOPALOLD
+      INTEGER :: IND, NUP, LOW, LB, INDLB, K
+
+C***  Speed of light in km/s      
+      REAL, PARAMETER :: CLIGHTKMS = 2.99792458E5
+
+      
+      
+C***  First iteration for a depth point: SL_new = SL_old => no contribution from ALO 
+      OLDOPAL = (L > 1) .AND. (ITNEL == 1)
 
+C***  Prepare SLNEW(IND) and init XJLAPP for all line indices ----------
+      DO IND=1,LASTIND
       LOW=INDLOW(IND)
       NUP=INDNUP(IND)
 
 C***  FOR RUDIMENTAL LINES: OPAL, SLNEW    NOT DEFINED
-      IF (EINST(LOW,NUP) .EQ. -2.) THEN
-         OPAL(IND)=UNDEF
-         SLNEW(IND)=UNDEF
-         GOTO 1
+        IF (RUDLINE(IND)) THEN
+          OPAL(IND)=5HUNDEF
+          SLNEW(IND)=5HUNDEF
+          CYCLE
       ENDIF
 
-      XJLAPP(IND)=XJL(L,IND)
+        XJLAPP(IND) = XJL(L, IND)
 
-C***  OPAL, ETAL, SLNEW NOT CALCULATED IF ZERO LINE CORE AND "NOTEMP"
-C***  NOTE THAT IRON LINES are always like lines with "core"
-      IF (BNOCORE  .AND.  NOTEMP .AND. .NOT. BDIAG(IND))
-     >    THEN
-         OPAL(IND)=UNDEF
-         SLNEW(IND)=UNDEF
-         GOTO 1
-      ENDIF
-
-      XLAM=XLAMZERO(IND)
+        XLAM = XLAMZERO(IND)
 
       IF (OLDOPAL) THEN
          OPAL(IND) = OPALOLD(IND)
       ELSE
+C***       Call LIOP only for the current depth point
+C***       (i.e. with ND = 1 and all depth-arrays reduced to one REAL variable)        
          CALL LIOP (EINST(NUP,LOW),WEIGHT(LOW),WEIGHT(NUP),LOW,NUP,
-     $         1,XLAM       ,ENTOTL ,EN,RSTAR,OPAL(IND),ETAL,VDOP)
+     >         1,XLAM, ENTOTL, EN,RSTAR,OPAL(IND),ETAL,VDOPUNIT)
+C***       Note: LIOP returns ETAL / DNUEDOP and OPAL / DNUEDOP, but since we
+C***             always build the source function SL = ETAL / OPAL, the 
+C***             VDOP-dependency cancels out (assuming coherent redis.)
       ENDIF
 
 C***  LASER SECURITY
-      IF (OPAL(IND) .LE. .0) THEN
-            SLNEW(IND)=.0
-            XRED(IND)=.0
-            XBLUE(IND)=.0
-            OPAL(IND)=.0
-            GOTO 1
+        IF (OPAL(IND) <= .0) THEN
+            SLNEW(IND) = .0
+            OPAL(IND)  = .0
+            bUSEALO(IND) = .FALSE.
+C***        If we have a LASER siuation, do not use ALO => cycle           
+            CYCLE
             ENDIF
 
       IF (OLDOPAL) THEN
          SLNEW(IND) = SLOLD(IND)
+C***       No ALO contribution => cycle           
+           CYCLE
          ELSE
          SLNEW(IND)=ETAL/OPAL(IND)
          ENDIF
 
-      IF (BNOCORE) GOTO 1
-
-
-C *** OUTPUT WARNING
-C      IF (BDIAG(IND)) 
-C     > write(0,*)'WARNING: Backgroundvalues calculated for Iron'
-  
-C***  BACKGROUND CONTINUUM OPACITY AND SOURCE FUNCTION ARE OBTAINED
-C***  BY INTERPOLATION AT THE LINE FREQUENCIES
-      CALL LIPO (OPACIND(IND),XLAM,OPAC,XLAMBDA,NF)
-      IF (OLDOPAL) THEN
-         SCNEIND(IND) = SCOLIND(IND)
-      ELSE
-         WAVENUM=ELEVEL(NUP)-ELEVEL(LOW)
-         CALL XRUDI (SCNEIND(IND),WAVENUM,SCNEW,XLAMBDA,1,NF,1)
-      ENDIF
-
-   1  CONTINUE
-
-C***  ENDLOOP  FOR PREPARATION -------------------------------------------
+      ENDDO
+C***  End of preparation loop ------------------------------------------
 
+C***  If the line opacities have not changed,
+C***    we do not need the second loop since XJLAPP = XJL
       IF (OLDOPAL) GOTO 102
 
-C***  LOOP OVER ALL LINE INDICES TO CALCULATE XJLAPP ---------
-      DO 101 IND=1,LASTIND
-      IF (XRED(IND) .GE. XBLUE(IND)) THEN
-        BNOCORE=.TRUE.
-      ELSE
-        BNOCORE=.FALSE.
-      ENDIF
-
-      LOW=INDLOW(IND)
-      NUP=INDNUP(IND)
+C***  Second IND loop to fill XJL --------------------------------------
+C***  (double structure required due to blends)        
+      DO IND=1,LASTIND
 
-C**   NO LINE CORE -> XJLAPP = XJL REMAINS UNCHANGED
-C***  IRON: EXCEPT FOR IRON-LINES
-      IF (BNOCORE .AND. .NOT. BDIAG(IND)) GOTO 11
-
-C***  IRON LINES
       IF (BDIAG(IND)) THEN
+C***      IRON LINES
          DPLOW = EN(LOW) - EN1(LOW)
          DPNUP = EN(NUP) - EN1(NUP)
          XJLAPP(IND) = XJL(L, IND) +
      >                  WFELOW(L, IND)*DPLOW + WFENUP(L, IND)*DPNUP
-         GOTO 101
-      ENDIF
-C *** OUTPUT WARNING
-      IF (BDIAG(IND)) 
-     > write(0,*)'WARNING: Iron zu weit'
-
-
-C***  RUDIMENTAL LINES ARE NOT CALCULATED -> XJLAPP IS UNDEFINED
-      IF (EINST(LOW,NUP) .EQ. -2.) GOTO 101
-
-      XLAM=XLAMZERO(IND)
-
-C***  LINE CORE INTEGRAL
-
-C***  CONVERT XRED AND XBLUE TO CORRESPONDING LINE FREQUENCY INDICES
-C***  NOTE THAT THE LINE FREQUENCIES ARE INDEXED IN FALLING SEQUENCE
-      KLMAX=(XMAX-XRED(IND))/DELTAX + 1.
-      KLMIN=(XMAX-XBLUE(IND))/DELTAX + 1.999999999
-      KLA = MAX (KLMIN-1,  1 )
-      KLB = MIN (KLMAX+1, NFL)
-
-C***  DO OLD VERSION, IF CURRENT LINE HAS NO OVERLAPS
-      IF (NBLENDS(IND) .EQ. 1) THEN 
-
-      BETA1 = OPACIND(IND)/OPAL(IND)
-      FCL=.0
-      FCC=.0
-      DO 16 KL=KLMIN, KLMAX
-      P = 1. / (1. + BETA1 / PHI(KL))
-      FCL = FCL+P*PWEIGHT(KL)
-      FCC = FCC+(1.-P)*PWEIGHT(KL)
-   16 CONTINUE
-C***  CORRECT FOR THE INTEGRATION STEP XRED,X(KLMAX)
-      IF (KLMAX .LT. NFL) THEN
-         XKLMAX=XMAX-(KLMAX-1)*DELTAX
-         Q=(XKLMAX-XRED(IND))/DELTAX
-         P=1. / (1. + BETA1 / PHI(KLMAX))
-         FCL=FCL+    P *PWEIGHT(KLMAX)*0.5*(Q-1.)
-         FCC=FCC+(1.-P)*PWEIGHT(KLMAX)*0.5*(Q-1.)
-         P=1. / (1. + BETA1 / PHI(KLMAX+1))
-         FCL=FCL+    P *PWEIGHT(KLMAX+1)*0.5*Q
-         FCC=FCC+(1.-P)*PWEIGHT(KLMAX+1)*0.5*Q
-         ENDIF
-C***  CORRECT FOR THE INTEGRATION STEP X(KLMIN),XBLUE
-      IF (KLMIN .GT. 1) THEN
-         XKLMIN=XMAX-(KLMIN-1)*DELTAX
-         Q=(XBLUE(IND)-XKLMIN)/DELTAX
-         P=1. / (1. + BETA1 / PHI(KLMIN))
-         FCL=FCL+    P *PWEIGHT(KLMIN)*0.5*(Q-1.)
-         FCC=FCC+(1.-P)*PWEIGHT(KLMIN)*0.5*(Q-1.)
-         P=1. / (1. + BETA1 / PHI(KLMIN-1))
-         FCL=FCL+    P *PWEIGHT(KLMIN-1)*0.5*Q
-         FCC=FCC+(1.-P)*PWEIGHT(KLMIN-1)*0.5*Q
-         ENDIF
-      DELTASC=SCNEIND(IND)-SCOLIND(IND)
-      DELTASL=SLNEW(IND)-SLOLD(IND)
-      XJLAPP(IND)=XJLAPP(IND)+FCL*DELTASL+FCC*DELTASC
-
-      ELSE
-
-C***  THIS BRANCH HANDLES OVERLAP TREATMENT ---------------------------------
-
-C***  Prepare FOR ALL OVERLAPPING LINES: 
-C***  - Beta = LINE / CONTINUUM OPACITY (INVERSELY TO PREVIOUS DEFINITION!)
-      DO 210 LB=1, NBLENDS(IND)
-       IND1 = IBLENDS(LB,IND)
-       IF (XRED(IND1) .GE. XBLUE(IND1)) GOTO 210
-       BETA(LB) = OPAL(IND1) / OPACIND(IND)
-C***  - PHIL = DISPLACED PROFILE FUNCTIONS
-      IF (IND .EQ. IND1) THEN
-         DO 250 KL=KLA, KLB
-         PHIL(KL,LB) = PHI(KL)
-  250    CONTINUE
-         ELSE
-C***     SHIFT OF CONSIDERED LINE RELATIVE TO BLENDING LINE, IN DOPPLER UNITS
-         XSHIFT = (XLAMZERO(IND1)/XLAMZERO(IND) - 1. ) * CLIGHT / VDOP
-         DO 220 KL=KLA, KLB
-         XKL = XMAX - (KL-1) * DELTAX
-         XREL = XKL + XSHIFT 
-         PHIL(KL,LB) = EXP(-XREL*XREL) / WPI
-  220    CONTINUE
-         ENDIF
-  210 CONTINUE
+        ELSEIF (bUSEALO(IND)) THEN
+C***      FOR NON-IRON LINES, USE ALO(IND) CALCULATED IN COLI->FREQUINT        
 
-
-C***  STORE FACTOR 1/N  (INTEGRAND IN FCC) 
-C***    N = 1 + SUM OVER (PHI(LB) * BETA(LB)  
-C***    AS FUNCTION OF FREQUENCY
-      DO 230 KL=KLA, KLB
-        FN(KL)=1.
-        DO 240 LB=1, NBLENDS(IND)
-          IND1 = IBLENDS(LB,IND)
-          IF (XRED(IND1) .GE. XBLUE(IND1)) GOTO 240
-          FN(KL) = FN(KL) + PHIL(KL,LB) * BETA(LB)
-  240     CONTINUE
-        FN(KL)=1./FN(KL)
-  230   CONTINUE
-
-
-C***  INTEGRATE COEFFICIENT OF THE CONTINUUM SOURCE FUNCTION--> FCC
-      FCC=0.0
-      DO 26 KL=KLMIN, KLMAX
-      FCC = FCC + FN(KL) * PWEIGHT(KL)
-   26 CONTINUE
-C***  CORRECT FOR THE INTEGRATION STEP XRED,X(KLMAX)
-      IF (KLMAX .LT. NFL) THEN
-         XKLMAX=XMAX-(KLMAX-1)*DELTAX
-         Q=(XKLMAX-XRED(IND))/DELTAX
-         FCC = FCC + FN(KLMAX)   * PWEIGHT(KLMAX)   * 0.5 * (Q-1.)
-     >             + FN(KLMAX+1) * PWEIGHT(KLMAX+1) * 0.5 * Q
-         ENDIF
-C***  CORRECT FOR THE INTEGRATION STEP X(KLMIN),XBLUE
-      IF (KLMIN .GT. 1) THEN
-         XKLMIN=XMAX-(KLMIN-1)*DELTAX
-         Q=(XBLUE(IND)-XKLMIN)/DELTAX
-         FCC=FCC + FN(KLMIN)   * PWEIGHT(KLMIN)   * 0.5 * (Q-1.)
-     >           + FN(KLMIN-1) * PWEIGHT(KLMIN-1) * 0.5 * Q
+          DELTASL = 0.
+          SUMSLNEW = 0.
+          SUMSLOLD = 0.
+          SUMOPALNEW = 0.
+          SUMOPALOLD = 0.
+          DO LB=1, NBLENDS(IND)
+C***        Consider contributions to XJL from all blending lines          
+            INDLB = IBLENDS(LB,IND)
+c            IF (.NOT. bUSEALO(INDLB) .OR. OPALOLD(INDLB) <= 0.) CYCLE
+            IF (OPALOLD(INDLB) <= 0.) CYCLE
+              SUMOPALNEW = SUMOPALNEW + OPAL(INDLB)
+              SUMOPALOLD = SUMOPALOLD + OPALOLD(INDLB)
+              SUMSLOLD = SUMSLOLD + SLOLD(INDLB) * OPALOLD(INDLB)
+              SUMSLNEW = SUMSLNEW + SLNEW(INDLB) * OPAL(INDLB)
+ccc            DELTASL = DELTASL + SLNEW(INDLB) - SLOLD(INDLB)
+c            IF (INDLB /= IND) THEN
+C***          Account for the fact that other line blending into the 
+C***            current IND transition do not have the full contribution
+C***            but are weighted with the contribution of their profile 
+C***            function at the rest wavelength of the considered transition.
+c              XSHIFT = ( XLAMZERO(INDLB)/XLAMZERO(IND)-1. )
+c     >                                         * CLIGHTKMS / VDOPUNIT
+c              DELTASL = DELTASL * EXP(-XSHIFT*XSHIFT)
+c            ENDIF    
+c            XJLAPP(IND) = XJLAPP(IND) + DELTASL * XLAMAPPMEAN(L, INDLB)
+          ENDDO
+          IF (SUMOPALNEW > 0. .AND. SUMOPALOLD > 0.) THEN
+            SUMSLNEW = SUMSLNEW / SUMOPALNEW
+            SUMSLOLD = SUMSLOLD / SUMOPALOLD
+            DELTASL = SUMSLNEW - SUMSLOLD
+            XJLAPP(IND) = XJLAPP(IND) + DELTASL * XLAMAPPMEAN(L, IND)
+          ENDIF
+          
+C***      Consider the change of the continuum contribution
+C***      by interpolating the original and approximated XJC at the 
+C***      wavelength of the current transition
+          WAVENUM = 1.E8 / XLAM
+          CALL XRUDI (XJCIND,    WAVENUM, XJC,    XLAMBDA, ND, NF, L)
+          CALL XRUDI (XJCAPPIND, WAVENUM, XJCAPP, XLAMBDA,  1, NF, 1)
+          DELTAXJC = XJCAPPIND - XJCIND
+          XJLAPP(IND) = XJLAPP(IND) + DELTAXJC
+C***      Alt. approach
+          CALL XRUDI (SCNEIND(IND),WAVENUM,SCNEW,XLAMBDA,1,NF,1)
+c          DELTASC = SCNEIND(IND) - SCOLIND(IND)
+c          XJLAPP(IND) = XJLAPP(IND) + DELTASC * XLAMAPPMEAN(L, IND)
          ENDIF
-      DELTASC = SCNEIND(IND)-SCOLIND(IND)
-      XJLAPP(IND) = XJLAPP(IND) + FCC*DELTASC
 
-C***  INTEGRATE OVER LINES
-      DO 28 LB=1, NBLENDS(IND)
-      IND1 = IBLENDS(LB,IND)
-      IF (XRED(IND1) .GE. XBLUE(IND1)) GOTO 28
-      FCL=0.0
-        DO 27 KL=KLMIN,KLMAX
-         FCL=FCL + PHIL(KL,LB) * FN(KL) * PWEIGHT(KL)
-   27    CONTINUE
-C***  CORRECT FOR THE INTEGRATION STEP XRED,X(KLMAX)
-        IF (KLMAX .LT. NFL) THEN
-           XKLMAX=XMAX-(KLMAX-1)*DELTAX
-           Q=(XKLMAX-XRED(IND))/DELTAX
-           FCL=FCL+ PHIL(KLMAX,LB)   * FN(KLMAX)   * PWEIGHT(KLMAX)
-     >                                             * 0.5 * (Q-1.)
-     >            + PHIL(KLMAX+1,LB) * FN(KLMAX+1) * PWEIGHT(KLMAX+1)
-     >                                             * 0.5 * Q
-           ENDIF
-C***  CORRECT FOR THE INTEGRATION STEP X(KLMIN),XBLUE
-        IF (KLMIN .GT. 1) THEN
-           XKLMIN=XMAX-(KLMIN-1)*DELTAX
-           Q=(XBLUE(IND)-XKLMIN)/DELTAX
-           FCL= FCL + PHIL(KLMIN,LB)   * FN(KLMIN)   * PWEIGHT(KLMIN)
-     >                                               * 0.5 * (Q-1.)
-     >              + PHIL(KLMIN-1,LB) * FN(KLMIN-1) * PWEIGHT(KLMIN-1)
-     >                                               * 0.5 * Q
+C***    Failsafe to prevent any negative radiation field
+        IF (XJLAPP(IND) < 0.) THEN
+          XJLAPP(IND) = XJL(L, IND)
+          bUSEALO(IND) = .FALSE.
+          IF (BDIAG(IND)) THEN
+C***        For iron lines, prevent the usage of the WFE values for the derivatives          
+            WFELOW(L, IND) = 0.
+            WFENUP(L, IND) = 0.
            ENDIF
-
-C***  Sum up XJLAPP: ADD THE CONTRIBUTION OF BLENDING LINE IND1
-      DELTASL = SLNEW(IND1) - SLOLD(IND1)
-      XJLAPP(IND) = XJLAPP(IND) + FCL * BETA(LB) * DELTASL
-
-28    CONTINUE
-
       ENDIF
 
-
-   11 CONTINUE
-
 C***  ONLY IF TEMPERATURE CORRECTIONS ARE APPLIED:
 C***  ADD SPECIAL TERM AT INNER BOUNDARY, WHICH ACCOUNTS FOR THE
 C***    DIRECT TEMPERATURE-DEPENDENCE OF THE RADIATION FIELD
 C***    VIA THE BOUNDARY CONDITION
-      IF (.NOT. NOTEMP  .AND.  L .EQ. ND) THEN 
-         XJLAPP(IND)=XJLAPP(IND)+0.5*(BNUE(XLAM,TL)-BNUE(XLAM,TLOLD))
-         ENDIF
+c        IF (.NOT. NOTEMP  .AND.  L .EQ. ND) THEN 
+c           XLAM=XLAMZERO(IND)
+c           XJLAPP(IND)=XJLAPP(IND)+0.5*(BNUE(XLAM,TL)-BNUE(XLAM,TLOLD))
+c        ENDIF
+c  we have to remove this if we consider the effect of XJC directly since this is included there
 
- 101    CONTINUE
-C***  ENDLOOP  ---------------------------------------------------------
-
-  102 CONTINUE
+      ENDDO
+C***  End line loop ----------------------------------------------------
 
 C***  XJL --> XJLAPP FOR DR-TRANSITIONS
-      DO 10 IND = LASTIND+1, LASTINDAUTO
-         IF (KRUDAUT(IND-LASTIND) .EQ. 1) GOTO 10
+  102 CONTINUE
+      DO IND = LASTIND+1, LASTINDAUTO
+         IF (KRUDAUT(IND-LASTIND) == 1) CYCLE
          XJLAPP(IND) = XJL(L,IND)
-   10 CONTINUE
+      ENDDO
 
       RETURN
       END
diff -bur ./shortray.f ../../powr-refactor/src/shortray.f
--- ./shortray.f	2024-07-28 13:14:30.000000000 +0200
+++ ../../powr-refactor/src/shortray.f	2023-11-21 10:10:55.293269795 +0100
@@ -8,7 +8,7 @@
      >        XHO, XHI, XNO, XNI, 
      >        Z, PPP, 
      >        IPLOT, BPLOT2, IW_COLIRAY_IPLUS, IVERS, 
-     >        XHOM, XHOP, XNOM, XNOP, OPA)
+     >        XHOM, XHOP, XNOM, XNOP, OPA, bWARNK)
 
 C***********************************************************************
 C***  LINE RADIATION TRANSFER IN THE COMOVING FRAME WITH A GIVEN SOURCE 
@@ -20,7 +20,7 @@
 C***  Output: The Intensities XIPLUS and XIMINUS 
 C***********************************************************************
 
-      INCLUDE 'interfacebib.inc'
+c      INCLUDE 'interfacebib.inc'
 
       DIMENSION RADIUS(ND), Z(ND), PPP(ND)
       DIMENSION ETAK(ND), OPAK(ND), OPAK_OLD(ND), OPA(ND)
@@ -29,12 +29,16 @@
       DIMENSION CWM0(ND,NP), CWM1(ND,NP), CWM2(ND,NP), CWM3(ND,NP)
       DIMENSION XIPLUS(ND), XIPLUS_OLD(ND), XIMINUS(ND), XIMINUS_OLD(ND)
 
-      LOGICAL PLOT, BPLOT2
+      LOGICAL :: PLOT, BPLOT2, bWARNK
+      
+      REAL :: XHID, TAUBOUND
 
       SAVE XIMINUS_OUT
+      SAVE CMWTEST 
 
       LMAX=MIN0(NP+1-JP,ND)
 
+      
 C***  Outer Boundary
 C***  All versions are independent of angle, 
 C***     i.e. I-minus must be set only once per frequency
@@ -144,7 +148,7 @@
         XIPLUS(LMAX) = XIMINUS(LMAX)
       ELSE
 C***  Core-Rays
-C        XIPLUS(LMAX) = BCORE + DBDR*Z(ND)/OPAK(ND) 
+c        XIPLUS(LMAX) = BCORE + DBDR*Z(ND)/OPAK(ND) * FluxCor
         XIPLUS(LMAX) = BCORE + 3.*XHID*Z(ND) 
 
         IF (XIPLUS(LMAX) .LT. 0.) THEN
@@ -153,6 +157,8 @@
         ENDIF
       ENDIF
 
+      rMINI = -1.E-300
+
 C***  Outward Integration of XIPLUS
       DO L=LMAX-1, 1, -1
         DZ = Z(L) - Z(L+1)
@@ -168,6 +174,7 @@
 ccc     >        (S_HAT, Z_HAT, S_OLD, Z, LMAX, L+1, .FALSE.)
           OPAK_HAT   = P*OPAK_OLD(L)   + Q*OPAK_OLD(L+1)
           TAU1       = 0.5*(OPAK(L) + OPAK_HAT) * Q * DZ
+          IBRANCH = 1
         ELSE          
           Q = PPDZ
           P = 1. - Q
@@ -175,6 +182,7 @@
           S_HAT      = P*S(L+1)      + Q*S_OLD(L+1)
           OPAK_HAT   = P*OPAK(L+1)   + Q*OPAK_OLD(L+1)
           TAU1       = 0.5*(OPAK(L) + OPAK_HAT) * DZ
+          IBRANCH = 2
         ENDIF
         EXPTAU1 = EXP(-TAU1)
         IF (ABS(TAU1) .GT. 1.0E-8) THEN
@@ -195,6 +203,14 @@
         XKL(L) = XKL(L) + 0.5*(XIPLUS(L)+XIMINUS(L)) * CWM2(L,JP)
         XHL(L) = XHL(L) + 0.5*(XIPLUS(L)-XIMINUS(L)) * CWM1(L,JP)
         XNL(L) = XNL(L) + 0.5*(XIPLUS(L)-XIMINUS(L)) * CWM3(L,JP)
+        
+        IF (XKL(L) < 0. .AND. .NOT. bWARNK) THEN
+          WRITE (0,'(A,2I4,4(3X,G20.10))') ' L, XKL, XJL', L, JP,
+     >        XKL(L), XJL(L), CWM0(L,JP), CWM2(L,JP)
+          WRITE (0,*) 'WARNING: NEGATIVE XKL IN COLI -> SHORTRAY'
+          bWARNK = .TRUE.
+        ENDIF
+        
       ENDDO
 
       IF (BPLOT2) THEN
@@ -206,12 +222,7 @@
 
 C***  Add the radiation field to XHO, XHI, XNO and XNI
       IF (LMAX .EQ. ND) THEN
-C***    Since 09 Feb 2016: special H (H_spec) for inner boundary
-C***    Note the unusual definition of an intensity-like core with
-C***    a flux-like weight. This allows to eliminate the backwards
-C***    Intensity I- at the inner boundary in the moment equations.
-        XHI = XHI + 0.5*(XIPLUS(ND)+XIMINUS(ND)) * CWM1(ND,JP)  
-C***    Currently XNI = XNL(ND) is unused
+        XHI = XHI + 0.5*(XIPLUS(ND)+XIMINUS(ND)) * CWM1(ND,JP)     !special H (H_spec) for inner boundary 
         XNI = XNI + 0.5*(XIPLUS(ND)-XIMINUS(ND)) * CWM3(ND,JP)
       ENDIF
       XHO  = XHO  + 0.5*(XIPLUS(1)-XIMINUS(1)) * CWM1(1,JP)
@@ -221,5 +232,11 @@
       XNOM = XNOM + 0.5*(         -XIMINUS(1)) * CWM3(1,JP)
       XNOP = XNOP + 0.5*(XIPLUS(1)           ) * CWM3(1,JP)
 
+      IF (JP == 1) THEN
+        CMWTEST = 0.
+      ENDIF
+      CMWTEST = CMWTEST + CWM1(1,JP)
+         
+
       RETURN
       END
Only in ../../powr-refactor/src/: steal.exe
Only in ../../powr-refactor/src/: steal.exe.opt
diff -bur ./steal.f ../../powr-refactor/src/steal.f
--- ./steal.f	2024-07-28 13:14:35.000000000 +0200
+++ ../../powr-refactor/src/steal.f	2024-07-22 09:27:16.108033925 +0200
@@ -13,7 +13,7 @@
 C*** NDIM and NFDIM are also set in LINPOP 
       INTEGER, PARAMETER :: NDIM    =        2560 
       INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400 
-      INTEGER, PARAMETER :: MAXAUTO =        2850 
+      INTEGER, PARAMETER :: MAXAUTO =        3200 
 C*** !!! ATTENTION !! USE of COMMON BLOCK in LINPOP !!!
 C*** MAXIND is also set in LINPOP 
       INTEGER, PARAMETER :: MAXIND  =       45000 
@@ -31,10 +31,10 @@
       INTEGER, PARAMETER :: MAXION = 27 
 
       INTEGER, PARAMETER :: NDIMP2  = NDIM + 2 
-      INTEGER, PARAMETER :: MAXKONT = NDIM 
+      INTEGER, PARAMETER :: MAXKONT = NFDIM/2 
       INTEGER, PARAMETER :: MAXKODR = NDIM 
 
-      INTEGER, PARAMETER ::MAXLAP = 40
+      INTEGER, PARAMETER ::MAXLAP = 60
 
 C***  NUMBER OF LEVELS WHICH CAN BE PLOTTED BY PLOTPOP
       INTEGER, PARAMETER ::MAXSETS = 25
@@ -47,15 +47,14 @@
       INTEGER, PARAMETER :: MAXGAHIST = 100
 
 C***  IRON: COMMON BLOCK ARRAY DIMENSIONS
-C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5    !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5    !xxl
+C      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5     !std
+c      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
+      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl / hydro
 
 C***  Fine Integration in STEAL - SETXJFINE
-      INTEGER, PARAMETER :: IFF_MAX =   80000      !std
+C      INTEGER, PARAMETER :: IFF_MAX =   80000      !std
 C      INTEGER, PARAMETER :: IFF_MAX =  200000      !vd20
-C      INTEGER, PARAMETER :: IFF_MAX =  300000      !xxl
+      INTEGER, PARAMETER :: IFF_MAX =  300000      !xxl / hydro
 
       INTEGER, PARAMETER :: TINYINT = SELECTED_INT_KIND(2)
 
@@ -66,11 +65,11 @@
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
       INTEGER, DIMENSION(MAXAUTO) :: LOWAUTO, IONAUTO
       REAL, DIMENSION(MAXAUTO) :: WAUTO, EAUTO, AAUTO
-      INTEGER KRUDAUT(MAXAUTO)
+      INTEGER, DIMENSION(MAXAUTO) :: KRUDAUT
       REAL, DIMENSION(NDIM) :: DRRATEN, RDIEL, RAUTO, DRJLW, 
      >                         DRJLWE, DRLJW
       INTEGER, DIMENSION(MAXKODR) :: KODRNUP, KODRLOW
-      CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
+      CHARACTER(10), DIMENSION(MAXAUTO) :: LEVUPAUTO, LEVAUTO
 
       REAL, DIMENSION(NPDIM) :: P
       REAL, DIMENSION(NDDIM,NPDIM) :: Z
@@ -84,7 +83,13 @@
      >                          HTOTL, HTOTCMF0, HTOTM, HTOTG, HTOTOBS,
      >                          AGRAV, AMECH, ARAD, APRESS, DTKUBAT,
      >                          ENTOTDENS, FTCOLI, TOLD2, TOLD3,
-     >                          GRSTATIC, VMACH, FLUXERR, CORRS
+     >                          GRSTATIC, GRDYN, VMACH, VTURB, HYDROF, 
+     >                          VELOorg, RADIUSorg, RNEorg, TAUSCALorg,
+     >                          Torg, T1old, T2old, T3old, RI, AMACHorg,
+     >                          ENTOTorg, GEFFLnew, GEFFL, GAMMARAD, 
+     >                          RNEdummy, RHELP, ARADHELP, VHELP,     
+     >                          VMIC, MacroDamp, CORRS, FLUXERR, 
+     >                          HTOTCUT, HTOTE, HTOTCMF0ADV
       INTEGER, DIMENSION(NDDIM) :: ITNE, IWARN
       REAL, DIMENSION(NDDIM, NDIM) :: POPNUM, DEPART, POPLTE,
      >                                POP1, POP2, POP3
@@ -95,20 +100,22 @@
       LOGICAL, DIMENSION(NDIM, NDIM) :: BCOLLIDONE
       REAL, DIMENSION(4, NDIM) :: ALTESUM
       REAL, DIMENSION(NFLDIM) :: PHI, PWEIGHT
-
       REAL, DIMENSION(MAXATOM) :: ABXYZ, ATMASS, STAGE
       INTEGER, DIMENSION(MAXATOM) :: KODAT, NFIRST, NLAST, IMAXPOP
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM, NDDIM) :: ARADELEM, ACONTELEM
+      REAL, DIMENSION(NDDIM, MAXATOM, MAXION) :: ARADION, ACONTION
       REAL, DIMENSION(MAXKONT) :: SIGMA1I, ALPHA, SEXPO,
      >                            ADDCON1, ADDCON2, ADDCON3
       REAL, DIMENSION(NFDIM) :: FWEIGHT, EMFLUX, EMCOLI 
       REAL, DIMENSION(NDDIM,NFDIM) :: XJC, WCHARM, XJCorg
-      REAL, DIMENSION(NDDIM,MAXINDE) :: XJL
+      REAL, DIMENSION(NDDIM,MAXINDE) :: XJL, XLAMAPPMEAN,
+     >                                  XLAMAPPUMEAN, XLAMAPPLMEAN
       REAL, DIMENSION(NFDIM,NDDIM) :: SCOLD
       REAL, DIMENSION(NFDIM,0:MAXION) :: SIGMAFF
       REAL, DIMENSION(NFDIM,MAXKONT) :: SIGMAKI
       INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW, NFEDGE
-      CHARACTER*8 IGAUNT(MAXKONT), KEYCBF(MAXKONT)
+      CHARACTER(8), DIMENSION(MAXKONT) :: IGAUNT, KEYCBF
 C     SPLIT: Groessere SCRATCH-Dimensionierung noetig
 C OLD> DIMENSION SCRATCH(2*NDIMP2), ATEST(NDIMP2,NDIMP2)
       REAL, DIMENSION(NDIMP2*NDIMP2) :: SCRATCH
@@ -122,14 +129,14 @@
       REAL, DIMENSION(MAXINDE) :: XJLAPP
       INTEGER, DIMENSION(10) :: NGAMC, NGAMR, NGAML, NGAMD
       REAL, DIMENSION(10) :: AGAMC, AGAMR, AGAML, AGAMD
-      REAL, DIMENSION(2) :: TauCorLimits
       LOGICAL, DIMENSION(MAXAUTO) :: DRXJL
       LOGICAL, DIMENSION(MAXIND) :: LINE, BDIAG
       LOGICAL :: NOTEMP, TPLOT, TPLTAU, CONVERG, MOREJOBS,
      >           NOEXTRAP, STHLP, NODATOM, OLDSTART, NOCON, COMPO,
-     >           NOPOP, BAUTO, BAUTO_ABORT, BINBOX,
+     >           DRNORUD, NOPOP, BAUTO, BAUTO_ABORT, BINBOX,
      >           BPRICORR, BCOREX, VPLOT, BUNLU, BHTOTERR, BITCONT,
-     >           BGFIN, BRDIVFAILED, BTRACE_POPNUM, bHLPHIST
+     >           BGFIN, BRDIVFAILED, BTRACE_POPNUM, bHLPHIST,
+     >           bLAMAPPCOLI, bALOTri
       CHARACTER(100) :: MODHEAD
       CHARACTER(255) :: HISTENTRY
       CHARACTER(80) :: COMMAND
@@ -138,6 +145,7 @@
       CHARACTER(10), DIMENSION(NDIM) :: LEVEL
       CHARACTER(10), DIMENSION(NDDIM) :: MAINPRO, MAINLEV
       CHARACTER(10), DIMENSION(MAXATOM) :: ELEMENT
+      LOGICAL, DIMENSION(MAXATOM) :: TRACEELEM
       CHARACTER(10), DIMENSION(MAXSETS, NDIM) :: LEVELPL, LEVELPLDEP
       CHARACTER(10) :: PRILEVRA
       CHARACTER(8), DIMENSION(NDDIM) :: INCRIT, VCRIT
@@ -151,52 +159,59 @@
       CHARACTER(256) :: TPLOTOPT
       CHARACTER(256), DIMENSION(MAXPLOTOPT) :: PLOTOPT
       REAL :: RMAX, GEDD, RCSAVE, DENSCON_FIX, CORRLAST
-      CHARACTER(1200) :: UNLUTECLINE
-      CHARACTER(120) :: DENSCON_LINE,
-     >                 ThinCard, HydroCard, AlphaCard, MacroCard
-      CHARACTER*80 DRLINES_CARD
+      CHARACTER(1200) :: UNLUTECLINE, HydroCard
+      CHARACTER(120) :: DENSCON_LINE, VTURB_LINE, DRLINES_CARD,
+     >                 ThinCard, AlphaCard, MacroCard, TaumaxCard
       CHARACTER(8) :: OPC, GEFFKEY
-      LOGICAL :: BFEWING, bTDIFFUS, BPLOCC, BTALTER
+      LOGICAL :: BPLOCC, BTALTER
       REAL, DIMENSION(MAXIND) :: XLAMBLUE, XLAMRED, DEXFAC
       INTEGER, DIMENSION(MAXLAP,MAXIND) :: IBLENDS
       REAL, DIMENSION(NFLDIM,MAXLAP) :: PHIL
       REAL, DIMENSION(MAXLAP) :: BETA
       INTEGER, DIMENSION(2*NDDIM+8) :: IADR16
-      REAL, DIMENSION(NDDIM) :: DTLOCAL
+      REAL, DIMENSION(NDDIM) :: DTLOCAL, DTFTFLX
       REAL, DIMENSION(NDIM) :: DTINT, DTRMAX
+      REAL, DIMENSION(NDDIM, MAXATOM) :: VDOPDD
       LOGICAL, DIMENSION(MAXKONT) :: NRB_CONT
-      LOGICAL, DIMENSION(NDIM,NDDIM) :: ZERO_RATES
+      LOGICAL, DIMENSION(NDIM, NDDIM) :: ZERO_RATES
 C***  New CARDS options added by ansander
-      LOGICAL :: bENSURETAUMAX, bHYDROSOLVE, bBLOCKINVERSION,
+      LOGICAL :: bENSURETAUMAX, bHYDROSOLVE, bRELSCHARMERACC,
      >           bFixGEFF, bTauStrict, bTauUpdated, bThinWind, 
      >           bGEddFix, bHydroDone, bNewVelo, bSUMMARY, bNoARAD,
-     >           bSaveTauCont, BOOLdummy, bUpdateMass, bUseTWOPNT,
-     >           bLateTau, bModHeadUpdate, bHydroHelp, bRELSCHARMERACC,
-     >           bOLDVELO, bTauMaxSafe, bFULLHYDROSTAT, bGAMMARADMEAN,
-     >           bBackupNow, bForceColiPP, bUCPP, bFeTCORR, bNoFeTCORR
-      REAL :: VMIN, RCON, TAUACC, TAUMAX, ReduceTauCorrections
+     >           bSaveTauCont, bRESTART, BOOLdummy, bUpdateMass, 
+     >           bLateTau, bKUBAT, bLOCAL, bModHeadUpdate, bHydroHelp,
+     >           bOLDVELO, bFULLHYDROSTAT, bGAMMARADMEAN, bINTUNIFY,
+     >           bBackupNow, bTMNoOS, bHYSTloose, bFTFLX,
+     >           bForceColiPP, bUCPP, bUpdateVT, bTDIFFUS, bDDVDOP, 
+     >           bHDNoAG, bTMTHOM, bKUBATDEBUG, BFEWING, bUseTWOPNT,
+     >           bFRACINV, bForceTDIFFUS, bFeTCORR, bNoFeTCORR,
+     >           bINT, bRMAX, bINCADV, bUpdateTEFF
+
+      REAL :: VMIN, RCON, TAUACC, TAUMAX
       CHARACTER(80), DIMENSION(3) :: RadiusGridParameters           !contains all RADIUS-GRID CARDS (for subr. RGRID)      
 
       REAL :: TEFF, GLOG, GEFFLOG, XMSTAR, GF, RSTAR, VDOP, XMAX,
-     >        VDOPFE, DXFE, XLAM0FE, TOTOUT, TOTIN, OPARND, VMAX,
+     >        VDOPFE, DXFE, XLAM0FE, TOTOUT, TOTIN, OPARND, VDOPUNIT,
      >        EDDIHOUTJMEAN, HTOTOUTMINUS, EPSILON, REDUCE, GEDDreduce,
      >        BRRESET, SMALLPOP, POPMIN, POPRANG, DELTAC, COREX,
-     >        XLAM_FINE_START, XLAM_FINE_END, WJCMIN, FQLIMIT,
-     >        WORKRATIO, GAMMAC, Rcritical,
-     >        DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, TBTAU, TAUINT,
-     >        GAMMAR, GAMMAL, GAMMAD, TNDCORR, DFEINDR,
+     >        XLAM_FINE_START, XLAM_FINE_END, WJCMIN, HNDCORFAC, DUMMY,
+     >        WORKRATIO, DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, MG,
+     >        GAMMAC, Rcritical, GAMMAR, GAMMAL, GAMMAD, TNDCORR, 
      >        CORMAX, RTCMAX, RELIT, XLOGL, RTRANS, XMDOT, GEDDRAD,
-     >        TEFFdummy, ZEROdummy, ZEROdummy2, GFLSAV, VTURB,
+     >        TEFFdummy, ZEROdummy, ZEROdummy2, GFLSAV, DFEINDR,
      >        VPAR1, VPAR2, HSCALE, BETA2, BETA2FRACTION, CLUMP_SEP,
      >        VPAR1_2, VPAR2_2, VFINAL, ATMEAN, OPALINE_SCALE,
-     >        GAMMARADMEAN, QIONMEAN, DTDRIN, HTOTND, HNDCORFAC, 
-     >        FLUXEPS, HYSTACC
+     >        GAMMARADMEAN, QIONMEAN, VMAX, HTOTMINUSND, HTOTND, 
+     >        HTOTNDCOR, POPMIN_org, fTNDCOR, DTDRIN, 
+     >        TBTAU, TAUINT, FLUXEPS, HYSTACC, ALOMIN, CORDELTAHDLAST,
+     >        TAUHDRAW, EXPTAUTCL
 
       REAL, PARAMETER :: AMU = 1.6605E-24   ! Atomic mass unit in gramm
 
       INTEGER :: N, L, LAST, JOBNUM, NCOLIP, IDX, KANAL, NFL, LASTIND,
-     >           I, J, NATOM, NAUTO, LASTKON, LASTKDR, KDR, LASTFE,
-     >           ND, NP, NF, NF2, IFF_N_MS, LSRAT, JOBMAX, K, KV, LST,
+     >           I, J, NATOM, NAUTO, LASTKON, LASTKDR, LASTFE, KDR,
+     >           LASTINDAUTO, LASTINDALL, iALOentry,
+     >           ND, NP, NF, NF2, IFF_N_MS, LSRAT, JOBMAX, K, KV,
      >           NDDUMMY, IHIST, IFRRA, ITORA, IPRICC, IPRILC, LSEXPO,
      >           LSTAU, LSPOP, IFLUX, IDAT, NPLOT, NEWWRC, NOLAP, ITBR,
      >           NATOUT, NUP, LOW, IPRINTZERORATES, NPLOTDEP, NPLOTOPT,
@@ -205,23 +220,29 @@
      >           NLASER, IND, IERR, NBRCANC, NKONVER, MAXFEACT, iAMT,
      >           IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP, ITSUM, IDUMMY, 
      >           NEXTHYDRO, LASTHYDRO, MFORM, iBLOCKINVERSION, iZRType,
-     >           LASTBACKUP, LASTTAU, NBACKUP, NTOLD, NKONV_THRESH,
-     >           IHSSTATUS, LASTINDAUTO, LASTINDALL, N_WITH_DRLEVELS, MG
+     >           LASTBACKUP, LASTTAU, NBACKUP, N_WITH_DRLEVELS,
+     >           LDTKDEC, LDTKOFF, ICMMODE, LASTHYDGA, LASTHYDROGAM,
+     >           NKONV_THRESH, NTOLD, LST, NDOUT, IHSSTATUS, IHDSTATUS
 
 
 C***  Hydro Stuff
+      INTEGER, PARAMETER :: ITMAXHYDRO = 1000               !Maximum number of iteration steps
       REAL, DIMENSION(NDDIM-1) :: ATHOM, ACONT
-      REAL, DIMENSION(NDDIM) :: RHO, XMU, ALPHAF
+      REAL, DIMENSION(NDDIM) :: RHO, XMU, ALPHAF, ARMDRESP
+      REAL, DIMENSION(3) :: HydroValues
+      REAL, DIMENSION(NDDIM, 2*ITMAXHYDRO) :: F_hist, G_hist !history arrays
 
 C***  Unsoeld-Lucy terms for TEMPEQ
       REAL, DIMENSION(NDDIM) :: OPASMEAN, QFJMEAN, OPAJMEAN,
-     >                          OPAPMEAN, QOPAHMEAN, OPASMEANTC, 
-     >                          OPAJMEANTC, OPALAMBDAMEAN, SMEAN
+     >                          OPAPMEAN, QOPAHMEAN, QOPAHMEANL,
+     >                          OPASMEANTC, SMEAN, HMEAN,
+     >                          OPAJMEANTC, OPALAMBDAMEAN
 
       REAL, DIMENSION(MAXIND) :: XRED, XBLUE, SLOLD, DETAL, OPAL,
      >                           SLNEW, DOPAL, SCOLIND, SCNEIND,
      >                           OPACIND, XRED0, XBLUE0, OPALOLD,
      >                           XLAMZERO
+      LOGICAL, DIMENSION(MAXINDE) :: bUSEALO
       INTEGER, DIMENSION(MAXIND) :: INDNUP, INDLOW, NBLENDS
       REAL, DIMENSION(4,MAXIND) :: COCO
 
@@ -322,6 +343,11 @@
 C***  Auto Gamma
       REAL, DIMENSION(7) :: AG
 
+C***  DEBUG:
+      REAL, DIMENSION(2) :: TauCorLimits
+      REAL :: ReduceTauCorrections, FQLIMIT
+      LOGICAL :: bTauMaxSafe, bBLOCKINVERSION
+
       CHARACTER(10) :: TIM1
 
       INTEGER :: ITWARN, ITMAX
@@ -337,11 +363,15 @@
       CHARACTER(60) :: LINK_HOST
       COMMON / COM_LINKINFO / LINK_DATE, LINK_USER, LINK_HOST
 
+C***  SOLAR RADIUS ( CM )
+      REAL, PARAMETER :: RSUN = 6.96E10
+
 C***  File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
       INTEGER, PARAMETER :: hMODEL = 3      !write to MODEL file
-      INTEGER, PARAMETER :: hHIST = 21      !write to MODHIST file
+      INTEGER, PARAMETER :: hHIST = 22      !write to MODHIST file
+      INTEGER, PARAMETER :: hALO  = 23      !integer handle of the ALO file
 
       INCLUDE 'interfacebib.inc'
 
@@ -352,8 +382,10 @@
       HTOTND = 0.
       CONVERG = .FALSE.
       FLUXERR = .0
+      bRESTART = .FALSE.
       BGFIN = .FALSE.
       IHSSTATUS = -1
+      IHDSTATUS = -1
 C***  Set Counters for Warnings
       IWARN_NEG_XJCAPP = 0
       IWARN_NEG_XJLAPP = 0
@@ -374,11 +406,11 @@
 
       CALL INSTALL
                                  
-c      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
-c        CALL CLOCK(TIM1)
+      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+        CALL CLOCK(TIM1)
 c      ELSE
 c        CALL TIME(TIM1)
-c      ENDIF
+      ENDIF
 
       !Put dummy stuff into COMMON block data to ensure storage reservation
       NDDUMMY = NDDIM
@@ -386,9 +418,58 @@
       DO L=1, NDDIM
         OLDRADI(L) = 1337.
         OLDVELO(L) = 1338.
+        DO IND=1, MAXIND
+          WFELOW(L,IND) = 0.
+          WFENUP(L,IND) = 0.
+        ENDDO
+        DO IND=1, MAXINDE
+          XLAMAPPMEAN(L, IND) = -31337.
+        ENDDO
+      ENDDO
+      DO IND=1, MAXIND
+        XRED(IND) = 0.
+        XBLUE(IND) = 0.
+        SLOLD(IND) = 0.
+        SLNEW(IND) = 0.
+        bUSEALO(IND) = .FALSE.
+        DETAL(IND) = 1337.
+        OPAL(IND) = 1337.
+        DOPAL(IND) = 1338.
+        SCOLIND(IND) = 0.   ! crucial
+        SCNEIND(IND) = 0.   ! crucial
+        OPACIND(IND) = 0.   ! crucial
+        XRED0(IND) = 0.
+        XBLUE0(IND) = 0.
+        OPALOLD(IND) = 1337.
+        XLAMZERO(IND) = 31337.
+        NBLENDS(IND) = 31338
+        INDNUP(IND) = 0.
+        INDLOW(IND) = 0.
+        DO I=1, 4
+          COCO(I, IND) = 0.
+        ENDDO
+      ENDDO
+
+      DO NF=1, NFDIM
+        XLAMBDA(NF) = -33.
+        XLAMBDA2(NF) = -33.
+        XJCAPP(NF) = -33. 
+        OPAC(NF) = -33.
+        SCNEW(NF) = -33.
+        DOPA(NF) = -33.
+        DETA(NF) = -33.
+        ETAC(NF) = -33.
+        EXPFAC(NF) = -33.
+        XJCLP1(NF) = -33.
+        OPAC1(NF) = -33.
+        XKC(NF) = -33.
+        XKC2(NF) = -33.
+        XJCAPPNEW(NF) = -33.
+        DO I=1, 4
+          XJC_PLOTDATA_L(NF, I) = -33.
+        ENDDO
+        FWTEST(NF) = -33.
       ENDDO
-      WFELOW = 0.
-      WFENUP = 0.
 
 C***  DEFINE CHANNEL 2 FOR PLOTS
       KANAL = 2
@@ -426,34 +507,40 @@
      >                  LASTFE, SIGMAFE, INDRB, INDRF,
      >                  IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY, 
      >                  VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >                  LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
  
       LASTINDAUTO = LASTIND + NAUTO
       LASTINDALL  = LASTIND + NAUTO + LASTFE
 
 C***  READING OF THE MODEL FILE ----------------------------------------
       CALL REMOST (ND,NDDIM,NP,NPDIM,P,Z,
-     >               ENTOT,TOLD,NF,NFDIM,XLAMBDA,FWEIGHT,RADIUS,
-     >               RSTAR,RCON,VELO,GRADI,VDOP,INCRIT,VCRIT,TOTOUT,
-     >               TOTIN,EMFLUX, MAXAUTO,LASTIND,INDNUP,INDLOW,KEY,
-     >               RNE,MODHEAD,JOBNUM,XJC,XJL,MODHIST,MAXHIST,LAST,
-     >               EINST,NDIM,ABXYZ,NATOM, TEFF, GLOG, GEFFLOG,
-     >               bFixGEFF, GEDD, bGEddFix, ENTOTDENS, XMDOT, 
-     >               Rcritical, GEDDRAD, XMSTAR, NAUTO, DRXJL, 
-     >               MAXXDAT, XDATA, HTOTL, BHTOTERR, HTOTND, DTDRIN,
+     >               ENTOT,TOLD,NF,NFDIM,XLAMBDA,FWEIGHT,
+     >               RADIUS,RSTAR,RCON,VELO,GRADI,VDOP,INCRIT,VCRIT,
+     >               TOTOUT,TOTIN,EMFLUX, MAXAUTO,LASTIND,INDNUP,
+     >               INDLOW,KEY,RNE,MODHEAD,JOBNUM,XJC,XJL,MODHIST,
+     >               MAXHIST,LAST,EINST,NDIM,ABXYZ,NATOM, TEFF, 
+     >               GLOG, GEFFLOG, bFixGEFF, GEDD, bGEddFix, 
+     >               ENTOTDENS, XMDOT, Rcritical, GEDDRAD, 
+     >               XMSTAR, NAUTO, DRXJL, MAXXDAT, XDATA, 
+     >               HTOTL, BHTOTERR, HTOTND, HTOTCUT, DTDRIN,
      >               DENSCON, FILLFAC, 
      >               LASTFE, ARAD, bNoARAD, WFELOW, WFENUP, NCOLIP,
-     >               FTCOLI, EMCOLI, GAHIST, 
-     >               MAXGAHIST, MAXIND, MAXINDE, MAXKONT, LASTKON,
-     >               XJTOTL, XKTOTL, XNTOTL, WJC, GF, OPARND, 
+     >               FTCOLI, EMCOLI, ARADELEM, ACONTELEM,
+     >               MAXION, ARADION, ACONTION, 
+     >               GAHIST, MAXGAHIST, MAXIND, MAXINDE, MAXKONT, 
+     >               LASTKON, XJTOTL, XKTOTL, XNTOTL, WJC, GF, OPARND, 
      >               OPASMEAN, OPASMEANTC, QFJMEAN, OPAJMEAN, SMEAN,
      >               OPAJMEANTC, OPAPMEAN, QOPAHMEAN,
-     >               EDDIHOUTJMEAN, XLAMBDA2, NF2, HTOTOUTMINUS, 
+     >               EDDIHOUTJMEAN, HMEAN, XLAMBDA2, NF2,
+     >               HTOTOUTMINUS, HTOTMINUSND, HTOTNDCOR,
      >               FF_INFO, IFF_DK, IFF_MAX, IFF_N_MS, 
      >               OPALAMBDAMEAN, TAUROSS, TAUROSScont, VMIN, N, 
      >               POPNUM, SIGMAKI, ATMASS, ACONT, ATHOM, OPALROSS,
-     >               RHO, XMU, ALPHAF, NEXTHYDRO, LASTHYDRO, VTURB,
-     >               GRSTATIC, LASTBACKUP, LASTTAU, GEFFKEY, ZERO_RATES)      
+     >               RHO, XMU, ALPHAF, ARMDRESP, HYDROF, NEXTHYDRO, 
+     >               LASTHYDRO, VTURB, VMIC, POPMIN, ZERO_RATES,
+     >               GRSTATIC, GRDYN, LASTBACKUP, LASTTAU, GEFFKEY,
+     >               XLAMAPPMEAN, XLAMAPPUMEAN, XLAMAPPLMEAN,
+     >               iALOentry, bHDNoAG, CORDELTAHDLAST, TAUHDRAW) 
      
       WRITE(hCPR,'(A,I7)') '>>> This is job number ', JOBNUM
       IF (TAUROSScont(ND) < 0.) THEN
@@ -485,17 +572,19 @@
      >     BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX, 
      >     BNUEFE, BXJLAPPCORE, WJCMIN, NKONV_THRESH,
      >     iBLOCKINVERSION, RSTAR, RMAX, TAUMAX, bENSURETAUMAX, TAUACC,
-     >     bTauStrict, ReduceTauCorrections, TauCorLimits, FQLIMIT,
+     >     bTauStrict,
      >     RadiusGridParameters, VMIN, bThinWind, ThinCard, bSUMMARY,
-     >     bHYDROSOLVE, bLateTau, HydroCard, AlphaCard, 
+     >     TaumaxCard, bHYDROSOLVE, bLateTau, HydroCard, AlphaCard, 
      >     DENSCON_FIX, DENSCON_LINE, MFORM, XMSTAR, GLOG, bUpdateMass,
-     >     WRTYPE, MODHEAD, bModHeadUpdate, bOLDVELO, bTauMaxSafe,
+     >     WRTYPE, MODHEAD, bModHeadUpdate, bOLDVELO,
      >     bFULLHYDROSTAT, bGAMMARADMEAN, GEDDreduce, iZRType, iAMT,
-     >     CLUMP_SEP, MacroCard, OPALINE_SCALE, NBACKUP, GEFFKEY, bUCPP,
-     >     FLUXEPS, HYSTACC, IHSSTATUS, bNoFeTCORR, bUseTWOPNT, 
-     >     bRELSCHARMERACC)
-
-      bBLOCKINVERSION = (iBLOCKINVERSION /= 0)  !temporary line until full ion split is implemented
+     >     CLUMP_SEP, MacroCard, OPALINE_SCALE, NBACKUP, GEFFKEY,
+     >     bHydroHelp, bHYSTloose, ICMMODE, bUCPP,
+     >     bUpdateVT, VTURB, fTNDCOR, bTMTHOM, bKUBATDEBUG,
+     >     bRELSCHARMERACC, bUseTWOPNT, FLUXEPS, HYSTACC, IHSSTATUS,
+     >     NDOUT, VTURB_LINE, ALOMIN, bLAMAPPCOLI, bDDVDOP,
+     >     bFRACINV, bForceTDIFFUS, bNoFeTCORR, TRACEELEM, bINCADV,
+     >     ENTOT, RHO, iALOentry, bALOTri)
 
 C***  The following lines are because the LINE option was removed from
 C***  decste wrh  4-Apr-2023
@@ -557,6 +646,10 @@
          ENDDO
       ENDIF
 
+      VDOPUNIT = VDOP
+      CALL VDOPDD_SETUP(bDDVDOP, VDOPDD, VDOPUNIT, DUMMY,
+     >                  TOLD, VMIC, ATMASS, ND, NATOM)          
+
 C***  COLI++ after this STEAL job forced by CARDS option     
       IF (bUCPP) THEN
         bForceColiPP = .TRUE.
@@ -566,7 +659,7 @@
 ccc   as a parameter for some subroutines. It is always: 
       NOTEMP=.TRUE.
 
-      !Avoid temperature corrections right after hydro step
+      !Avoid temperature corrections right after hydro and TAUMAX step
       IF (BUNLU .AND. ((LASTHYDRO == 1) 
      >                  .OR. (bLateTau .AND. LASTHYDRO == 2))) THEN
         BUNLU = .FALSE.
@@ -626,16 +719,16 @@
       CORRLAST = MIN(CORRLAST, 1.)
 
 C***  Preparations for Fluxcorrection in TEMPCORR (UnLu-Method)
-      CALL INITFCORR (TEFF, RSTAR, TOLD, RNE, bNoARAD,
+      CALL INITFCORR (TEFF, RSTAR, TOLD, RNE, bNoARAD, bINCADV,
      >                ABXYZ, ATMASS, ELEMENT, NATOM, WRTYPE,
      >                RADIUS, VELO, GRADI, VTURB, ENTOT, ND,
      >                HTOTM, HTOTG, HTOTOBS, HTOTL, ACONT, ATHOM,
      >                AGRAV, AMECH, ARAD, APRESS, WORKRATIO,
      >                CLUMP_SEP, OPALROSS, MacroCard, DENSCON,
-     >                FILLFAC, OPALINE_SCALE,
-     >                FTCOLI, XJTOTL, XKTOTL, XNTOTL, HTOTCMF0, 
-     >                XMSTAR, MFORM, GLOG, ATMEAN, VMACH,
-     >                TAUROSS, QIONMEAN, GAMMARADMEAN, RCON)
+     >                FILLFAC, OPALINE_SCALE, MacroDamp, FTCOLI,
+     >                XJTOTL, XKTOTL, XNTOTL, HTOTCMF0, HTOTCMF0ADV,
+     >                HTOTND, HTOTE, XMSTAR, MFORM, GLOG, ATMEAN,VMACH,
+     >                XMU, TAUROSS, QIONMEAN, GAMMARADMEAN, RCON)
 
 C***  Calculate ABS(DTDR) at inner boundary (e.g. for use in COLI)
 C***  This works best if one full COLI was already done, since then the full
@@ -653,7 +746,7 @@
      >                ALPHA, SEXPO, ADDCON1, ADDCON2, ADDCON3, 
      >                IGAUNT, NF, XLAMBDA, FWEIGHT, NOM,
      >                MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT, 
-     >                RADIUS(ND), KONTNUP, KONTLOW, LASTKON)
+     >                RADIUS(ND), KONTNUP, KONTLOW, LASTKON, POPMIN)
 C***    Scale opacity down with filling factor
         OPARND = OPARND * FILLFAC(ND)
       ENDIF
@@ -661,7 +754,7 @@
 C***  Start approximation for the temperature gradient at ND
 C***  This should not be calculated before an OLD MODEL might have been adapted
 C***  The first coli will calculate this gradient if still missing
-      IF (DTDRIN < .0 .AND. JOBNUM .GT. 1) THEN
+      IF (DTDRIN < .0 .AND. JOBNUM > 1) THEN
          DTDRIN = 0.1875 * OPARND * TEFF**4 / TOLD(ND)**3
       ENDIF
 
@@ -679,7 +772,10 @@
      >                 LASTKON, LASTIND, LASTINDAUTO, LASTINDALL, 
      >                 OPALROSS, TOLD, RADIUS,
      >                 RSTAR, OPALAMBDAMEAN, OPASMEANTC, 
-     >                 DTKUBAT, BCOLLIDONE )
+     >                 MAXKONT, ADDCON1, ADDCON2, ADDCON3, 
+     >                 IGAUNT, ALPHA, SEXPO, MAXION,
+     >                 DTKUBAT, bCOLLIDONE, ZERO_RATES,
+     >                 bKUBATDEBUG)
 
         IF (.NOT. bNoFeTCORR) THEN
 C***      Added in Feb 2018 to wrh branch:        
@@ -692,15 +788,17 @@
             AGAMD(MG) = 0.
           ENDDO
         ENDIF
-        CALL TEMPCORR (TOLD, TNEW, ND, RADIUS, TEFF,
-     >    HTOTL, XJTOTL, HTOTCMF0, FTCOLI, 
-     >    DTLOCAL, DTINT, DTRMAX, FLUXERR,
+        CALL TEMPCORR (TOLD, TNEW, ND, RADIUS, VELO, TEFF,
+     >    VTURB, XMU, RSTAR, HTOTL, XJTOTL, HTOTCMF0,
+     >    HTOTCMF0ADV, FTCOLI, DTLOCAL, DTINT, DTRMAX, FLUXERR,
      >    OPASMEANTC, QFJMEAN, OPAJMEANTC, OPAPMEAN, 
-     >    QOPAHMEAN, EDDIHOUTJMEAN,
-     >    HTOTOUTMINUS, HTOTND, OPARND, DTDRIN, UNLUTECLINE, 
-     >    DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, TBTAU, TAUINT,
-     >    OPALAMBDAMEAN, TAUROSS, ARAD, DTKUBAT, BTDIFFUS, HNDCORFAC,
-     >    SMEAN, CORRS, FLUXEPS)
+     >    QOPAHMEAN, QOPAHMEANL, OPARND, 
+     >    EDDIHOUTJMEAN, HMEAN, HTOTCUT, SMEAN, HTOTOUTMINUS, 
+     >    HTOTND, DTDRIN, UNLUTECLINE, DUNLU_LOC, DUNLU_RMAX, 
+     >    DUNLU_INT, DUNLU_TB, TBTAU, TAUINT, EXPTAUTCL,
+     >    OPALAMBDAMEAN, TAUROSS, ARAD, DTKUBAT,
+     >    bKUBAT, bLOCAL, bINT, bRMAX, bINCADV,
+     >    bTDIFFUS, HNDCORFAC, CORRS, FLUXEPS)
      
       ELSE
          DO L=1, ND
@@ -774,10 +872,12 @@
       ENDIF
 
 C*** AUTO-GAMMA Artistics
-      IF (BAG) 
-     >  CALL ADJGAMMA(GAHIST, MAXGAHIST, AG, LASTHYDRO, BTALTER,
-     >                GAMMAC, GAMMAL, GAMMAR, GAMMAD, BGFIN, GF, 
-     >                BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, BGAMMADFIX)
+      IF (BAG) THEN
+        CALL ADJGAMMA(GAHIST, MAXGAHIST, AG, LASTHYDRO, LASTTAU, 
+     >                BTALTER, GAMMAC, GAMMAL, GAMMAR, GAMMAD, BGFIN,
+     >                GF, BGAMMACFIX, BGAMMALFIX, BGAMMARFIX, 
+     >                BGAMMADFIX, bHDNoAG)
+      ENDIF
 
 C***  IN CASE OF JOBNUM=1 (STARTJOB) OR OUTPUT REQUEST ONLY (STHLP),
 C***  GAMMA'S ARE SET ZERO:
@@ -790,6 +890,8 @@
      >       "STEAL: JOBNUM=1 or output-only -> All GAMMAs = 0"
       ENDIF
  
+      POPMIN_org = POPMIN
+ 
 C***  SKIP ANY CALCULATIONS IN OUTPUT-ONLY MODE OR OLDSTART-INITIALIZATION
       IF (STHLP .OR. OLDSTART .OR. (bLateTau .AND. LASTHYDRO == 1)) THEN
         WRITE (hCPR,*) "This STEAL is a short one (skipping LINPOP)"
@@ -818,7 +920,7 @@
      $                  KODAT,NFIRST,NLAST,NATOUT,
      $                  NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $                  RDIEL,RAUTO,IONAUTO,IONGRND,
-     $                  INDNUP, INDLOW, LASTIND, LASTINDALL,
+     $                  INDNUP,INDLOW,LASTIND, LASTINDALL, MAXION,
      $                  KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,LASTKDR,
      $                  KEYCBF,MAXATOM,SIGMATHK,SEXPOK,EDGEK,LASTINDAUTO,
      $                  KRUDAUT, ZERO_RATES, POPMIN,
@@ -847,30 +949,32 @@
 
 C***    PREPARATION OF THE LINE-OVERLAP TREATMENT
 C***    IRON: IRON-LINES ARE OMITTED (-->NBLENDS = 0)
-        CALL OVERLAP (IBLENDS,MAXLAP, LASTIND, LASTINDAUTO,
+        CALL OVERLAP (IBLENDS,MAXLAP,LASTIND, LASTINDAUTO,
      >                XLAMZERO,XLAMRED,XLAMBLUE,
-     >                XMAX,EINST,NDIM,ELEVEL,INDNUP,INDLOW,NOLAP,VDOP,
-     >                NBLENDS, KRUDAUT, EAUTO, NAUTO, EION)
+     >                XMAX,EINST,NDIM,ELEVEL,INDNUP,INDLOW,NOLAP,
+     >                VDOPUNIT,NBLENDS, KRUDAUT, EAUTO, NAUTO, EION)
      
 C***    Temperature correction at inner boundary if TDIFFUS is set in CARDS
-        IF (bTDIFFUS) THEN
-          CALL TDIFFUS(TNEW, RADIUS, ND, TEFF, OPARND, TNDCORR)
+        IF ((bTDIFFUS .AND. BUNLU) 
+     >           .OR. (bTDIFFUS .AND. bForceTDIFFUS)) THEN
+          CALL TDIFFUS(TNEW, RADIUS, ND, TEFF, OPARND, TNDCORR,
+     >                 bNoARAD, HTOTNDCOR, fTNDCOR)
+          WRITE (hCPR,*) 
+     >       'STEAL: T at inner boundary updated via TDIFFUS'
         ENDIF
 
 C***    SOLUTION OF THE NON-LINEAR SET OF RATE EQUATIONS
-        
-
         CALL LINPOP (TNEW,RNE,ENTOT,ITNE,POPNUM,DEPART,POPLTE,POP1,
      $   N,ENLTE,WEIGHT,NCHARG,EION,ELEVEL,EN,EINST,LEVEL,
      $   FWEIGHT,XJC,NF,XJL,WCHARM,SCOLD,
-     $   XJLAPP,
-     $   DM, V1,V2,GAMMAC,GAMMAL,EPSILON,
+     $   XJLAPP, XLAMAPPMEAN, bUSEALO, ALOMIN, bLAMAPPCOLI,
+     >   DM, V1,V2,GAMMAC,GAMMAL,EPSILON,TOLD,
      $   NOTEMP,DELTAC,GAMMAR,IPRICC,IPRILC,MODHEAD,JOBNUM,IFRRA,ITORA,
      $   RADIUS,RSTAR,OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,
-     $   VELO,GRADI, VDOP,NFLDIM,PHI,PWEIGHT,
+     $   VELO,GRADI, VDOPDD, VDOPUNIT,NFLDIM,PHI,PWEIGHT,
      $   LASTIND,LASTINDAUTO, LASTINDALL,
      $   SIGMAKI,
-     $   ND,LSRAT,CRATE,RRATE,RATCO,ALPHA,SEXPO, 
+     $   ND,LSRAT,CRATE, RRATE,RATCO,ALPHA,SEXPO, 
      $   ADDCON1, ADDCON2, ADDCON3, 
      $   IGAUNT, KEYCBB, NRB_CONT, ZERO_RATES, IPRINTZERORATES, POPMIN,
      $   LINE,ALTESUM,NFEDGE,NOM,NATOM,ABXYZ,KODAT,NFIRST,
@@ -880,9 +984,9 @@
      $   RAUTO,DRJLW,DRJLWE,DRLJW,NSCHAR,MAXATOM,BETA,PHIL,NBLENDS,
      $   SIGMATHK,SEXPOK,EDGEK,XDATA,
      $   KONTNUP,KONTLOW,LASTKON,KODRNUP,KODRLOW,LASTKDR,KEYCBF,NATOUT,
-     $   BRRESET,NOCON,ENOLD,TEFF, KRUDAUT, ELEMENT, 
-     $   BAUTO, BAUTO_ABORT, CKONVER, SMALLPOP, BUNLU, 
-     >   DENSCON, FILLFAC, ENTOTDENS,
+     $   BRRESET,NOCON,ENOLD,TEFF, KRUDAUT, 
+     $   BAUTO, CKONVER, SMALLPOP, BUNLU, 
+     >   FILLFAC, ENTOTDENS,
      >   WFELOW, WFENUP, GAMMAD, NKONVER, WJC, 
      >   OPC, BPLOCC, LPLOCC, KPLOCC, KANAL, 
      >   LASTFE, WJCMIN, NKONV_THRESH,
@@ -909,11 +1013,11 @@
      >   IFF_MAX, IFF_MAX, FF_INFO, IFF_DK, IFF_WCHARM, WCHARM_FINE, 
      >   IFF_N_MS,
 C***  Split Parameter (if blockwise DM inversion is used or not)
-     >   bBLOCKINVERSION, AOFF, CORRLAST, bRELSCHARMERACC,
-C***  Settings for ZERO_RATES, BROYDEN TWOPOINT, and AUTO_MODIFY
-     >   iZRType, bUseTWOPNT, iAMT,
-C***  Fe rate temperature correction
-     >   CORRS, DEXFAC, bFeTCORR,
+     >   iBLOCKINVERSION, AOFF, CORRLAST, bRELSCHARMERACC, bFRACINV,
+C***  FERAT correction      
+     >   CORRS, DEXFAC, bFeTCORR, iZRType, 
+C***  Two-point broyden and auto modify temperature settings
+     > bUseTWOPNT, iAMT, 
 C***  For constant consistency check     
      >   NDIM, MAXIND, NFDIM, MAXFEIND)
 
@@ -935,7 +1039,7 @@
  
    20 CONTINUE
 C***  REDUCED CORRECTIONS, IF OPTION IS SET
-      IF (REDUCE.NE.1. .AND. JOBNUM.GT.1 .AND. .NOT. STHLP)
+      IF (REDUCE.NE.1. .AND. JOBNUM.GT.1 .AND. (.NOT. STHLP))
      $      CALL REDCOR (POPNUM,POP1,ND,N,RNE,NCHARG,REDUCE)
  
 C***  PRINTOUT POP. NUMBERS (IF REQUESTED)
@@ -945,15 +1049,20 @@
  
 C***  PRINTOUT RELATIVE CORRECTIONS 
       IF ((JOBNUM .GT. 5 .OR. JOBNUM .GT. 1 .AND. .NOT. STHLP) .AND. 
-     >     BPRICORR)
-     $      CALL PRICORR (POPNUM, POP1, LEVEL, N, ND, MODHEAD, LSPOP, 
-     $                   CORMAX, RTCMAX, JOBNUM, REDUCE, 
+     >     BPRICORR) THEN
+            CALL PRICORR (POPNUM, POP1, LEVEL, N, ND, MODHEAD, LSPOP, 
+     $                   CORMAX, RTCMAX, JOBNUM, REDUCE, CKONVER,
      >                   GAMMAC, GAMMAL, GAMMAR, GAMMAD, 
      $                   TOLD, TNEW, EPSILON, DELTAC, SMALLPOP, BUNLU, 
-     $                   DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, 
-     >                   bTDIFFUS,  TNDCORR, HNDCORFAC, GAHIST, MAXGAHIST, 
-     >                   STHLP, IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP,
-     >                   TBTAU, TAUINT)
+     >                   DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB,
+     >                   bTDIFFUS, TNDCORR, HNDCORFAC, GAHIST, 
+     >                   MAXGAHIST, STHLP, ICMMODE,
+     >                   IWARN_NEG_XJCAPP, IWARN_NEG_XJLAPP, 
+     >                   TBTAU, TAUINT, NDOUT, NATOM, NOM, TRACEELEM)
+     
+      ELSEIF (ITWARN > 0) THEN
+        WRITE (hCPR,*) 'ITWARN =', ITWARN
+      ENDIF
 
 C*** INHIBIT SMALL OR NEGATIVE POP. NUMBERS (WARNINGS ISSUED!)
       CALL INHIBIT (POPNUM, N, ND, NCHARG, RNE, 
@@ -1038,11 +1147,11 @@
      >                           RSTAR, XLOGL, XMDOT, RTRANS, VELO, 
      >                           VDOP, DENSCON, FILLFAC, GLOG, GEFFLOG,
      >                           GEDD, RADIUS, RCON, INCRIT, VCRIT,
-     >                           VTURB, bThinWind, bHYDROSOLVE, 
+     >                           VTURB, VMACH, bThinWind, bHYDROSOLVE, 
      >                           WORKRATIO, RNE, ENTOT, XMU, XMSTAR, 
      >                           GRADI, NATOM, ABXYZ, ATMASS, ELEMENT,
-     >                           SYMBOL, bFULLHYDROSTAT, 
-     >                           GEDDRAD, ARAD, APRESS, AGRAV, 
+     >                           SYMBOL, bFULLHYDROSTAT, MAXATOM, KODAT,
+     >                           GEDDRAD, ARAD, APRESS, AGRAV, HTOTOBS,
      >                           GAMMARADMEAN, QIONMEAN, bFixGEFF)
       ELSEIF (bNoARAD) THEN
         WRITE (hCPR,'(A)') 'WARNING: *** MODEL SUMMARY NOT POSSIBLE: '
@@ -1094,9 +1203,24 @@
          IF (ACTPAR .EQ. 'ACC') THEN
            CALL PLOTACC (PLOTOPT(IPLOTOPT), AGRAV, AMECH, ARAD, APRESS, 
      >                   ACONT, ATHOM, WORKRATIO, VELO, RADIUS, ND, 
-     >                   ATMEAN, RNE, RCON, TNEW, TEFF, RSTAR, XMU,
-     >                   XMSTAR, Rcritical, bFULLHYDROSTAT,
-     >                   MODHEAD, JOBNUM, KANAL, HYSTACC)
+     >                   ATMEAN, ENTOT, RNE, TAUROSS, RCON, TNEW, TEFF, 
+     >                   RSTAR, XMU, VTURB, XMSTAR, Rcritical, 
+     >                   bFULLHYDROSTAT, bNoARAD,
+     >                   MODHEAD, JOBNUM, KANAL)
+         ENDIF
+
+C***     *************
+C***     *  ACCELEM  *
+C***     *************
+         IF (ACTPAR == 'ACCELEM') THEN
+           CALL PLOTACCELEM (PLOTOPT(IPLOTOPT), AGRAV, AMECH, ARAD, 
+     >                       ARADELEM, ACONTELEM, ARADION, ACONTION,
+     >                       APRESS, ACONT, ATHOM, WORKRATIO,
+     >                       VELO, RADIUS, ND, NATOM, MAXION,
+     >                       ATMEAN, ENTOT, RNE, TAUROSS, RCON, TNEW,
+     >                       TEFF, RSTAR, XMU, XMSTAR, 
+     >                       Rcritical, bFULLHYDROSTAT, SYMBOL,
+     >                       ELEMENT, bNoARAD, MODHEAD, JOBNUM, KANAL)
          ENDIF
 
 C***     *********************
@@ -1108,49 +1232,76 @@
      >                     WORKRATIO, VELO, RADIUS, ND, ATMEAN,
      >                     ENTOT, RNE, RCON, TNEW, TEFF, RSTAR, XMU,
      >                     XMSTAR, Rcritical, bFULLHYDROSTAT,
-     >                     QIONMEAN, GAMMARADMEAN,
+     >                     QIONMEAN, GAMMARADMEAN, bNoARAD,
      >                     MODHEAD, JOBNUM, KANAL)
          ENDIF
          
+C***     ***********************
+C***     *  FG STRATIFICATION  *
+C***     ***********************
+         IF (ACTPAR == 'FGSTRAT') THEN
+           CALL PLOTFGADAPTER (PLOTOPT(IPLOTOPT), XMSTAR, TAUROSS, ARAD, 
+     >                         VELO, RADIUS, ND, ATMEAN, ENTOT, TNEW, 
+     >                         VTURB, XMU, RSTAR, Rcritical, WORKRATIO,
+     >                         bNoARAD, MODHEAD, JOBNUM, KANAL)
+         ENDIF
+         
+C***     **********************
+C***     *  FORCE MULTIPLIER  *
+C***     **********************
+         IF (ACTPAR == 'FORCEMULT') THEN
+           CALL PLOTFORCEMULT (PLOTOPT(IPLOTOPT), TAUROSS, TAUROSScont,
+     >                         AGRAV, AMECH, ARAD, APRESS, ACONT, ATHOM, 
+     >                         VELO, RADIUS, ND, ATMEAN, ENTOT, TNEW, 
+     >                         XMU, RCON, Rcritical, WORKRATIO,
+     >                         bNoARAD, MODHEAD, JOBNUM, KANAL)
+         ENDIF
+         
 C***     **********
 C***     *  UNLU  *
 C***     **********
          IF (ACTPAR == 'UNLU' .AND. BUNLU) THEN
            CALL PLOTUNLU (KANAL, PLOTOPT(IPLOTOPT), MODHEAD, JOBNUM, 
-     >                    ND, TOLD, TNEW, DUNLU_LOC, DUNLU_TB, bTDIFFUS,
-     >                    DTLOCAL, DTINT, DTRMAX, DTKUBAT)
+     >                    ND, TOLD, TNEW, bKUBAT, bLOCAL, 
+     >                    bINT, bRMAX, bTDIFFUS, DTLOCAL, DTINT, 
+     >                    DTRMAX, DTKUBAT, EXPTAUTCL)
          ENDIF
 
 C***     **********
 C***     *  HTOT  *
 C***     **********
          IF (ACTPAR .EQ. 'HTOT') 
-     >     CALL PLOTHSUM (HTOTL, HTOTM, HTOTG, HTOTOBS, HTOTCMF0,
-     >                    ND, MODHEAD, JOBNUM, KANAL, TEFF, BHTOTERR,
-     >                    FLUXEPS)
+     >     CALL PLOTHSUM (HTOTL, HTOTND, EDDIHOUTJMEAN, XJTOTL, HTOTM,
+     >                    HTOTG, HTOTOBS, HTOTCMF0, HTOTCMF0ADV,
+     >                    FLUXEPS, ND, MODHEAD, JOBNUM, KANAL, TEFF, 
+     >                    BHTOTERR, bINCADV)
 
 C***     **********
 C***     *  FLUX  *
 C***     **********
          IF (ACTPAR .EQ. 'FLUX') 
-     >      CALL PLOTFLU (NF, XLAMBDA, EMFLUX, EMCOLI, MODHEAD, JOBNUM, 
-     >                    KANAL, RSTAR, TOTOUT, PLOTOPT(IPLOTOPT))
+     >      CALL PLOTFLU (NF, XLAMBDA, EMFLUX, EMCOLI, MODHEAD, 
+     >                    JOBNUM, KANAL, RSTAR, TOTOUT, 
+     >                    PLOTOPT(IPLOTOPT))
 
 C***     **********
 C***     *  ALPHA *
 C***     **********
          IF (ACTPAR == 'ALPHA')
-     >     CALL PLOTALPHA(ND, RADIUS, ALPHAF, MODHEAD, JOBNUM, .FALSE.)
-     
+     >     CALL PLOTALPHA(PLOTOPT(IPLOTOPT), ND, RADIUS, ALPHAF,
+     >                    VMACH, VELO, TAUROSS, ENTOT, ATMEAN, 
+     >                    MODHEAD, JOBNUM, .FALSE.)
 C***     ************
 C***     *  SIGMAFE *
 C***     ************
-         IF (ACTPAR == 'SIGMAFE' .AND. JOBNUM >= 11) THEN
+         IF (ACTPAR == 'SIGMAFE' .AND. JOBNUM > 1) THEN
            CALL PLOTSIGMAFE(PLOTOPT(IPLOTOPT), MODHEAD, JOBNUM,
      >                      SIGMAFE, INDRB, MAXFEIND, 
      >                      LASTINDALL, LASTFE, IFRBSTA, IFRBEND, 
-     >                      LEVEL, N, INDNUP, INDLOW,
-     >                      INDEXMAX, NFEREADMAX,
+     >                      LASTKON, INDRF, KONTLOW, KONTNUP,
+     >                      LEVEL, N, INDNUP, INDLOW, NOM,
+     >                      ELEVEL, EION,
+     >                      INDEXMAX, NFEREADMAX, MAXATOM, KODAT,
      >                      VDOPFE, DXFE, XLAM0FE, .FALSE.)
          ENDIF
       ENDDO
@@ -1173,6 +1324,8 @@
 
 C***  DIRECT TRANSFER OF TEMPERATURE STRATIFICATION PLOT (IF REQUESTED)
       IF (TPLOT) THEN
+cc      IF (NTPLOT > 0) THEN
+cc        DO ITPLOT=1, NTPLOT
 C         IF ((LSTAU .LE. 0) .AND. TPLTAU)
 C     $       CALL TAUSCAL (RSTAR,ND,RADIUS,RNE,
 C     $            ENTOT,TNEW,POPNUM,NDIM,N,EN,LEVEL,NCHARG,WEIGHT,
@@ -1180,9 +1333,9 @@
 C     $            ADDCON1, ADDCON2, ADDCON3, 
 C     $            IGAUNT,NOM,NF,
 C     $            XLAMBDA,FWEIGHT,TAUTHOM,TAUROSScont,
-C     $            MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-C     $            KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC)
-         CALL PLOTT (TPLOTOPT, ND, RADIUS, TAUROSS, TNEW,
+C     $            MAXATOM,MAXION,SIGMATHK,SEXPOK,EDGEK,KODAT,
+C     $            KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC, POPMIN)
+         CALL PLOTT (TPLOTOPT, ND, RADIUS, TAUROSS, TNEW, ENTOT,
      >               MODHEAD, JOBNUM, KANAL, BINBOX, UNLUTECLINE)
       ENDIF
 
@@ -1210,7 +1363,24 @@
         IF (IERR == -10) NTOLD = 1
       ENDIF
 
-      IF (JOBNUM > 1 ) THEN
+      !bHYDROSOLVE = .FALSE. !deactivate calls so far
+      IF ((bHYDROSOLVE .OR. bHydroHelp) .AND. (JOBNUM > 1)) THEN
+          WRITE (hCPR, '(A)') 
+     >       '*** WARNING: HYDROSOLVE NOT INCLUDED IN THIS BRANCH'
+C***      -- THIS WOULD BE THE LOCATION OF THE HYDROSOLVE CALL --
+          bHydroDone = .FALSE.
+          IF (bHydroDone) THEN
+            VMIN = VELO(ND)         !ensure updated VMIN after hydro
+            bUpdateVT = .TRUE.
+          ENDIF
+          bSaveTauCont = .TRUE.
+          IF (.NOT. bHydroHelp) THEN
+C***        Do not run ENSURETAUMAX iteration together with HYDROSOLVE
+            bENSURETAUMAX = .FALSE. 
+          ENDIF
+      ENDIF
+
+      IF (JOBNUM > 1) THEN
           !ensures that the TAUMAX value given in the CARDS file is still reached at the inner boundary
           ! do not do this for the steal job that is run right after WRSTART (JOB = 1) because the
           ! adapter should be finished before this subroutine is called
@@ -1219,26 +1389,32 @@
      >              TAUMAX, TAUACC, bTauStrict,
      >              VMIN, VELO, GRADI, RADIUS, XMDOT, GEDDRAD,
      >              RHO, TAUROSScont, RMAX, RCON, TNEW, TEFF,
-     >              TOLD, TOLD2, TOLD3, CKONVER, bTauMaxSafe,
+     >              TOLD, TOLD2, TOLD3, CKONVER, TaumaxCard, 
      >              LASTTAU, GLOG, GEFFLOG, bFixGEFF, XMSTAR, RSTAR, 
      >              XMU, ENTOT, RNE, ND, NDDIM, NP, NPDIM, P, Z, VTURB,
-     >              ARAD, APRESS, AMECH, AGRAV, XJC, bThinWind, 
+     >              VMACH, ARAD, APRESS, AMECH, AGRAV, XJC, bThinWind, 
      >              ThinCard, RadiusGridParameters, DENSCON, FILLFAC, 
      >              DENSCON_FIX, DENSCON_LINE, NFIRST, NLAST, NATOM, 
-     >              ABXYZ, ATMASS, GEDD, BUNLU, HTOTL, HTOTCMF0, 
-     >              FQLIMIT, bFULLHYDROSTAT, bGAMMARADMEAN, TAUROSS,
-     >              CORMAX, TauCorLimits, INCRIT, VCRIT, SCRATCH,
-     >              ReduceTauCorrections, GEDDreduce, QIONMEAN,
+     >              ABXYZ, ATMASS, GEDD, BUNLU, HTOTL, HTOTCMF0, HMEAN,
+     >              bFULLHYDROSTAT, bGAMMARADMEAN, TAUROSS,
+     >              CORMAX, INCRIT, VCRIT, SCRATCH,
+     >              GEDDreduce, QIONMEAN,
      >              GAMMARADMEAN, GRSTATIC, bGEddFix, bTauUpdated, 
-     >              JOBNUM, POPMIN, XJCorg, NCOLIP, NEWWRC,
-     >              NTOLD, DEPARTNDorg,
+     >              JOBNUM, POPMIN, MacroDamp, bNoARAD,
+     >              bTMNoOS, bHYSTloose, bTMTHOM,
+     >              NCOLIP, NEWWRC, NTOLD, DEPARTNDorg,
+C                   Backup and temporary arrays     
+     >              VELOorg, RADIUSorg, ENTOTorg, TAUSCALorg,
+     >              Torg, T1old, T2old, T3old, RI, AMACHorg,
+     >              RNEorg, GEFFLnew, GEFFL, GAMMARAD, 
+     >              RNEdummy, RHELP, ARADHELP, VHELP, XJCorg,
                     !The parameters hereafter are only needed for TAUSCAL
      >              NDIM,MAXKONT,POPNUM,POP1,POP2,POP3,N,EN,LEVEL,
      >              NCHARG,WEIGHT,ELEVEL,EION,EINST,ALPHA,SEXPO,
      >              ADDCON1, ADDCON2, ADDCON3, 
      >              IGAUNT,NOM,NF,
      >              XLAMBDA,FWEIGHT,TAUTHOM,
-     >              MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
+     >              MAXATOM,MAXION,SIGMATHK,SEXPOK,EDGEK,KODAT,
      >              KONTNUP,KONTLOW,LASTKON
      >    )
           bSaveTauCont = .TRUE.
@@ -1268,6 +1444,7 @@
 
       IF (bSaveTauCont .AND. (TAUROSScont(ND) > 0.)) THEN
         CALL WRITMS(hMODEL,TAUROSScont,ND,'TAURCONT',-1,IDUMMY,IERR)
+        CALL WRITMS(hMODEL,TAUTHOM,    ND,'TAUTHOM ',-1,IDUMMY,IERR)
       ENDIF
 
       IF (DTDRIN >= 0.) THEN
@@ -1313,7 +1490,11 @@
           CALL WRITMS (hMODEL,RCON,1 ,   'RCON    ', -1, IDUMMY, IERR)
       ENDIF
       IF (bHydroDone) THEN
-        CALL WRITMS (hMODEL,RCSAVE,1 , 'RCSAVE  ', -1, IDUMMY, IERR)
+        CALL WRITMS (hMODEL, TAUHDRAW, 1, 'TAUHDRAW', -1, IDUMMY, IERR)
+        CALL WRITMS (hMODEL, RCSAVE,   1, 'RCSAVE  ', -1, IDUMMY, IERR)
+        CALL WRITMS (hMODEL, ARAD,  ND-1, 'ARAD    ', -1, IDUMMY, IERR)
+        CALL WRITMS (hMODEL, GRDYN,   ND, 'GRDYN   ', -1, IDUMMY, IERR)     
+        bForceColiPP = .TRUE.
       ENDIF
       CALL WRITMS (hMODEL,VELO,ND,   'VELO    ', -1, IDUMMY, IERR)
       CALL WRITMS (hMODEL,GRADI,ND,  'GRADI   ', -1, IDUMMY, IERR)
@@ -1322,19 +1503,28 @@
       IF (bTauUpdated .OR. bUpdateMass) THEN
         !In case of fixed g_eff => save updated Mass ang log g_grav
         IF (bUpdateMass .OR. bFixGEFF) THEN
+          CALL WRITMS (hMODEL,RSTAR ,1 , 'RSTAR   ', -1, IDUMMY, IERR)
           CALL WRITMS (hMODEL,XMSTAR,1 , 'XMSTAR  ', -1, IDUMMY, IERR)
           CALL WRITMS (hMODEL,GLOG  ,1 , 'GLOG    ', -1, IDUMMY, IERR)
+          WRITE (hCPR, '(A)') '*** Mass and/or Radius have been updated:'
+          WRITE (hCPR, '(A,F5.2)') '*** new mass:   ', XMSTAR
+          WRITE (hCPR, '(A,F5.2)') '*** new radius: ', RSTAR/RSUN
+          WRITE (hCPR, '(A,F5.2)') '*** new log g:  ', GLOG
         ELSEIF (.NOT. bFixGEFF) THEN
           !GEDD fixed, but not GEFF => save new g_eff, but with flexible mark (negative)
           GFLSAV = -1. * GEFFLOG
           CALL WRITMS (hMODEL,GFLSAV,1 , 'GEFFLOG ', -1, IDUMMY, IERR)
         ENDIF
       ENDIF
-      
-C      IF (bTauUpdated .AND. bFULLHYDROSTAT) THEN
-C        NCOLIP = -1     !force COLI++ (i.e. new EDDIS) due to changes and a_rad-dependency
-C        CALL WRITMS(hMODEL, NCOLIP, 1,'NCOLIP  ', -1, IDUMMY, IERR)
-C      ENDIF
+      IF (bUpdateTEFF) THEN
+        CALL WRITMS (hMODEL, TEFF, 1, 'TEFF    ', -1, IDUMMY, IERR)
+      ENDIF
+      IF (bUpdateVT) THEN
+        DO L=1, ND
+          VMIC(L) = VTURB(L) * SQRT(2.)
+        ENDDO
+        CALL WRITMS (hMODEL, VMIC, ND, 'VMIC    ', -1, IDUMMY, IERR)
+      ENDIF
 
       IF (NEXTHYDRO > 0) THEN
         !If used, update hydro iteration counter
@@ -1347,9 +1537,18 @@
       ENDIF
       
       IF (bHydroDone) THEN
+        LASTHYDGA = 1
+        IF (HydroValues(3) > 0.5) THEN
+          !Switch off AUTO GAMMA if velocity corrections larger than 0.5
+          LASTHYDGA = 0
+        ENDIF
         !This is only written after a successful hydro iteration
+        CALL WRITMS (hMODEL,HYDROF,ND,'HYDROF  ',-1,IDUMMY,IERR)
         CALL WRITMS (hMODEL,LASTHYDRO,1,'LSTHYDRO',-1,IDUMMY,IERR)
+        CALL WRITMS (hMODEL,LASTHYDGA,1,'LSTHYDGA',-1,IDUMMY,IERR)
         CALL WRITMS (hMODEL,XMDOT,1 , 'XMDOT   ', -1, IDUMMY, IERR)        
+        CALL WRITMS (hMODEL,CORDELTAHDLAST, 1, 'CODHDLST',
+     >                                          -1, IDUMMY, IERR)        
         !update continous radiation field (has been interpolated)
         DO K=1, NF
           KV=1+ND*(K-1)
@@ -1378,13 +1577,13 @@
       CALL WRITMS (hMODEL,LASTBACKUP,1, 'LASTBAK ', -1, IDUMMY, IERR)
       
 C***  UPDATING THE MODEL HISTORY
-      CALL       STHIST (MODHIST, LAST, MAXHIST, GAMMAC, GAMMAL, GAMMAR, 
-     >                   GAMMAD, MODHEAD, JOBNUM, CORMAX, RTCMAX,
-     $                   REDUCE, NSCHAR, BUNLU, DUNLU_LOC, DUNLU_INT, 
-     >                   DUNLU_RMAX, DUNLU_TB,
-     >                   BXJLAPPNEW, BXJCAPPNEW, bBLOCKINVERSION,
-     >                   XLAM_FINE_START, XLAM_FINE_END, bHydroDone,
-     >                   bTauUpdated)
+      CALL       STHIST (MODHIST,LAST,MAXHIST,GAMMAC,GAMMAL,GAMMAR,
+     >                   GAMMAD, DELTAC,MODHEAD,JOBNUM,CORMAX,RTCMAX,
+     >                   REDUCE, NSCHAR, BUNLU, 
+     >                   DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB,
+     >                   BXJLAPPNEW, BXJCAPPNEW, iBLOCKINVERSION,
+     >                   XLAM_FINE_START, XLAM_FINE_END, LASTHYDRO,
+     >                   HydroValues, bTauUpdated)
 
       IF (.NOT. bHLPHIST) THEN
         !write model history entry into explicit history file
@@ -1409,7 +1608,15 @@
       CALL NEXTJOB (JOBNUM, JOBMAX, MODHIST, LAST, CORMAX, EPSILON,
      >              NEWWRC, MOREJOBS, CONVERG, NOEXTRAP, NOCON, 
      >              BPRICORR, COREX, BCOREX, NCOLIP, BAG, BGFIN, 
-     >              BAUTO_ABORT, FLUXEPS, ND, FLUXERR, IHSSTATUS)
+     >              BAUTO_ABORT, FLUXEPS, ND, FLUXERR, IHSSTATUS,
+     >              IHDSTATUS, bRESTART, bHYDROSOLVE, bHydroHelp)
+      IF (bHydroHelp) THEN
+        NEXTHYDRO = -13     !indicates one-time analysis of hydro values for converged model
+        CALL WRITMS (hMODEL,NEXTHYDRO,1,'NXTHYDRO',-1,IDUMMY,IERR)
+      ELSEIF (NEXTHYDRO == -13) THEN
+        NEXTHYDRO = -1      !switch off hydro indication value afterwards
+        CALL WRITMS (hMODEL,NEXTHYDRO,1,'NXTHYDRO',-1,IDUMMY,IERR)
+      ENDIF
 
 C***  SECOND ENTRY FOR OUTPUT-ONLY (STEAL-HELP)
   26  CONTINUE
@@ -1431,6 +1638,10 @@
         CALL WRITMS (hMODEL,MODHIST,MAXHIST,'MODHIST ',-1, IDUMMY, IERR)
       ENDIF
    
+      !Even though POPMIN is read from CARDS, current POPMIN has to be 
+      ! written to model file as it needs to be known for the formal integral
+      CALL WRITMS (hMODEL,POPMIN_org,1,   'POPMIN  ',-1, IDUMMY, IERR)
+   
       IF (JOBNUM == 1) GOTO 27
 
 C********* final PLOTs and printouts *******************
@@ -1457,8 +1668,9 @@
      >                   ADDCON1, ADDCON2, ADDCON3, 
      >                   IGAUNT,NOM,NF,
      >                   XLAMBDA,FWEIGHT,TAUTHOM,TAUROSScont,
-     >                   MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-     >                   KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC)
+     >                   MAXATOM,MAXION,SIGMATHK,SEXPOK,EDGEK,KODAT,
+     >                   KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC, 
+     >                   POPMIN)
          ENDIF
          LSTAU=1 !print all depth points after model is converged
          CALL PRITAU (LSTAU,MODHEAD,JOBNUM,ND,RADIUS,RNE,
@@ -1471,11 +1683,11 @@
      >                           RSTAR, XLOGL, XMDOT, RTRANS, VELO, 
      >                           VDOP, DENSCON, FILLFAC, GLOG, GEFFLOG,
      >                           GEDD, RADIUS, RCON, INCRIT, VCRIT,
-     >                           VTURB, bThinWind, bHYDROSOLVE, 
+     >                           VTURB, VMACH, bThinWind, bHYDROSOLVE, 
      >                           WORKRATIO, RNE, ENTOT, XMU, XMSTAR,
      >                           GRADI, NATOM, ABXYZ, ATMASS, ELEMENT,
-     >                           SYMBOL, bFULLHYDROSTAT, 
-     >                           GEDDRAD, ARAD, APRESS, AGRAV, 
+     >                           SYMBOL, bFULLHYDROSTAT, MAXATOM, KODAT,
+     >                           GEDDRAD, ARAD, APRESS, AGRAV, HTOTOBS,
      >                           GAMMARADMEAN, QIONMEAN, bFixGEFF)
          ELSEIF (bNoARAD) THEN
            WRITE (hCPR,'(A)') 'WARNING: *** MODEL SUMMARY NOT POSSIBLE:'
@@ -1505,8 +1717,9 @@
      >                  ADDCON1, ADDCON2, ADDCON3, 
      >                  IGAUNT,NOM,NF,
      >                  XLAMBDA,FWEIGHT,TAUTHOM,TAUROSScont,
-     >                  MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-     >                  KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC)
+     >                  MAXATOM,MAXION,SIGMATHK,SEXPOK,EDGEK,KODAT,
+     >                  KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC,
+     >                  POPMIN)
           CALL PRITAU (LSTAU,MODHEAD,JOBNUM,ND,RADIUS,RNE,
      >                 ENTOT,TNEW,TAUTHOM,TAUROSS,TAUROSScont,
      >                 DENSCON,FILLFAC)
@@ -1532,7 +1745,7 @@
 
 C***  PRINTOUT OF EMERGENT CONT. FLUX (IF REQUESTED)
         IF (IFLUX == 1) THEN
-          IF (TOTOUT .EQ. -999. ) THEN
+          IF (TOTOUT == TRANSFER ('UNDEF.   ', TOTOUT)) THEN
             PRINT 7
     7       FORMAT (//' INVALID PRINT OR PLOT OPTION - ',
      >      'EMERGENT CONT. FLUX NOT YET CALCULATED ',//)
@@ -1548,7 +1761,7 @@
      >                  KEY,NF,ALPHA,SEXPO,
      >                  ADDCON1, ADDCON2, ADDCON3, 
      >                  IGAUNT,SIGMATHK,SEXPOK,EDGEK, MAXATOM,
-     >                  COCO,KEYCBB,ALTESUM,
+     >                  MAXION, COCO,KEYCBB,ALTESUM,
      >                  NATOUT,NATOM,ELEMENT,NOM,ABXYZ,ATMASS,
      >                  NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,IONAUTO,
      >                  INDNUP,INDLOW,LASTIND,LASTINDALL,IONGRND,
diff -bur ./sthist.f ../../powr-refactor/src/sthist.f
--- ./sthist.f	2024-07-28 13:14:36.000000000 +0200
+++ ../../powr-refactor/src/sthist.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,10 +1,10 @@
-      SUBROUTINE STHIST (MODHIST, LAST, MAXHIST, GAMMAC, GAMMAL, GAMMAR,
-     >                   GAMMAD, MODHEAD, JOBNUM, CORMAX, RTCMAX,
+      SUBROUTINE STHIST (MODHIST,LAST,MAXHIST,GAMMAC,GAMMAL,GAMMAR,
+     >                   GAMMAD, DELTAC,MODHEAD,JOBNUM,CORMAX,RTCMAX,
      >                   REDUCE, NSCHAR, BUNLU, 
      >                   DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, 
-     >                   BXJLAPPNEW, BXJCAPPNEW, bBLOCKINVERSION,
-     >                   XLAM_FINE_START, XLAM_FINE_END, bHydroDone, 
-     >                   bTauUpdated)
+     >                   BXJLAPPNEW, BXJCAPPNEW, iBLOCKINVERSION,
+     >                   XLAM_FINE_START, XLAM_FINE_END, LASTHYDRO,
+     >                   HydroValues, bTauUpdated)
 C***********************************************************************
 C***  UPDATING THE MODEL HISTORY FOR MAIN PROGRAM STEAL
 C***********************************************************************
@@ -14,12 +14,12 @@
 C***  MAXENTRY = MAXIMUM SPACE NEEDED BY THE NEXT REPEAT CYCLE.
 C***   (MAXENTRY SHOULD BE GREATER THAN THE NUMBER OF NON-RUDIMENTAL LINES)
       INTEGER, PARAMETER :: MAXENTRY = 1000
-      INTEGER :: JOBNUM, NSCHAR, MAXHIST, LAST, LENGTH, IDX,
+      INTEGER :: JOBNUM, NSCHAR, MAXHIST, LAST, LENGTH,
      >           LBACK, LASTWRC, LASTCOM, LASTNEW, LNEW,
-     >           IOLD, INEW, NRFOUND,
+     >           IOLD, INEW, NRFOUND, LASTHYDRO, iBLOCKINVERSION,
      >           ISTART, IEND, LASTWHATEVER, LASTCHAR, I, J
 
-
+      INTEGER, EXTERNAL :: IDX
 
       REAL :: GAMMAC, GAMMAL, GAMMAR, GAMMAD,
      >        DELTAC, CORMAX, RTCMAX, REDUCE,
@@ -27,6 +27,8 @@
      >        DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB, 
      >        XLAM_FINE_START, XLAM_FINE_END
 
+      REAL, DIMENSION(3) :: HydroValues         !1 = log MDOT, 2 = VINF in km/s, 3 = CORRMAX
+     
       CHARACTER(8*MAXHIST) :: MODHIST
       CHARACTER(100) :: MODHEAD
       CHARACTER(88) :: BUFFER88
@@ -35,8 +37,7 @@
       CHARACTER(16) :: BUFFER16
       CHARACTER(8) :: MAXCOR, BUFFER8
       CHARACTER(2) :: C2
-      LOGICAL :: BUNLU, BXJCAPPNEW, BXJLAPPNEW, bHydroDone, 
-     >           bBLOCKINVERSION, bTauUpdated
+      LOGICAL :: BUNLU, BXJCAPPNEW, BXJLAPPNEW, bTauUpdated
  
       MAXCOR='UNDEF.  '
       IF (JOBNUM > 1) THEN
@@ -104,8 +105,12 @@
         CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,16,BUFFER16)
       ENDIF
 
-      IF (bBLOCKINVERSION) THEN
+      IF (iBLOCKINVERSION > 0) THEN
+        IF (iBLOCKINVERSION == 2) THEN
+          WRITE(UNIT=BUFFER8, FMT='(A8)') ' ISPLIT '
+        ELSE
         WRITE(UNIT=BUFFER8, FMT='(A8)') ' SPLIT  '
+        ENDIF
         CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
       ENDIF
 
@@ -114,8 +119,14 @@
         CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
       ENDIF
 
-      IF (bHydroDone) THEN
-        WRITE(UNIT=BUFFER8, FMT='(A8)') ' HYDRO  '
+      IF (LASTHYDRO == 0) THEN
+        WRITE(UNIT=BUFFER8, FMT='(A8)') ' HYDRO ('
+        CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
+        WRITE(UNIT=BUFFER8, FMT='(F8.3)') HydroValues(1)
+        CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
+        WRITE(UNIT=BUFFER8, FMT='(A1,F7.1)') ';', HydroValues(2)
+        CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
+        WRITE(UNIT=BUFFER8, FMT='(A1,F6.3,A1)') ';', HydroValues(3), ')'
         CALL ADDHISTENTRY(MODHIST,LAST,MAXHIST,8,BUFFER8)
       ENDIF
       
diff -bur ./storage.f ../../powr-refactor/src/storage.f
--- ./storage.f	2024-07-28 13:14:36.000000000 +0200
+++ ../../powr-refactor/src/storage.f	2024-07-22 09:27:16.108033925 +0200
@@ -14,6 +14,9 @@
 
 C***  IRECL : RECORD LENGTH OF THE FILE OPENENED BY FORTRAN. THE VARIABLE 
 C***                     LENGTH IS 4 BYTE
+C***   => changed with compiler parameter "assume byterecl" to be compartible with gfortran
+C***  IADRL = IRECL / 2, BECAUSE ALL VARIABLES, EVEN THE CHARACTERS, SHOULD 
+C***                     HAVE 8 BYTE
 
 C***  Variable-names have 8 Characters. Note that the Character ^ is not valid
 C***    because it is used to transport blanks from the MSFILE plotutility
@@ -36,12 +39,12 @@
       CHARACTER(1) :: CKIND
       CHARACTER(7) :: CSTATUS, FN
       CHARACTER(8) :: ACTION, MODE, KSTR, KINDSTR, CNAME, CNAME2
-      CHARACTER(10) :: FMTSTR
+      CHARACTER(10) :: FMTSTR, CACTION
 
-      REAL :: RDUMMY
-      INTEGER :: IKIND, IDEFKIND, NDIMR, LFMT, IFMTLEN
+      REAL :: RDUMMY, RSCRATCH
+      INTEGER :: IKIND, IDEFKIND, NDIMR, LFMT, IFMTLEN, INTSCRATCH
 
-      LOGICAL BEXIST, BVARKN, BDIMEQ, BNEWKINDINFO
+      LOGICAL BEXIST, BVARKN, BDIMEQ, BNEWKINDINFO, bWRINT
 
       INTEGER, EXTERNAL :: IDX  !function to obtain the (non-blank) length of a string
 
@@ -123,12 +126,16 @@
 
 C***  CHECK IF FILE DOES EXIST
         INQUIRE (FILE=FN, EXIST=BEXIST)
+        CACTION = 'READWRITE'
         IF (CNAME == 'AUTO') THEN
           IF (BEXIST) THEN
             CSTATUS = 'OLD'
           ELSE
             CSTATUS = 'NEW'
           ENDIF
+        ELSEIF (CNAME == 'READ') THEN
+          CSTATUS = 'OLD'
+          CACTION = 'READ'
         ELSE
           CSTATUS = CNAME(1:7)
           IF ((CSTATUS == 'REPLACE') .OR. (CSTATUS(1:3) == 'NEW')) THEN
@@ -142,6 +149,7 @@
      >        FORM='UNFORMATTED',
      >        RECL=IRECL,
      >        STATUS=CSTATUS,
+     >        ACTION=CACTION,
      >        ERR=90,
      >        IOSTAT=IOS)
 
@@ -604,7 +612,7 @@
         ENDDO
    44   CONTINUE
         IF (.NOT. BVARKN) THEN
-          WRITE (0,'(3A)') 'Variable ',NAME, ' not known'
+          WRITE (0,'(3A)') 'Variable ',CNAME, ' not known'
           STOP 'ERROR WHEN ACTION = INFO-D'
         ENDIF
         IERR = 0
@@ -651,6 +659,7 @@
         NIND3 = (INUM-1) / IADRL + 1
         NREST = INUM
         LFMT = IDX(CNAME2)
+        bWRINT = .FALSE.
         IF ((CNAME2(1:4) == 'AUTO') .OR. (CNAME2(1:4) == 'auto')) THEN
           IF (CKIND == 'I') THEN
             IFMTLEN = INT(  LOG10(2. ** FLOAT(IKIND * 8)) + 2. )
@@ -677,6 +686,7 @@
           FMTSTR = CNAME2
         ENDIF
         FMTSTR = ADJUSTL(FMTSTR)
+        IF (FMTSTR(1:2) == '(I') bWRINT = .TRUE.
         WRITE (*,*) 'N=?'
         DO I=1, NIND3
           IF (CKIND /= ' ') THEN
@@ -684,13 +694,21 @@
      >              SCRATCHBYTE
             INDEX = (I-1) * IADRL
             DO J=1, MIN(IADRL, NREST), IKIND
-              WRITE (*,TRIM(FMTSTR)) (SCRATCHBYTE(JJ), JJ=J, J+IKIND-1)
+              WRITE (*,FMT=TRIM(FMTSTR)) (SCRATCHBYTE(JJ), 
+     >                                    JJ=J, J+IKIND-1)
             ENDDO
           ELSE
             READ(UNIT=ICHANNEL, REC=(IFIRST-1+I), ERR=94, IOSTAT=IOS)
      >              SCRATCH
             INDEX = (I-1) * IADRL
-            WRITE (*,TRIM(FMTSTR)) (SCRATCH(J), J=1, MIN(IADRL, NREST))
+            DO J=1, MIN(IADRL, NREST)    
+              IF (bWRINT) THEN
+                INTSCRATCH = TRANSFER(SCRATCH(J), INTSCRATCH)
+                WRITE (*,FMT=TRIM(FMTSTR)) INTSCRATCH
+              ELSE 
+                WRITE (*,FMT=TRIM(FMTSTR)) SCRATCH(J)
+              ENDIF               
+            ENDDO
           ENDIF
           NREST = NREST - IADRL
         ENDDO
@@ -710,15 +728,19 @@
       GOTO 99
 
    91 WRITE (0,*) ' ERROR WHEN READING MASS-STORAGE FILE (LABEL=91)'
+      WRITE (0,*) ' FILE NAME = ', FN
       GOTO 99
 
    92 WRITE (0,*) ' ERROR WHEN WRITING MASS-STORAGE FILE (LABEL=92)'
+      WRITE (0,*) ' FILE NAME = ', FN
       GOTO 99
 
    93 WRITE (0,*) ' ERROR WHEN WRITING MASS-STORAGE FILE (LABEL=93)'
+      WRITE (0,*) ' FILE NAME = ', FN
       GOTO 99
 
    94 WRITE (0,*) ' ERROR WHEN READING MASS-STORAGE FILE (LABEL=94)'
+      WRITE (0,*) ' FILE NAME = ', FN
       GOTO 99
 
 
diff -bur ./tabread.f ../../powr-refactor/src/tabread.f
--- ./tabread.f	2024-07-28 13:14:36.000000000 +0200
+++ ../../powr-refactor/src/tabread.f	2023-09-27 10:14:15.129755873 +0200
@@ -5,7 +5,6 @@
 C***  ITAB = 1: INPUT OF TABULATED TEMPERATURE STRUCTURE T(R)
 C***  ITAB = 2: INPUT OF TABULATED VELOCITY FIELD V(R)
 C***  ITAB = 3: INPUT OF T(R) AND V(R)
-C***  Called from: WRSTART
 C***********************************************************************
  
       REAL RADIUS(ND),VELO(ND),GRADI(ND),T(ND)
@@ -21,9 +20,8 @@
 
       IF (KARTE(:1) .EQ. '*' ) GOTO 1
       IF (KARTE(:5).EQ.'TABLE') THEN
-c         DECODE (80,11,KARTE) NRP,VTAB,TTAB
+         DECODE (80,11,KARTE) NRP,VTAB,TTAB
    11    FORMAT (15X,I3,7X,F7.1,7X,F8.0)
-         READ (KARTE,11) NRP,VTAB,TTAB
          IF (NRP.LE.0) THEN
             CALL REMARK ('NO TABLE INPUT')
             STOP 'ERROR'
@@ -37,9 +35,8 @@
       IF (KARTE(:7).EQ.'ENDGRID') GOTO 30
  
 C***  DECODE INPUT
-c      DECODE (80,12,KARTE) L,R(L),V(L),G(L),TH(L)
+      DECODE (80,12,KARTE) L,R(L),V(L),G(L),TH(L)
    12 FORMAT (I5,4F10.5)
-      READ (KARTE,12) L,R(L),V(L),G(L),TH(L)
       IP(L)=1
       GOTO 1
    30 CONTINUE
diff -bur ./tauscal.f ../../powr-refactor/src/tauscal.f
--- ./tauscal.f	2024-07-28 13:14:37.000000000 +0200
+++ ../../powr-refactor/src/tauscal.f	2023-09-27 10:14:15.129755873 +0200
@@ -3,19 +3,27 @@
      $                   ELEVEL,EION,EINST,ALPHA,SEXPO,
      $                   ADDCON1, ADDCON2, ADDCON3, 
      $                   IGAUNT,NOM,NF,
-     $                   XLAMBDA,FWEIGHT,TAUTHOM,TAUROSS,
-     $                   MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
-     $                   KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC)
+     >                   XLAMBDA,FWEIGHT,TAUTHOM,TAUROSS,MAXATOM,MAXION,
+     >                    SIGMATHK,SEXPOK,EDGEK,KODAT,KONTNUP,KONTLOW,
+     >                    LASTKON, DENSCON, FILLFAC, POPMIN)
 C***********************************************************************
 C***  CALCULATION OF THE NLTE OPTICAL DEPTH SCALES (ROSSELAND, THOMSON)
 C***   for continuum opacities
 C***
+C***   called from 
+C***     STEAL -> HYDROSOLVE -> TAUSCAL (3x)
+C***     STEAL -> HYDROSOLVE -> HDSOLUTION -> TAUSCAL 
+C***     STEAL -> HYDROSOLVE -> HYDROVELO -> CALCTAUCONTMAX -> TAUSCAL 
+C***     STEAL -> ENSURETAUMAX -> TAUSCAL (2x)
+C***     STEAL -> TAUSCAL (2x)
+C***     WRSTART -> TAUSCAL
+C***  
 C***  note: this routine updates the EN vector
 C***********************************************************************
  
       IMPLICIT NONE
 
-      INTEGER, INTENT(IN) :: ND, NDIM, N, MAXATOM, LASTKON, NF
+      INTEGER, INTENT(IN) :: ND, NDIM, N, MAXATOM, MAXION, LASTKON, NF
       REAL, INTENT(IN) :: RSTAR
 
       REAL, DIMENSION(ND), INTENT(IN) :: RADIUS, RNE, ENTOT, T
@@ -27,7 +35,7 @@
       REAL, DIMENSION(N, N), INTENT(IN) :: EINST
       REAL, DIMENSION(LASTKON), INTENT(IN) :: 
      >                ALPHA, SEXPO, ADDCON1, ADDCON2, ADDCON3
-      REAL, DIMENSION(MAXATOM, MAXATOM), INTENT(IN) :: 
+      REAL, DIMENSION(MAXATOM, MAXION), INTENT(IN) :: 
      >                SIGMATHK, SEXPOK, EDGEK
       REAL, DIMENSION(NF), INTENT(IN) :: FWEIGHT, XLAMBDA
       CHARACTER(10), DIMENSION(N), INTENT(IN) :: LEVEL(NDIM)
@@ -42,7 +50,7 @@
  
       INTEGER :: L, I
       REAL :: TL, RL, ENTOTDENSL, RNEL, OPAMEAN, DR, RM1, 
-     >        ENELM1, ENEL, OPARM1, OPARL, ENEMEAN, aOPARL
+     >        ENELM1, ENEL, OPARM1, OPARL, ENEMEAN, POPMIN
       LOGICAL :: bUseOPAROSSpre
 
 C***  SIGMAE = ELCTRON SCATTERING CROSS SECTION  ( CM**2 )
@@ -70,12 +78,16 @@
      >                  ALPHA,SEXPO,
      >                  ADDCON1, ADDCON2, ADDCON3, 
      >                  IGAUNT,NF,XLAMBDA,FWEIGHT,NOM,
-     >                  MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,RL,
-     >                  KONTNUP,KONTLOW,LASTKON)
+     >                  MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
+     >                  RL,KONTNUP,KONTLOW,LASTKON,POPMIN)
+ccc        WRITE(0,*) 'L, OPARL ', L, OPARL
         IF (OPARL <= 0.) THEN
           WRITE(0,*) " WARNING: negative Opacity ", OPARL
-          WRITE(0,*) '   taking absolute value... '
-          OPARL = ABS(OPARL)
+C          WRITE(0,*) '   taking absolute value... '
+C          OPARL = ABS(OPARL)
+C***       Absolute of negative value might still be desasterous
+C***       -> use Thomson only (recalculated here)
+           OPARL = SIGMAE * ENEL
         ENDIF
         OPARL = OPARL * FILLFAC(L) !downscale opacity with filling factor
         IF (L > 1) THEN
diff -bur ./tdiffus.f ../../powr-refactor/src/tdiffus.f
--- ./tdiffus.f	2024-07-28 13:14:38.000000000 +0200
+++ ../../powr-refactor/src/tdiffus.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,4 +1,5 @@
-      SUBROUTINE TDIFFUS(T, RADIUS, ND, TEFF, OPARND, TNDCORR)
+      SUBROUTINE TDIFFUS(T, RADIUS, ND, TEFF, OPARND, TNDCORR,
+     >                   bNoARAD, HTOTNDCOR, fTNDCOR)
 C***********************************************************************
 C*** Correction of the innermost temperature point via the (pure)
 C*** diffusion approximation => THIS UPDATES T(ND)
@@ -12,15 +13,21 @@
       IMPLICIT NONE
 
       INTEGER, INTENT(IN) :: ND   
-      REAL, INTENT(IN) :: TEFF, OPARND
+      REAL, INTENT(IN) :: TEFF, OPARND, HTOTNDCOR, fTNDCOR
       REAL, INTENT(INOUT) :: TNDCORR
+      LOGICAL, INTENT(IN) :: bNoARAD
       
       REAL, DIMENSION(ND), INTENT(IN) :: RADIUS
       REAL, DIMENSION(ND), INTENT(INOUT) :: T
       
-      REAL :: TSAVE, TMID, TLAST, TL, DTDR
+      REAL :: TSAVE, TMID, TLAST, TL, DTDR, DTDRplus, DTDRminus
       INTEGER :: L, ICOUNT
       
+      LOGICAL, PARAMETER :: bPRINT = .FALSE. !print debug information
+
+      !Physical constants
+      REAL, PARAMETER :: STEBOLDPI = 1.8046E-5      !Stephan-Boltzmann constant (CGS) / Pi
+      
       !File and channel handles (=KANAL)
       INTEGER, PARAMETER :: hOUT = 6        !write to wruniqX.out (stdout)
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
@@ -45,7 +52,28 @@
       
       DO
         TMID = 0.5 * (T(ND-1) + TL)
+        
+        IF ((bNoARAD .OR. HTOTNDCOR == 0.) .OR. (fTNDCOR <= 0.)) THEN
+c***      Classic version
         DTDR = 0.1875 * OPARND * TEFF*(TEFF/TMID)**3.
+        ELSE
+C***      Include inner boundary correction terms (seems to be unstable)
+C***      ( switched on by fTNDCOR > 0 via TDIFFCOR CARDS line )
+          DTDR = 0.1875 * OPARND * ( TEFF*(TEFF/TMID)**3. )
+     >            - 0.75 * OPARND/STEBOLDPI 
+     >                     * HTOTNDCOR / TMID**(3.)
+        ENDIF
+        
+C***    Debug print
+        IF (bPRINT .AND. (.NOT. bNoARAD) .AND. HTOTNDCOR /= 0.) THEN
+           DTDRplus = 0.1875 * OPARND * ( TEFF*(TEFF/TMID)**3. )
+           DTDRminus = - 0.75 * OPARND/STEBOLDPI 
+     >                     * HTOTNDCOR / TMID**(3.)
+           WRITE (hCPR,'(A,4(G15.5),2X,L1)') 'DTDR: ', 
+     >        DTDRplus, DTDRminus, DTDR, 
+     >        (T(L-1) + (RADIUS(L-1)-RADIUS(L))*DTDR ) / 1000., fTNDCOR
+        ENDIF
+        
         TLAST = TL
         
         TL = T(ND-1) + (RADIUS(ND-1)-RADIUS(ND))*DTDR
@@ -65,6 +93,11 @@
         
       ENDDO
 
+C***  optional damping of the change in T(ND)
+      IF (fTNDCOR > 0.) THEN
+        TL = TSAVE + (TL - TSAVE) * fTNDCOR
+      ENDIF
+      
 C***  Save new (converged) temperature
       T(ND) = TL
       
@@ -73,4 +106,3 @@
       
       RETURN
       END
-            
\ No newline at end of file
diff -bur ./tempcorr_expdamp.f ../../powr-refactor/src/tempcorr_expdamp.f
--- ./tempcorr_expdamp.f	2024-07-28 13:14:38.000000000 +0200
+++ ../../powr-refactor/src/tempcorr_expdamp.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,4 +1,5 @@
       SUBROUTINE TEMPCORR_EXPDAMP(TAUDAMP, METHOD, TAUROSS, bSKIPCORR, 
+     >                            bDAMPOUT, 
      >                            L, ND, DE_LOC, DE_INT, DE_RMAX, DE_TB)
 C***********************************************************************
 C***  Optional exponential tau-based damping for temperature corrections
@@ -10,7 +11,7 @@
       
       INTEGER, INTENT(IN) :: L, ND
       REAL, INTENT(IN) :: TAUDAMP
-      LOGICAL, INTENT(IN) :: bSKIPCORR
+      LOGICAL, INTENT(IN) :: bSKIPCORR, bDAMPOUT
       CHARACTER(4), INTENT(IN) :: METHOD
 
       REAL, INTENT(INOUT) :: DE_LOC, DE_INT, DE_RMAX, DE_TB
@@ -76,6 +77,15 @@
         ENDIF  
       ENDIF
                   
+C***  Option for massive additional damping in the outer part        
+        IF (bDAMPOUT) THEN
+          IF (TAUROSS(L) < 1.) THEN
+            DE_LOC = DE_LOC * EXP(10. * (TAUROSS(L) - 1.))
+            DE_INT = DE_INT * EXP(10. * (TAUROSS(L) - 1.))
+            DE_RMAX = DE_RMAX * EXP(10. * (TAUROSS(L) - 1.))
+            DE_TB = DE_TB * EXP(10. * (TAUROSS(L) - 1.))
+          ENDIF
+        ENDIF                
 
 C***    Option: In case of negative flux or arad, skip TCORR completely
         IF (bSKIPCORR) THEN
diff -bur ./tempcorr.f ../../powr-refactor/src/tempcorr.f
--- ./tempcorr.f	2024-07-28 13:14:38.000000000 +0200
+++ ../../powr-refactor/src/tempcorr.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,12 +1,14 @@
-      SUBROUTINE TEMPCORR (TOLD, TNEW, ND, RADIUS, TEFF, 
-     >           HTOTL, XJTOTL, HTOTCMF0, 
-     >           FTCOLI, DTLOCAL, DTINT, DTRMAX, FLUXERR,
+      SUBROUTINE TEMPCORR (TOLD, TNEW, ND, RADIUS, VELO, TEFF, 
+     >           VTURB, XMU, RSTAR, HTOTL, XJTOTL, HTOTCMF0, 
+     >           HTOTCMF0ADV, FTCOLI, DTLOCAL, DTINT, DTRMAX, FLUXERR,
      >           OPASMEANTC, QFJMEAN, OPAJMEANTC, OPAPMEAN,
-     >           QOPAHMEAN, EDDIHOUTJMEAN,
-     >           HTOTOUTMINUS, HTOTND, OPARND, DTDRIN, UNLUTECLINE, 
-     >           DUNLU_LOC, DUNLU_INT, DUNLU_RMAX, DUNLU_TB,
-     >           TBTAU, TAUINT, OPALAMBDAMEAN, TAUROSS, ARAD,
-     >           DTKUBAT, bTDIFFUS, HNDCORFAC, SMEAN, CORRS, FLUXEPS)          
+     >           QOPAHMEAN, QOPAHMEANL, OPARND,
+     >           EDDIHOUTJMEAN, HMEAN, HTOTCUT, SMEAN, HTOTOUTMINUS, 
+     >           HTOTND, DTDRIN, UNLUTECLINE, DUNLU_LOC, DUNLU_RMAX, 
+     >           DUNLU_INT, DUNLU_TB, TBTAU, TAUINT, EXPTAUL,
+     >           OPALAMBDAMEAN, TAUROSS, ARAD, DTKUBAT, 
+     >           bKUBAT, bLOCAL, bINT, bRMAX, bINCADV,
+     >           bTDIFFUS, HNDCORFAC, CORRS, FLUXEPS)
 C***********************************************************************
 C***  THIS SUBROUTINE APPLIES DIRECTLY A TEMPERATURE CORRECTION, 
 C***  FOLLOWING THE UNSOELD-LUCY METHOD
@@ -16,23 +18,30 @@
 C***********************************************************************
 
       IMPLICIT NONE
+      INCLUDE 'interfacebib.inc'
 
       INTEGER, INTENT(IN) :: ND
       REAL, DIMENSION(ND) :: RADIUS, TOLD, TNEW, XJTOTL,
      >                       DTLOCAL, DTINT, DTRMAX, DTKUBAT, 
      >                       TAUROSS, FTCOLI, HTOTCMF0, CORRS, FLUXERR,
-     >                       QOPAHMEAN, OPASMEANTC, 
+     >                       QOPAHMEAN, QOPAHMEANL, OPASMEANTC, HMEAN,
      >                       QFJMEAN, OPAJMEANTC, OPALAMBDAMEAN, 
-     >                       OPAPMEAN, SMEAN
-      REAL, DIMENSION(ND-1) :: ARAD, HTOTL
-      
-      REAL, INTENT(IN) :: TEFF, FLUXEPS, HTOTND, OPARND
-      REAL, INTENT(INOUT) :: DTDRIN
-      
-      LOGICAL :: BSMOOTHTC, BMONOTONIC, BWARNTMIN, bKUBAT,  
-     >           bOldFormat, bLOCAL, bOPAPMEAN, bINT2POINT, 
-     >           bSKIPCORR, bOBEXTRAP
-      LOGICAL, INTENT(IN) :: bTDIFFUS
+     >                       OPAPMEAN, SMEAN, VELO, XMU, VTURB,
+     >                       HTOTCMF0ADV
+      REAL, DIMENSION(ND-1) :: ARAD, HTOTL, HTOTCUT
+
+C***  Local, depth-dependent arrays
+      INTEGER, PARAMETER :: NDTCMAX = 120
+      REAL, DIMENSION(NDTCMAX) :: XL
+      
+      REAL, INTENT(IN) :: RSTAR, TEFF, FLUXEPS
+      
+      LOGICAL :: BSMOOTHTC, BWARNTMIN, bKUBAT, 
+     >           bOldFormat, bLOCAL, bFixOut, bINTUseOutTCor,
+     >           bINTinonly, bLOCinonly, bINMONO, bTDIFFUS,
+     >           bDAMPOUT, bRMN, bDTOUTPUT, bOPAPMEAN,
+     >           bPOSINT, bSKIPCORR, bINT2POINT, bOUTFLX,
+     >           bOBEXTRAP, bCUTINT, bINT, bRMAX, bINCADV
       
       INTEGER, PARAMETER :: NPARMAX = 40
       
@@ -40,22 +49,27 @@
       CHARACTER(4) :: EDMETHOD
       CHARACTER(40), DIMENSION(NPARMAX) :: ACTPAR
       
-      INTEGER :: I, NPAR, IPAR, L, LMINTMIN, LMAXTMIN, NTMIN, Linner,
-     >           LOCMIN, LOCMAX, LCUTCORRUSE, iAUTOEXPTAU
+      INTEGER :: I, NPAR, IPAR, L, Lmono, LMINTMIN, LMAXTMIN, 
+     >           NTMIN, IMONOTONIC, Linner, Lsonic, LOCMIN, LOCMAX,
+     >           LCUTCORRUSE, IMONOCOUNT, iAUTOEXPTAU
       REAL :: TMIN, CORRMAX, CUTCORR, DUNLU_LOC, DUNLU_RMAX, DUNLU_INT, 
      >        DHINTSUM, TREF, OPAMEAN, RL2, RL2M, DHRMAX, DHRMAX1, DH,
      >        DTB1, DTB, DTBTEFF, WRH, TNEW4, TOLD4, WRADIUS, QC,
      >        QS, TLEFT, TNEWL, F, RELCORR, HTOTOUTMINUS, EDDIHOUTJMEAN,
-     >        DHINT, DHCORRSUM, DT, DT1, DT2, DT3, DT4, DT5, CMAX, 
+     >        DHINT, DHCORRSUM, DT, DT1, DT2, DT3, DT4, CMAX, 
      >        DUNLU, EXPTAU, TM, DTDRTRUE, TAUINT,
-     >        DUNLU_TB, rfKUBAT, taurfmin, TBTAU, FINTMIN,
-     >        tempREAL, DE_LOC, DE_INT, DE_RMAX, DE_TB, HNDCORFAC, 
+     >        DUNLU_TB, rfKUBAT, rfa, rfb, taurfmin, TBTAU, FINTMIN,
+     >        tempREAL, AS, FTIMAX, DE_LOC, DE_INT, DE_RMAX, DE_TB,
+     >        HTOTND, OPARND, HCUR, HNDCORFAC, DTJMB,
+     >        QFJM, FTCOLINORM, DTDRIN, HTOTOUTSUB,
      >        TAVERAGE, DAMP, DAMPKUBAT, FLUXERRFAC, CLIMIT, FTEPS,
-     >        AUTOFLUXTAU
+     >        AUTOFLUXTAU, HTOTCMF0OUT, HTOTCMF0LM,
+     >        CONVEPS, EXPTAUL
        
 
       REAL, PARAMETER :: PI4 = 12.5663706144    !PI4 = 4*PI
       REAL, PARAMETER :: STEBOLDPI = 1.8046E-5  !STEFAN-BOLTZMANN CONSTANT (CGS-UNITS) / PI
+      REAL, PARAMETER :: BOLTZK = 1.3807E-16    !BOLTZMANN CONSTANT on cgs units
       REAL, PARAMETER :: AMU = 1.6605E-24       !Atomic mass unit (gramm) = m_H
 
       !File and channel handles (=KANAL)
@@ -63,23 +77,41 @@
       INTEGER, PARAMETER :: hCPR = 0        !write to wruniqX.cpr (stderr)
       
       
+      IF (ND > NDTCMAX) THEN
+        WRITE (hCPR,'(A)') 'TEMPCORR: FATAL ERROR ******'
+        WRITE (hCPR,'(A)') 'TEMPCORR: NDTCMAX INSUFFICIENT'
+        WRITE (hCPR,'(2(A,I4))') 'ND = ', ND, ', NDTCMAX = ', NDTCMAX
+        STOP 'FATAL ERROR IN STEAL->TEMPCORR'
+      ENDIF
+      
 C***  Decode parameters of UNLUTEC option card
 
 C***  Default values
       BSMOOTHTC  = .FALSE.
-      BMONOTONIC = .FALSE.
+      IMONOTONIC = 0
       BWARNTMIN  = .FALSE. 
+      bFixOut = .FALSE.
+      bDAMPOUT = .FALSE.
+      bINTinonly = .FALSE.
+      bLOCinonly = .FALSE.
       CORRMAX = 0.
       CUTCORR = .0
-      FLUXERRFAC  = .0
       TMIN = 6000.
+      bINMONO = .FALSE.
+      bRMN = .FALSE.
+      bPOSINT = .FALSE.
       bSKIPCORR = .FALSE.
       EXPTAU = 0.
       iAUTOEXPTAU = -1
       FTEPS = 0.01        !Default flux epsilon for automatic flux-tau
       bOBEXTRAP = .FALSE. !Default: Do not extrapolate T for outer boundary
+      bCUTINT = .FALSE.
+      bOUTFLX = .FALSE.
+      FLUXERRFAC = -1.
+      CONVEPS = -1.       !Default: Never define T-stratification as converged
 
       bOldFormat = .TRUE.
+      bDTOUTPUT = .FALSE.
 C***  range where TBALANCE correction is gradually switched off
       TBTAU = 0.1
       taurfmin = 0.01       
@@ -91,6 +123,8 @@
 C***                the two depth points L-1 and L
       bINT2POINT = .FALSE.
 
+C***  Default: Use outer T corrections for inner INT correction estimates      
+      bINTUseOutTCor = .TRUE.
 C***  Damping of the flux (INT) term      
       TAUINT = -99.
       FINTMIN = -99.
@@ -109,6 +143,8 @@
             bOldFormat = .FALSE.
           CASE ('BALANCE', 'TBALANCE', 'TB')
             bOldFormat = .FALSE.
+          CASE ('PRINT')
+            bOldFormat = .FALSE.
         ENDSELECT
       ENDDO
 
@@ -136,7 +172,10 @@
             BSMOOTHTC = .TRUE.
             IPAR = IPAR + 1
           ELSE IF (ACTPAR(IPAR) .EQ. 'MONOTONIC') THEN
-            BMONOTONIC = .TRUE.
+            IMONOTONIC = 1
+            IPAR = IPAR + 1
+          ELSE IF (ACTPAR(IPAR) == 'MONOINNER') THEN
+            IMONOTONIC = 2
             IPAR = IPAR + 1
 
           ELSE IF (ACTPAR(IPAR) .EQ. 'CORRMAX') THEN
@@ -243,7 +282,10 @@
               IPAR = IPAR + 1
 
             CASE ('MONO', 'MONOTONIC')
-              BMONOTONIC = .TRUE.
+              IMONOTONIC = 1
+              IPAR = IPAR + 1
+            CASE ('MONOINNER', 'MONOSONIC', 'MI')
+              IMONOTONIC = 2
               IPAR = IPAR + 1
             CASE ('EXPTAU', 'COSTAU')
               IF (IPAR+1 > NPAR) THEN
@@ -287,22 +329,62 @@
               ENDIF
               READ (ACTPAR(IPAR+1),'(F10.0)', ERR=1) tempREAL
               IF (tempREAL > 0.) THEN
-                FTEPS = -1. * FTEPS
+                FTEPS = -1. * tempREAL
               ELSE 
                 WRITE (hCPR,*) 'Error when decoding FTEPS'
                 STOP 'ERROR in Subr. TEMPCORR'
               ENDIF
               IPAR = IPAR + 2              
+            CASE ('FIXOUT')
+              bFixOut = .TRUE.
+              IPAR = IPAR + 1
+            CASE ('DAMPOUT')
+              bDAMPOUT = .TRUE.
+              IPAR = IPAR + 1
+            CASE ('FIXINTOUT')
+              bINTinonly = .TRUE.
+              IPAR = IPAR + 1
+            CASE ('FIXLOCOUT')
+              bLOCinonly = .TRUE.
+              IPAR = IPAR + 1
             CASE ('OBEX', 'OBEXTRAP')
               bOBEXTRAP = .TRUE.
               IPAR = IPAR + 1
                                                         
+            CASE ('PRINT')
+              bDTOUTPUT = .TRUE.
+              IPAR = IPAR + 1
+              
+            CASE ('RMN')
+              bRMN = .TRUE.
+              IPAR = IPAR + 1
+              
+            CASE ('NOINTOTC')            
+              bINTUseOutTCor = .FALSE.
+              IPAR = IPAR + 1
+
             CASE ('SKIPNEGFLUX')
               IF (MINVAL(ARAD) <= 0. .OR. MINVAL(HTOTL) <= 0.) THEN
                 bSKIPCORR = .TRUE.
               ENDIF
               IPAR = IPAR + 1
                             
+            CASE ('POSINT')
+              bPOSINT = .TRUE.
+              IPAR = IPAR + 1
+
+            CASE ('INT2POINT')
+              bINT2POINT = .TRUE.
+              IPAR = IPAR + 1
+              
+            CASE ('INTCUT')
+              bCUTINT = .TRUE.
+              IPAR = IPAR + 1
+
+            CASE ('OUTFLX')
+              bOUTFLX = .TRUE.
+              IPAR = IPAR + 1
+              
             CASE ('CORRMAX', 'CM')
               IF (IPAR+1 > NPAR) THEN
                 WRITE (hCPR,*) 'Error when decoding CORRMAX'
@@ -326,7 +408,9 @@
               ENDIF
               READ (ACTPAR(IPAR+1),'(F10.0)', ERR=1) CUTCORR
               IPAR = IPAR + 2
-
+            CASE ('INMONO')
+              bINMONO = .TRUE.
+              IPAR = IPAR + 1
             CASE ('TMIN')
               IF (IPAR+1 > NPAR) THEN
                 WRITE (hCPR,*) 'Error when decoding TMIN'
@@ -348,6 +432,23 @@
               ENDIF
               READ (ACTPAR(IPAR+1),'(F10.0)', ERR=1) TAUINT
               IPAR = IPAR + 2    
+            CASE ('CONVEPS')
+              IF (IPAR+1 > NPAR) THEN
+                WRITE (hCPR,*) 'Error when decoding CONVEPS'
+                STOP 'ERROR in Subr. TEMPCORR'
+              ENDIF
+              IF (ACTPAR(IPAR+1)(1:4) == 'FLUX') THEN
+                IF (FLUXEPS > 0.) THEN
+                  CONVEPS = FLUXEPS
+                ELSE
+                  WRITE (hCPR,*) 'Error when decoding CONVEPS: ' //
+     >              'FLUX option invalid as no FLUXEPS was specified'
+                  STOP 'ERROR in Subr. TEMPCORR'
+                ENDIF
+              ELSE
+                READ (ACTPAR(IPAR+1),'(F10.0)', ERR=1) CONVEPS
+              ENDIF
+              IPAR = IPAR + 2
             CASE DEFAULT
               !unknown parameter => skip
               IPAR = IPAR + 1
@@ -371,8 +472,24 @@
 C***********************************************************************
 C***    Prepare third Term of Unsoeld-Lucy-Procedure: outer Boundary
 C***********************************************************************
-      DHRMAX1 = (HTOTCMF0(1) - HTOTOUTMINUS) / EDDIHOUTJMEAN -
+      IF (bOUTFLX) THEN
+C***    Include HTOTOUTMINUS as now calculated in COLI->FREQUINT -- ansander, Oct 2023
+        HTOTOUTSUB = HTOTOUTMINUS
+      ELSE
+C***    In the standard branch, HTOTOUTMINUS defined, but not calculated in COLI
+C***    To achieve the same result as the previous code we thus need zero substraction.
+        HTOTOUTSUB = 0.
+      ENDIF
+      IF (bINCADV) THEN
+        DHRMAX1 = (HTOTCMF0ADV(1) - HTOTOUTSUB) / EDDIHOUTJMEAN -
+     >             XJTOTL(1)
+      ELSE
+        DHRMAX1 = (HTOTCMF0(1) - HTOTOUTSUB) / EDDIHOUTJMEAN -
      >           XJTOTL(1)
+      ENDIF
+C***  This might be better (but I do not remember why)     
+c      DHRMAX1 = (HTOTCMF0(2) - HTOTOUTSUB) / EDDIHOUTJMEAN -
+c     >           XJTOTL(1)
       DHINTSUM = .0
 
 C**********************************************************************
@@ -408,8 +525,16 @@
 C***    No direct input via UNLUTEC, but FLUXEPS card is specified:
         FTEPS = FLUXEPS
       ENDIF
+      IF (bINCADV) THEN
+        CALL TEMPCORR_FLUXERR(FLUXERR, ND, HTOTL, HTOTCMF0ADV,
+     >                        FTEPS, TAUROSS, AUTOFLUXTAU)
+      ELSEIF (bPOSINT) THEN
+        CALL TEMPCORR_FLUXERR(FLUXERR, ND, HMEAN, HTOTCMF0,
+     >                        FTEPS, TAUROSS, AUTOFLUXTAU)
+      ELSE
       CALL TEMPCORR_FLUXERR(FLUXERR, ND, HTOTL, HTOTCMF0,
      >                      FTEPS, TAUROSS, AUTOFLUXTAU)
+      ENDIF
 C***  Apply AUTOFLUXTAU is EXPTAU=AUTO in UNLUTEC card:
       IF (iAUTOEXPTAU >= 0) THEN
         IF (EXPTAU < 0.) THEN
@@ -447,7 +572,7 @@
                     
 C***      Fill factors for optional additional exponential damping
           CALL TEMPCORR_EXPDAMP(EXPTAU, EDMETHOD, TAUROSS, 
-     >                          bSKIPCORR, 
+     >                          bSKIPCORR, bDAMPOUT,
      >                          L, ND, DE_LOC, DE_INT, DE_RMAX, DE_TB)          
           
 C******************************************************************
@@ -481,22 +606,34 @@
      >       (TREF * TREF * TREF * 4. * STEBOLDPI * OPAMEAN * 1000.)
 
 
+C***    Flux consistency: integral term ("Strom-Iteration")            
 C***    The corrections of the previously treated depth points 
 C***      are integrated in dhcorrsum and also taken into account
 ccc this is not described in the UNLU paper, and might be questioned!
 ccc  wrh  4-Jul-2016
 
           RL2 = RADIUS(L) * RADIUS(L)
+         
           IF (L .EQ. 1) THEN
             DHINT = .0
             DHCORRSUM = .0
           ELSE
-
-            DH = HTOTL(L-1) - HTOTCMF0(L-1)
+            IF (bINCADV) THEN
+              HTOTCMF0LM = HTOTCMF0ADV(L-1)
+            ELSE
+              HTOTCMF0LM = HTOTCMF0(L-1)
+            ENDIF
+            IF (bCUTINT) THEN
+              DH = HTOTCUT(L-1) - HTOTCMF0LM
+            ELSEIF (bPOSINT) THEN
+              DH = HMEAN(L-1) - HTOTCMF0LM
+            ELSE
+              DH = HTOTL(L-1) - HTOTCMF0LM
+            ENDIF
             WRADIUS = RADIUS(L) - RADIUS(L-1)
 
 C***        Already performed corrections 
-            IF (L .GT. 2) THEN 
+            IF (L .GT. 2 .AND. bINTUseOutTCor) THEN 
              TNEW4 = TNEW(L-1) * TNEW(L-1) * TNEW(L-1) * TNEW(L-1) 
              TOLD4 = TOLD(L-1) * TOLD(L-1) * TOLD(L-1) * TOLD(L-1)  
              RL2M = RADIUS(L-1) * RADIUS(L-1)
@@ -512,6 +649,11 @@
              DH = DH + DHCORRSUM
             ENDIF 
 
+C***        Optional switch-off for corrections in the outer part             
+            IF (bINTinonly .AND. TAUROSS(L) < TBTAU) THEN
+              DH = 0.
+            ENDIF
+            
             DHINTSUM = DHINTSUM + DH * WRADIUS * QOPAHMEAN(L-1)          
 C***        Factors outside integral
             DHINT = OPAJMEANTC(L) * DHINTSUM / (RL2 * QFJMEAN(L))
@@ -549,7 +691,11 @@
      >           / (QFJMEAN(L) * RL2) 
 
 C***      Damping of the RMAX (i.e. 3rd) term with same factor as 2nd
+          IF (bRMN) THEN
+            DTRMAX(L)  = DAMP * DHRMAX  * DTB     ! stored for PLOT UNLU
+          ELSE
           DTRMAX(L)  = DAMP * DHRMAX  * DTBTEFF ! stored for PLOT UNLU
+          ENDIF
           DT3 = DUNLU_RMAX * DE_RMAX * DTRMAX(L)
 
 C********************************************************************     
@@ -588,6 +734,14 @@
 
          TNEW(L) = TOLD(L) + DT      
 
+         IF (MAXVAL(FLUXERR) > 0. .AND. CONVEPS > 0.
+     >            .AND. CONVEPS > MAXVAL(FLUXERR)) THEN 
+           IF (L==1) THEN
+             WRITE (hCPR,*) 'FLUXERR < CONVEPS: ' //
+     >          'Temperature stratification considered to be converged'
+           ENDIF
+           TNEW(L) = TOLD(L)
+         ENDIF
 
 C***     Restrict here the T-correction to factor of two increase
 C***      this is necessary to avoid a crash at the next depth point 
@@ -624,6 +778,19 @@
      >          * (RADIUS(1) - RADIUS(2)) * QOPAHMEAN(1)
       ENDIF
       
+C***  Option: Fixed temperature in the outer region
+      IF (bFixOut) THEN        
+        foloop: DO L=1, ND
+          IF (TAUROSS(L) > TBTAU) THEN
+            WRITE (hCPR,'(2A,I3,A)') 
+     >        'TEMPCORR: Temperature fixed for optically thin regime',
+     >        ' (',L-1,' outer depth points)'
+            EXIT foloop
+          ENDIF
+          TNEW(L) = TOLD(L)
+        ENDDO foloop
+      ENDIF
+
 C***  Smoothing of temperature corrections
       IF (BSMOOTHTC) THEN
         QC = 0.6
@@ -649,19 +816,47 @@
 C**************************************************************
 C*** Enforcing monotonic temperature structure
 C**************************************************************
-      IF (BMONOTONIC) THEN
-      WRITE (0,*) 'TEMPCORR: Monotonic Temperature enforced'
+      DO L=1, Linner
+        AS = SQRT( BOLTZK/AMU * TOLD(L)/XMU(L) + (VTURB(L)*1.E5)**2 )
+        AS = AS/1.E5
+        IF (VELO(L) > 5. * AS) THEN
+          Lsonic = L
+          EXIT
+        ENDIF
+      ENDDO
+      IF (IMONOTONIC > 0 .OR. ((.NOT. bTDIFFUS) .AND. bINMONO)) THEN
+         IF (IMONOTONIC > 0) THEN
+           WRITE (hCPR,'(A)') 'TEMPCORR: Monotonic Temperature enforced'
+           IF (IMONOTONIC > 1) THEN
+C***         MONOINNER option: Restrict monotonic regime to inner layers
+             Lmono = Lsonic
+           ELSE
+             Lmono = 1
+           ENDIF
+         ELSE 
+           Lmono = Lsonic
+           Linner = ND-1
+           WRITE (hCPR,'(A)') 'TEMPCORR: Monotonic Temperature '
+     >       // 'enforced for innermost points'                         
+         ENDIF
+         IMONOCOUNT = 0
    10    CONTINUE
 
 C***     Find local maximum
          LOCMAX=0
-         DO L=1, Linner-1
+         DO L=Lmono, Linner-1
             IF (TNEW(L+1) < TNEW(L)) THEN
               LOCMAX=L
               EXIT
             ENDIF
          ENDDO
          IF (LOCMAX .EQ. 0) GOTO 11
+         IMONOCOUNT = IMONOCOUNT + 1
+         IF (IMONOCOUNT > 20) THEN
+           WRITE (0,*) 'More than 20 MONOTONIC iterations: Giving up!'
+           WRITE (0,*) 'LOCMAX = ', LOCMAX
+           GOTO 11
+         ENDIF
  
 C***     Find following local minimum
          IF (LOCMAX == Linner-1) THEN
@@ -689,7 +884,7 @@
          ENDDO
 
 C***     Replace all T further out with average if yet hotter
-         DO L= LOCMAX-1, 1, -1
+         DO L= LOCMAX-1, Lmono, -1
             IF (TNEW(L) > TAVERAGE) THEN
                TNEW(L) = TAVERAGE
             ELSE
@@ -809,6 +1004,26 @@
       ELSE
         bLOCAL = .FALSE.
       ENDIF
+      IF (DUNLU_INT > 0.) THEN
+        bINT = .TRUE.
+      ELSE
+        bINT = .FALSE.
+      ENDIF
+      IF (DUNLU_RMAX > 0.) THEN
+        bRMAX = .TRUE.
+      ELSE
+        bRMAX = .FALSE.
+      ENDIF
+
+C***  Determine depth index of current EXPTAU value
+      IF (EXPTAU >= TAUROSS(1) .AND. EXPTAU <= TAUROSS(ND)) THEN
+        DO L=1, ND
+          XL(L) = FLOAT(L)
+        ENDDO
+        CALL SPLINPOX(EXPTAUL, EXPTAU, XL, TAUROSS, ND) 
+      ELSE
+        EXPTAUL = 0.
+      ENDIF
           
       RETURN
 
diff -bur ./tempcorr_fluxerr.f ../../powr-refactor/src/tempcorr_fluxerr.f
--- ./tempcorr_fluxerr.f	2024-07-28 13:14:38.000000000 +0200
+++ ../../powr-refactor/src/tempcorr_fluxerr.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,7 +1,7 @@
       SUBROUTINE TEMPCORR_FLUXERR(FLUXERR, ND, HTOTL, HTOTCMF0, 
      >                            FTEPS, TAUROSS, AUTOFLUXTAU)
 C***********************************************************************
-C***  Calculation of the current deviation from flux conservation
+C***  Calculation of the current deviation from flux conversation
 C***  and determination of an optical depth that can be used
 C***  as a damping parameter for flux correction terms that should
 C***  favor inner flux corrections.
Only in ../../powr-refactor/src/: vdopdd_setup.f
diff -bur ./vdop_struct.f ../../powr-refactor/src/vdop_struct.f
--- ./vdop_struct.f	2024-07-28 13:14:41.000000000 +0200
+++ ../../powr-refactor/src/vdop_struct.f	2023-09-27 10:14:15.129755873 +0200
@@ -1,5 +1,5 @@
       SUBROUTINE VDOP_STRUCT (BDD_VDOP, DD_VDOP_LINE, DD_VDOP, VDOP, 
-     >                        VELO, T, 
+     >                        VMIC_MODEL, VELO, T, 
      >                        ND, NDDIM, NATOM, MAXATOM, DD_VDOPDU, 
      >                        VMICFRAC_DEFAULT, ATMASS, 
      >                        XMAX, XMAXMIN, 
@@ -46,7 +46,8 @@
       INTEGER  :: L, NA, NPAR, I, NA_MIN, ISRCHEQ, IVDOPSTATUS
       REAL, DIMENSION(NATOM), INTENT(IN) :: ATMASS
 
-      REAL, DIMENSION(ND), INTENT(IN) :: VELO, T, TAUROSS, RADIUS
+      REAL, DIMENSION(ND), INTENT(IN) :: VELO, T, TAUROSS, RADIUS,
+     >                                   VMIC_MODEL
       REAL, DIMENSION(ND) :: DD_VMIC, DD_VMICDU
 
       REAL, INTENT(IN) :: VMICFRAC_DEFAULT, XMAXMIN 
@@ -80,6 +81,19 @@
         CALL SARGC (DD_VDOP_LINE, NPAR)
         IF ((NPAR .LT. 2) .OR. (NPAR .GT. 8)) GOTO 102
         CALL SARGV (DD_VDOP_LINE, 2, ACTPAR)
+        IF (ACTPAR == 'MODEL') THEN
+C***      use VMIC as specified in the MODEL file
+          IF (MINVAL(VMIC_MODEL) < 0.) THEN
+C***        FATAL ERROR if no (useful) VMIC is stored in the MODEL
+            WRITE (0, '(A)') '*** ERROR: No VMIC stored in MODEL file'
+            WRITE (0, '(A)') '*** VMIC MODEL is invalid in this case!'
+            STOP '*** Fatal error in vdop_struct'            
+          ENDIF
+          DO L=1, ND
+            DD_VMIC(L) = VMIC_MODEL(L)
+          ENDDO
+        ELSE
+C***      VMIC was specified via FORMAL_CARDS
         READ (ACTPAR, '(F20.0)', ERR = 102) VMIC_MIN
 C***    VMIC(L) is never smaller than specified by user
         WRITE(0,'(A,F10.5)') "Inner microturbulence:", VMIC_MIN
@@ -142,6 +156,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF 
+                        IF ((DIST_IN .GE. VELO(1)) .OR. (DIST_OUT .LE. VELO(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner wind velocity: ", VELO(ND)
+                            WRITE(0,'(A,F10.5)') "Outer wind velocity: ", VELO(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
 C***                    interpolation boundaries may not exceed model boundaries
                         DIST_IN = AMAX1(DIST_IN, VELO(ND))
                         DIST_OUT = AMIN1(DIST_OUT, VELO(1))
@@ -174,6 +194,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF 
+                        IF ((DIST_IN .LE. TAUROSS(1)) .OR. (DIST_OUT .GE. TAUROSS(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner tau: ", TAUROSS(ND)
+                            WRITE(0,'(A,F10.5)') "Outer tau: ", TAUROSS(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
                         DIST_IN = AMIN1(DIST_IN, TAUROSS(ND))
                         DIST_OUT = AMAX1(DIST_OUT, TAUROSS(1))
                         WRITE(0,'(A,F10.5, A, F10.5)') 
@@ -205,6 +231,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF                    
+                        IF ((DIST_IN .GE. RADIUS(1)) .OR. (DIST_OUT .LE. RADIUS(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner radius: ", RADIUS(ND)
+                            WRITE(0,'(A,F10.5)') "Outer radis: ", RADIUS(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
                         DIST_IN = AMAX1(DIST_IN, RADIUS(ND))
                         DIST_OUT = AMIN1(DIST_OUT, RADIUS(1))
                         WRITE(0,'(A,F10.5, A, F10.5)') 
@@ -234,6 +266,7 @@
             ELSE
                 GOTO 102
             ENDIF
+          ENDIF
 C***        End of depth-dependent VMIC
         ENDIF
 C***    VMIC(L) is now defined for every case
@@ -323,6 +356,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF
+                        IF ((DIST_IN .GE. VELO(1)) .OR. (DIST_OUT .LE. VELO(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner wind velocity: ", VELO(ND)
+                            WRITE(0,'(A,F10.5)') "Outer wind velocity: ", VELO(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
                         DIST_IN = AMAX1(DIST_IN, VELO(ND))
                         DIST_OUT = AMIN1(DIST_OUT, VELO(1))
                         WRITE(0,'(A,F10.5, A, F10.5)') 
@@ -355,6 +394,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF
+                        IF ((DIST_IN .LE. TAUROSS(1)) .OR. (DIST_OUT .GE. TAUROSS(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner tau: ", TAUROSS(ND)
+                            WRITE(0,'(A,F10.5)') "Outer tau: ", TAUROSS(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
                         DIST_IN = AMIN1(DIST_IN, TAUROSS(ND))
                         DIST_OUT = AMAX1(DIST_OUT, TAUROSS(1))
                         WRITE(0,'(A,F10.5, A, F10.5)')
@@ -387,6 +432,12 @@
                             DIST_IN = DIST_OUT
                             DIST_OUT = DUMMY
                         ENDIF
+                        IF ((DIST_IN .GE. RADIUS(1)) .OR. (DIST_OUT .LE. RADIUS(ND))) THEN
+                            WRITE(0,'(A,F10.5)') "Interpolation boundaries not in model boundaries!"
+                            WRITE(0,'(A,F10.5)') "Inner radius: ", RADIUS(ND)
+                            WRITE(0,'(A,F10.5)') "Outer radius: ", RADIUS(1)
+                            STOP "Fatal error in subroutine VDOP_STRUCT"
+                        ENDIF
                         DIST_IN = AMAX1(DIST_IN, RADIUS(ND))
                         DIST_OUT = AMIN1(DIST_OUT, RADIUS(1))
                         WRITE(0,'(A,F10.5, A, F10.5)') 
@@ -417,6 +468,10 @@
                 GOTO 101
             ENDIF
         ENDIF
+C*** VMIC array is filled even when not specified so that convolution works in subr. STARKBROAD
+      DO L=1, ND
+        DD_VMIC(L) = DD_VDOP(L,1)
+      ENDDO
 *********** END OF VDOP VERSION ************
       ENDIF
 C*** Generic (Symbol 'G') has its own VDOP velocity VDOPFE from the iron file
Only in ../../powr-refactor/src/: vturb_setup.f
diff -bur ./wmodcoli.f ../../powr-refactor/src/wmodcoli.f
--- ./wmodcoli.f	2024-07-28 13:14:43.000000000 +0200
+++ ../../powr-refactor/src/wmodcoli.f	2023-11-21 10:10:55.293269795 +0100
@@ -1,18 +1,22 @@
       SUBROUTINE WMODCOLI(XJCINT, FWTEST, ARAD, ACONT, ATHOM,
      >                    ND, NF, RADIUS, ENTOT, RSTAR,
-     >                    XJFEMEAN, SIGMAINT, LASTFE, 
-     >                    HTOTL, HTOTND, HTOTNDCOR, 
-     >                    WFELOW, WFENUP, FTCOLI, NCOLIP, 
+     >                    XJFEMEAN, SIGMAINT, LASTFE, HTOTL, WFELOW, 
+     >                    WFENUP, FTCOLI, FTCOLIB, REDISMODE, NCOLIP, 
      >                    XJTOTL, XKTOTL, XNTOTL, WJC,
      >                    DBDTINT, DBDTOPAINT, DBDTINT_M, DBDTOPAINT_M,
-     >                    OPASMEAN, OPASMEANTC, OPAPMEAN, QFJMEAN, 
-     >                    SMEAN, OPAJMEAN, OPAJMEANTC, 
-     >                    QOPAHMEAN, EDDIHOUTJMEAN, 
-     >                    HTOTOUTMINUS, LASTIND, 
-     >                    FERATUL, FERATLU, BCOLIP, EPSGMAX, 
+     >                    OPASMEAN, OPASMEANTC, OPAPMEAN, 
+     >                    QFJMEAN, SMEAN, OPAJMEAN, OPAJMEANTC, 
+     >                    QOPAHMEAN, EDDIHOUTJMEAN, HMEAN,
+     >                    HTOTOUTMINUS, HTOTMINUSND, HTOTND, 
+     >                    HTOTNDCOR, HTOTCUT,
+     >                    LASTIND,  FERATUL, FERATLU, BCOLIP, EPSGMAX, 
      >                    FTFE, EMCOLI, FF_INFO, IFF_DK, IFF_MAX_MS,
      >                    IFF_WCHARM, OPALAMBDAMEAN, TOTOUT, bKALPHA,
-     >                    ALPHAF, RHO, XMU, TAUROSS, OPAROSS)
+     >                    ALPHAF, ARMDRESP, GAMMATHIN, CK, RHO, XMU, 
+     >                    TAUROSS, OPAROSS, OPAROSSELEM, OPAROSSCONT, 
+     >                    OPATOTELEM, NATOM, 
+     >                    ARADELEM, ACONTELEM, MAXION,
+     >                    ARADION, ACONTION, hMODEL, hALO)
 C****************************************************************
 C*** Handles all MODEL write (MSWRIT) statements from COLI
 C***  only called by COLI main program
@@ -22,17 +26,19 @@
 
       INTEGER, PARAMETER :: TINYINT = SELECTED_INT_KIND(2)
 
-      INTEGER, INTENT(IN) :: ND, NF, LASTFE, IFF_MAX_MS
+      INTEGER, INTENT(IN) :: ND, NF, NATOM, MAXION, LASTFE, IFF_MAX_MS,
+     >                       hMODEL, hALO
 
       REAL, DIMENSION(ND) :: ARAD, ACONT, ATHOM,
-     >                       RADIUS, ENTOT,
-     >                       HTOTL, FTCOLI, 
+     >                       HTOTL, HTOTCUT, FTCOLI, FTCOLIB,
      >                       XJTOTL, XKTOTL, XNTOTL,
      >                       EPSGMAX, OPALAMBDAMEAN, SMEAN,
-     >                       ALPHAF, RHO, XMU,          !used for hydro
-     >                       QOPAHMEAN, 
+     >                       ALPHAF, ARMDRESP, GAMMATHIN, CK,
+     >                       RHO, XMU, OPAROSSCONT,          
+     >                       QOPAHMEAN, QOPAHMEANL, HMEAN,
      >                       OPAJMEANTC, OPAJMEAN, OPASMEAN,
-     >                       OPASMEANTC, OPAPMEAN, QFJMEAN
+     >                       OPASMEANTC, OPAPMEAN,
+     >                       QFJMEAN
 
       REAL, DIMENSION(LASTFE) :: SIGMAINT
       REAL, DIMENSION(ND,NF) :: XJCINT, WJC
@@ -44,17 +50,24 @@
       INTEGER(KIND=TINYINT), DIMENSION(IFF_MAX_MS) :: IFF_DK   !erst, wenn MS-Storage aktualisiert
       INTEGER(KIND=TINYINT), DIMENSION(IFF_MAX_MS,ND) :: IFF_WCHARM
       
-      REAL, DIMENSION(ND), INTENT(IN) :: TAUROSS, OPAROSS
+      REAL, DIMENSION(ND), INTENT(IN) :: TAUROSS, OPAROSS,
+     >                                   RADIUS, ENTOT
+      REAL, DIMENSION(NATOM, ND), INTENT(IN) :: OPAROSSELEM, OPATOTELEM
+      REAL, DIMENSION(NATOM, ND-1), INTENT(IN) :: ARADELEM, ACONTELEM
+      REAL, DIMENSION(ND-1, NATOM, MAXION), INTENT(IN) :: ARADION, 
+     >                                                    ACONTION
 
       INTEGER :: L, INDF, NCOLIP, LASTIND, IND, INDFE, IDUMMY, IERR,
-     >           IFF_N_MS
+     >           IFF_N_MS, LARM
       REAL :: EDDIHOUTJMEAN, DBDTINT_M, DBDTOPAINT_M, OPARNDM,
      >        DBDTOPAINT, DBDTINT, OPARND, RSTAR, HTOTOUTMINUS,
-     >        TOTOUT, HTOTND, HTOTNDCOR
+     >        TOTOUT, HTOTMINUSND, HTOTND, HTOTNDCOR
 
       LOGICAL :: BCOLIP, bKALPHA
       
       CHARACTER(8) :: NAME, CKIND
+      CHARACTER(4) :: REDISMODE
+
 
 C***  NORMALIZE AND SAVE XJC'S
       DO INDF=1, NF
@@ -71,10 +84,10 @@
          ENDDO
          WRITE (NAME,'(A3,I4)') 'XJC', INDF
          CALL WRITMS 
-     >        (3, XJCINT(1, INDF), ND, NAME, -1, IDUMMY, IERR)
+     >        (hMODEL, XJCINT(1, INDF), ND, NAME, -1, IDUMMY, IERR)
          WRITE (NAME,'(A3,I4)') 'WJC', INDF
          CALL WRITMS 
-     >        (3,    WJC(1, INDF), ND, NAME, -1, IDUMMY, IERR)
+     >        (hALO,  WJC(1, INDF), ND, NAME, -1, IDUMMY, IERR)
       ENDDO
 
       DO INDF=1, NF
@@ -85,10 +98,21 @@
 
       CALL WRITMS(3, TAUROSS,ND, 'TAUROSS ', -1, IDUMMY, IERR)
       CALL WRITMS(3, OPAROSS,ND, 'OPAROSS ', -1, IDUMMY, IERR)
+      LARM = NATOM * ND
+      CALL WRITMS(3,OPAROSSELEM,LARM,'OPARELEM', -1, IDUMMY, IERR)
+      CALL WRITMS(3,OPAROSSCONT,ND,  'OPARCONT', -1, IDUMMY, IERR)
+      CALL WRITMS(3,OPATOTELEM,LARM,'OPALELEM', -1, IDUMMY, IERR)
 
       CALL WRITMS(3, ARAD, ND-1, 'ARAD    ', -1, IDUMMY, IERR)
       CALL WRITMS(3, ACONT, ND-1, 'ACONT   ', -1, IDUMMY, IERR)
       CALL WRITMS(3, ATHOM, ND-1, 'ATHOM   ', -1, IDUMMY, IERR)
+      LARM = NATOM * (ND-1) 
+      CALL WRITMS(3, ARADELEM, LARM, 'ARADELEM', -1, IDUMMY, IERR)
+      CALL WRITMS(3, ACONTELEM,LARM, 'ACNTELEM', -1, IDUMMY, IERR)
+      LARM = (ND-1) *  NATOM * MAXION
+      CALL WRITMS(3, ARADION, LARM, 'ARADION ', -1, IDUMMY, IERR)
+      CALL WRITMS(3, ACONTION,LARM, 'ACONTION', -1, IDUMMY, IERR)
+      
 C      CALL WRITMS(3, RHO,    ND, 'RHO     ', -1, IDUMMY, IERR)
 C      CALL WRITMS(3, XMU,    ND, 'XMU     ', -1, IDUMMY, IERR)
 C***  save radiative acceleration and fractions in internal units
@@ -102,8 +126,10 @@
 C***  CALCULATE AND SAVE LOCAL RADIATIVE ENERGY LOSS IN CGS
       DO L=1, ND
          FTCOLI(L) = FTCOLI(L)/RSTAR
+         FTCOLIB(L) = FTCOLIB(L)/RSTAR
       ENDDO
       CALL WRITMS(3, FTCOLI, ND, 'FTCOLI  ', -1, IDUMMY, IERR)
+      CALL WRITMS(3, FTCOLIB,ND, 'FTCOLIB ', -1, IDUMMY, IERR)
 
 C***  IRON: NORMALIZE AND SAVE MEAN INTENSITIES 'XJFEMEAN'
 C           AND DIAGONAL WEIGHTS 'WFELOW' AND 'WFENUP'
@@ -116,6 +142,8 @@
             FTFE(L,INDFE)      = FTFE(L,INDFE)/RSTAR
          ENDDO
          IND = LASTIND + INDFE
+C***     XJL for iron lines is stored here, for all other lines
+C***     this has already been done in the subroutine CHECK_LINES
          IF (IND <= 9999) THEN
            WRITE (NAME,'(A3,I4,A1)') 'XJL', IND, ' '
          ELSE
@@ -125,10 +153,10 @@
      >        (3, XJFEMEAN(1, INDFE), ND, NAME, -1, IDUMMY, IERR)
          WRITE (NAME,'(A3,I4)') 'WFL', INDFE
          CALL WRITMS 
-     >        (3, WFELOW(1, INDFE), ND, NAME, -1, IDUMMY, IERR)
+     >        (hALO, WFELOW(1, INDFE), ND, NAME, -1, IDUMMY, IERR)
          WRITE (NAME,'(A3,I4)') 'WFU', INDFE
          CALL WRITMS 
-     >        (3, WFENUP(1, INDFE), ND, NAME, -1, IDUMMY, IERR)
+     >        (hALO, WFENUP(1, INDFE), ND, NAME, -1, IDUMMY, IERR)
 C***     FTFE is for tests only and not used in other programs
 C***     therefore it is not written to the MODEL anymore - wrh 17-May-2023
 ccc         WRITE (NAME,'(A3,I4)') 'FTF', INDFE
@@ -156,22 +184,26 @@
       CALL WRITMS(3,XJTOTL, ND, 'JTOTL   ', -1, IDUMMY, IERR)
       CALL WRITMS(3,XKTOTL, ND, 'KTOTL   ', -1, IDUMMY, IERR)
       CALL WRITMS(3,XNTOTL, ND, 'NTOTL   ', -1, IDUMMY, IERR)
+C***  non-negative HTOTL (can be used in TEMPCORR)
+      CALL WRITMS(3, HMEAN, ND-1, 'HMEAN   ', -1, IDUMMY, IERR)
+C***  HTOTL with too strong lines cut (can be used in TEMPCORR)      
+      CALL WRITMS(3, HTOTCUT, ND-1,  'HTOTCUT ', -1, IDUMMY, IERR)
 
 C***  Calculate and Save Rosseland Opacity at the inner Boundary
       OPARND = DBDTINT / DBDTOPAINT
-C      WRITE (0,*) 'OPAROSS(ND) ', OPARND, OPAROSS(ND)
       CALL WRITMS(3, OPARND, 1, 'OPARND  ', -1, IDUMMY, IERR)
+      OPARNDM = DBDTINT_M / DBDTOPAINT_M
+      CALL WRITMS(3, OPARNDM, 1, 'OPARNDM ', -1, IDUMMY, IERR)
       
-C***  Save Eddington Flux at inner boundary 
-C***  calculated in FREQUINT
-      CALL WRITMS(3, HTOTND, 1, 'HTOTND  ', -1, IDUMMY, IERR)
-
-C***  Diffusion/LTE correction for Eddington Flux at inner boundary
-C***  HTOTNDCOR = int( B_nu(T_ND)/2 - h_nu * J_nu,ND , d-nu )
-C***  calculated in FREQUINT
-      CALL WRITMS(3, HTOTNDCOR, 1, 'HTNDCOR ', -1, IDUMMY, IERR)
+C***  Save special Hminus at inner boundary (used in STEAL for T(ND)-correction)      
+      CALL WRITMS(3, HTOTMINUSND, 1, 'HTMND   ', -1, IDUMMY, IERR)
+      CALL WRITMS(3, HTOTND     , 1, 'HTOTND  ', -1, IDUMMY, IERR)
+      CALL WRITMS(3, HTOTNDCOR  , 1, 'HTNDCOR ', -1, IDUMMY, IERR)
+C***  Save special Hminus at outer boundary (used in STEAL for T-correction)      
+      CALL WRITMS(3, HTOTOUTMINUS, 1,'HTOTOUTM', -1, IDUMMY, IERR)
 
-C***  Write NCOLIP
+C***  Write REDISMODE and NCOLIP
+      CALL WRITMS(3, REDISMODE, 1, 'REDISMO ', -1, IDUMMY, IERR)
       CALL WRITMS(3, NCOLIP,    1, 'NCOLIP  ', -1, IDUMMY, IERR)
 
 C***  Unsoeld-Lucy Terms for TEMPEQ
Only in ../../powr-refactor/src/: wrcont.exe
Only in ../../powr-refactor/src/: wrcont.exe.opt
diff -bur ./wrcont.f ../../powr-refactor/src/wrcont.f
--- ./wrcont.f	2024-07-28 13:14:44.000000000 +0200
+++ ../../powr-refactor/src/wrcont.f	2023-09-27 10:14:15.129755873 +0200
@@ -10,18 +10,22 @@
 C***  DEFINE ARRAY DIMENSIONS ******************************************
 C***  IRON: ADD GENERIC ION TO MAXATOM
       INTEGER, PARAMETER :: MAXATOM =          26
-      INTEGER, PARAMETER :: NDIM    =        2560
+      INTEGER, PARAMETER :: NDIM    =        1560
       INTEGER, PARAMETER :: NFDIM   = 2*NDIM + 400
       INTEGER, PARAMETER :: MAXIND  =       45000
       INTEGER, PARAMETER :: MAXFEIND  =       1500
       INTEGER, PARAMETER :: MAXKONT =     NFDIM/2
+      INTEGER, PARAMETER :: MAXKODR =        NDIM
       INTEGER, PARAMETER :: NDDIM   =          89
       INTEGER, PARAMETER :: NPDIM   =          94
       INTEGER, PARAMETER :: MAXHIST =        4000 
       INTEGER, PARAMETER :: MAXXDAT =          10 
  
+C***  MAXIMUM ION CHARGE WHICH MAY OCCUR (SEE ALSO SUBR. GAUNTFF)
+      INTEGER, PARAMETER :: MAXION = 27 
+
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      INTEGER, PARAMETER :: MAXAUTO = 2850 
+      INTEGER, PARAMETER :: MAXAUTO = 3200 
       INTEGER, DIMENSION(MAXAUTO) :: LOWAUTO, IONAUTO, KRUDAUT
       REAL, DIMENSION(MAXAUTO) :: WAUTO, EAUTO, AAUTO
       COMMON /COMAUTO/ LOWAUTO, WAUTO, EAUTO, AAUTO, IONAUTO, KRUDAUT
@@ -58,10 +62,11 @@
       REAL, DIMENSION(NDDIM, NDIM) :: POPNUM
 
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
-C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5     !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5     !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5     !xxl
+C      INTEGER, PARAMETER :: INDEXMAX = 4000000, NFEREADMAX = 100000    !standard vd100
+C      INTEGER, PARAMETER :: INDEXMAX = 5000000, NFEREADMAX = 150000    !vd50
+C      INTEGER, PARAMETER :: INDEXMAX = 15000000, NFEREADMAX = 400000   !vd20
+      INTEGER, PARAMETER :: INDEXMAX = 100000000, NFEREADMAX = 600000     !custom hydro
+C      INTEGER, PARAMETER :: INDEXMAX = 12000000, NFEREADMAX = 300000   !Goetz
 
       REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
       INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
@@ -75,18 +80,18 @@
      >           NAUTO, LASTKON, LASTFE, JOBNUM, ND, NP, NF,
      >           LAST, NEXTK, LSOPA, LSINT, IFLUX, JOBMAX, IVERS, K,
      >           NCOLIP, LASTK, KDONE, IDUMMY, ISTATS, KWORDS, KBLOCKS,
-     >           IERR, N_WITH_DRLEVELS 
+     >           IERR, IWARNES2, N_WITH_DRLEVELS 
      
       REAL :: VDOPFE, XLAM0FE, TEFF, RSTAR, DTDR, TOTOUT, TOTIN, DXFE,
      >        BCORE, OPARND, TNOW, TUSED, TLEFT, TPERK, FLUXIN, DBDR,
-     >        DUMMY, TBEGIN
+     >        DUMMY, TBEGIN, POPMIN
 
       LOGICAL BFEMODEL
 
-      LOGICAL NOTEMP, BUNLU, BKUDRITZKI
+      LOGICAL :: NOTEMP, BUNLU, BKUDRITZKI, bCLXJC, bNoARAD, bNoXJC
 
       REAL, DIMENSION(MAXXDAT) :: XDATA
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
 
       CHARACTER(MAXHIST*8) :: MODHIST
       CHARACTER(255) :: HISTENTRY
@@ -137,17 +142,23 @@
 
       CALL INSTALL
 
-c      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
-c        CALL CLOCK(TIM1)
-c      ELSE
-c        CALL TIME(TIM1)
-c      ENDIF
+      IF (OPSYS .EQ. 'CRAY' .OR. OPSYS .EQ. 'SGI') THEN
+        CALL CLOCK(TIM1)
+      ELSE
+        CALL TIME(TIM1)
+      ENDIF
 
 C***  Initialize BELIFI; To Store Feautrier Matrices in Memory is now default
       BELIFI = .FALSE.
 
+C***  Initialize XJC and other vectors
+      XJC = 0.
+      EDDI = 0.
+      EMFLUX = 0.
+      
 C***  INITIALIZE COUNTER IWARNES, COUNTING SMALL EDDI'S (F) IN ELIMIN
       IWARNES = 0
+      IWARNES2 = 0
 
       CALL       DATOM (NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,MAINQN,
      $                  EINST,ALPHA,SEXPO,
@@ -164,7 +175,7 @@
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL, 
-     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
  
 C***  WARNING: THIS DEFINITION IS DIFFERENT TO THAT DONE IN STEAL
 C***  UNSOELD-LUCY-PROCEDURE IS ACTIVE ==> NOTEMP = FALSE
@@ -173,27 +184,34 @@
       ENDIF
 
       BKUDRITZKI = .FALSE.
-C***  IN CASE OF FIRST WRCONT-JOB: SET OPTION "NOTEMP"
-      IF (JOBNUM .EQ. 2 .AND. BKUDRITZKI) THEN
-        NOTEMP =.TRUE.
-      ELSE
-        NOTEMP = .FALSE.
-      ENDIF
 
 C***  READING OF THE MODEL FILE ****************************************
       CALL       RMODCON (ND,NDDIM,RADIUS,NP,NPDIM,P,Z,ENTOT,T,RNE,NF,
      $             NFDIM,MODHIST,MAXHIST,LAST,ALTESUM,XLAMBDA,
-     $             TEFF,NOTEMP,XJCOLD,HEDDI,EDDI,NCOLIP,
-     $             FWEIGHT,KEY,POPNUM,RSTAR,MODHEAD,JOBNUM,NEXTK,N,
-     $             MAXXDAT,XDATA, DENSCON, FILLFAC, OPARND, ZERO_RATES,
-     >             NDIM)
+     >             TEFF,NOTEMP,XJCOLD,HEDDI,EDDI,NCOLIP,FWEIGHT,
+     >             KEY,POPNUM,RSTAR,MODHEAD,JOBNUM,NEXTK,N,NDIM,
+     $             MAXXDAT,XDATA, DENSCON, FILLFAC, OPARND, 
+     >             POPMIN, ZERO_RATES, bNoARAD, bNoXJC)
       WRITE(hCPR,'(A,I7)') '>>> This is job number ', JOBNUM
 
-      CALL POPMIN_NULLING (ZERO_RATES, POPNUM, ND, N)
+C***  IN CASE OF FIRST WRCONT-JOB: SET OPTION "NOTEMP"
+c      IF (JOBNUM .EQ. 2 .AND. BKUDRITZKI) THEN
+      IF (JOBNUM .EQ. 2) THEN
+        NOTEMP = .TRUE.
+      ELSE
+        NOTEMP = .FALSE.
+      ENDIF
+      
+      IF (bNoXJC) THEN
+C***    IF no XJC is found in the model, we cannot call DIFDTDR      
+        NOTEMP = .TRUE.
+      ENDIF
+      
+      CALL POPMIN_NULLING (ZERO_RATES, POPNUM, POPMIN, ND, N)
 
 C***  DECODING INPUT OPTIONS *******************************************
       CALL       DECON (LSOPA,LSINT,IFLUX,JOBMAX,MODHIST, 
-     >                  BUNLU, IVERS)
+     >                  BUNLU, bCLXJC, IVERS, POPMIN)
 
       TOTIN=.0
       TOTOUT=.0
@@ -219,25 +237,25 @@
 C***  CALCULATION OF "DTDR" FOR USE IN SUBR. DIFFUS
 C***  (ONLY IF DEFAULT OPTION "TEMPERATURE CORRECTION" IS SET)
       IF (.NOT. NOTEMP) CALL DIFDTDR (DTDR,TEFF,XJCOLD,HEDDI,T(ND),
-     $                  RADIUS(ND),ND,EN,POPNUM,RNE(ND),ENTOT(ND),RSTAR,
-     $                  NDIM,N,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
-     $                  ALPHA,SEXPO,
+     >                  RADIUS(ND),ND,EN,POPNUM,POPMIN,RNE(ND),
+     >                  ENTOT(ND),RSTAR,NDIM,N,LEVEL,NCHARG,
+     $                  WEIGHT,ELEVEL,EION,EINST,ALPHA,SEXPO,
      $                  ADDCON1, ADDCON2, ADDCON3, 
      $                  IGAUNT,NOM,NF,XLAMBDA,FWEIGHT,
      $                  MAXATOM,SIGMATHK,SEXPOK,EDGEK,KODAT,
      $                  KONTNUP,KONTLOW,LASTKON, DENSCON, FILLFAC, 
      >                  BKUDRITZKI, OPARND)
 
-c      IF (OPSYS .EQ. 'CRAY') THEN
-c        CALL SECOND(TBEGIN)
-c      ENDIF
+      IF (OPSYS .EQ. 'CRAY') THEN
+        CALL SECOND(TBEGIN)
+      ENDIF
 
 C***  SOLUTION OF THE TRANSFER EQUATION AT EACH FREQUENCY-POINT ********
       DO L=1, ND
          ENTOT(L) = ENTOT(L) * DENSCON(L)
       ENDDO
       DO 1 K=NEXTK,NF
-      CALL COOP (XLAMBDA(K),ND,T,RNE,POPNUM,ENTOT,RSTAR,
+      CALL COOP (XLAMBDA(K),ND,T,RNE,POPNUM,POPMIN,ENTOT,RSTAR,
      $           OPA,ETA,THOMSON,IWARN,MAINPRO,MAINLEV,NOM,KODAT,
      $           NDIM,N,MAXATOM,LEVEL,NCHARG,WEIGHT,ELEVEL,EION,EINST,
      $           ALPHA,SEXPO,
@@ -256,50 +274,57 @@
       CALL ELIMIN (XLAMBDA(K),EMFLUX(K),FLUXIN,U,Z,
      $          A,B,C,W,BX,WX,XJC,RADIUS,P,BCORE,DBDR,
      $          OPA,ETA,THOMSON,EDDI,ND,NP,NPDIM,ENTOT,K,
-     $           IWARNES, ST, BELIFI, IVERS)
+     $           IWARNES, IWARNES2, ST, BELIFI, IVERS)
 C***  INTEGRATION OF THE TOTAL INCIDENT AND EMERGENT FLUX
       TOTIN=TOTIN+FLUXIN*FWEIGHT(K)
       TOTOUT=TOTOUT+EMFLUX(K)*FWEIGHT(K)
  
 C***  WRITING ON THE MODEL FILE
+      IF (bNoARAD .OR. (.NOT. bCLXJC)) THEN
       WRITE (NAME, '(A3, I4, A1)') 'XJC', K, ' '
       CALL WRITMS(3,XJC,ND,NAME,-1, IDUMMY, IERR)
+      ENDIF
       IF (K <= 999) THEN
         WRITE (NAME, '(A4, I3, A1)') 'EDDI', K, ' '
       ELSE
         WRITE (NAME, '(A4, I4)') 'EDDI', K
       ENDIF
       CALL WRITMS (3,EDDI,3*ND,NAME,-1, IDUMMY, IERR)
-      LASTK=K
  
-C***  The following feature is disabled !! wrh 20-Mar-2024
 C***  ABORT, IF NOT SUFFICIENT TIME LEFT FOR NEXT FREQUENCY POINT
-c      IF (K.EQ.NF) GOTO 1
-c      KDONE=K+1-NEXTK
-c      IF (OPSYS .EQ. 'CRAY') THEN
-c        CALL SECOND(TNOW)
-c        TUSED=TNOW-TBEGIN
-c        CALL TREMAIN (TLEFT)
-c        TPERK=TUSED/FLOAT(KDONE)
-c      ELSE
-c        TLEFT = 20.
-c        TPERK = 1.
-c      ENDIF
-c      IF (TLEFT.LT.TPERK*10.0) THEN
-c            CALL REMARK ('CP TIME NEARLY ELAPSED')
-c            WRITE (0,2) LASTK,NF
-c    2       FORMAT (I3,' OF ',I3,' FREQUENCY POINTS COMPLETED')
-c            GOTO 6
-c            ENDIF
+      LASTK=K
+      IF (K.EQ.NF) GOTO 1
+      KDONE=K+1-NEXTK
+      IF (OPSYS .EQ. 'CRAY') THEN
+        CALL SECOND(TNOW)
+        TUSED=TNOW-TBEGIN
+        CALL TREMAIN (TLEFT)
+        TPERK=TUSED/FLOAT(KDONE)
+      ELSE
+        TLEFT = 20.
+        TPERK = 1.
+      ENDIF
+      IF (TLEFT.LT.TPERK*10.0) THEN
+            CALL REMARK ('CP TIME NEARLY ELAPSED')
+C!!!            ASSIGN 2 TO LABEL
+C!!!            CALL REMARKF (LABEL,LASTK,NF)
+            WRITE (0,2) LASTK,NF
+    2       FORMAT (I3,' OF ',I3,' FREQUENCY POINTS COMPLETED')
+            GOTO 6
+            ENDIF
     1 CONTINUE
  
     6 CONTINUE
 
 C***  OUTPUT OF WARNING FOR SMALL EDDIS (F)
       IF (IWARNES .GT. 0) THEN
-        WRITE (0,*) 'WRCONT > ELIMIN: ', IWARNES, ' WARNINGS:'
-        WRITE (0,*) 'Either:  Eddies (F) smaller than 0.01 '
-        WRITE (0,*) 'or    :  Jcont .le. 0'
+        WRITE (hCPR,*) 'WRCONT > ELIMIN: ', IWARNES, ' WARNINGS:'
+        WRITE (hCPR,*) 'Either:  Eddies (F) smaller than 0.01 '
+        WRITE (hCPR,*) 'or    :  Jcont .le. 0' 
+      ENDIF
+      IF (IWARNES2 .GT. 0) THEN
+        WRITE (hCPR,*) 'WRCONT > ELIMIN: ', IWARNES2, ' WARNINGS:'
+        WRITE (hCPR,*) 'Eddies (F) larger than 1.0 '
       ENDIF
 
 C***  UPDATING THE MODEL HISTORY
Only in ../../powr-refactor/src/: wrstart.exe
Only in ../../powr-refactor/src/: wrstart.exe.opt
diff -bur ./wrstart.f ../../powr-refactor/src/wrstart.f
--- ./wrstart.f	2024-07-28 13:14:44.000000000 +0200
+++ ../../powr-refactor/src/wrstart.f	2023-09-27 10:14:15.129755873 +0200
@@ -13,10 +13,11 @@
 C***  DEFINE ARRAY DIMENSIONS
       INTEGER, PARAMETER :: MAXATOM =          26 
       INTEGER, PARAMETER :: NDIM    =         2560 
-      INTEGER, PARAMETER :: NFDIM   =  2*NDIM + 400 
-      INTEGER, PARAMETER :: MAXIND  =        45000 
-      INTEGER, PARAMETER :: MAXFEIND  =       1500 
+      INTEGER, PARAMETER :: NFDIM   =  2*NDIM + 400 + 1000  !wrstart needs higher NFDIM buffer due to FGRID setup
+      INTEGER, PARAMETER :: MAXIND  =        40000 
+      INTEGER, PARAMETER :: MAXFEIND  =       2500 
       INTEGER, PARAMETER :: MAXKONT =      NFDIM/2 
+      INTEGER, PARAMETER :: MAXKODR =         NDIM 
       INTEGER, PARAMETER :: NDDIM   =           89 
       INTEGER, PARAMETER :: NPDIM   =           94 
       INTEGER, PARAMETER :: MAXHIST =         4000 
@@ -37,19 +38,18 @@
       !INCRIT in common block has been replaced by IDUMP as it is never used there
 
 C***  HANDLING OF DIELECTRONIC RECOMBINATION / AUTOIONIZATION (SUBR. DATOM)
-      INTEGER, PARAMETER :: MAXAUTO = 2850
+      INTEGER, PARAMETER :: MAXAUTO = 3200
       INTEGER, DIMENSION(MAXAUTO) :: LOWAUTO, IONAUTO, KRUDAUT
       REAL, DIMENSION(MAXAUTO) :: WAUTO, EAUTO, AAUTO, WSTABIL
-      CHARACTER*10 LEVUPAUTO(MAXAUTO), LEVAUTO(MAXAUTO)
 
-      INTEGER, DIMENSION(NDIM) :: NCHARG, MAINQN, NOM, IONGRND
-      INTEGER, DIMENSION(MAXKONT) :: KONTNUP, KONTLOW, NFEDGE
-      CHARACTER*8 IGAUNT(MAXKONT), KEYCBF(MAXKONT)
+      INTEGER, DIMENSION(NDIM) :: NCHARG, MAINQN, NOM, IONGRND,
+     >                            INDRBS, IFRBSSTA, IFRBSEND, IFES
+      INTEGER, DIMENSION(MAXKONT) :: IGAUNT, KONTNUP, KONTLOW, 
+     >                               KEYCBF, NFEDGE
       INTEGER, DIMENSION(MAXATOM) :: KODAT, NFIRST, NLAST
       INTEGER, DIMENSION(NDDIM) :: IDUMP
-c      INTEGER, DIMENSION(NFDIM) :: KEY
-      CHARACTER*8 KEY(NFDIM)
       INTEGER, DIMENSION(MAXIND) :: INDNUP, INDLOW
+      INTEGER, DIMENSION(MAXKODR) :: KODRNUP, KODRLOW
 
       REAL, DIMENSION(NDIM) :: WEIGHT, ELEVEL, EION, ENLTE
       REAL, DIMENSION(MAXKONT) :: ALPHA, SEXPO,
@@ -61,14 +61,15 @@
      >                          RHO, XMU, VELOold, RADIUSold, GEFFL,
      >                          ARAD, APRESS, VTEMP, DR, RI, OLDGRADI,
      >                          GAMMARAD, EN, TAUTHOM, TAUGREY, 
-     >                          GRSTATIC,
+     >                          VTURB, VMIC, GRSTATIC,
 C***  PROVIDE VARIABLES FOR THE READ OF THE SECOND MODEL FOR TEMPERATURE 
 C***    INTERPOLATION
      >                          T2, RADIUS2, TOLD2, ROLD2, TEFFOLD2
       REAL, DIMENSION(NPDIM) :: P
       REAL, DIMENSION(NDDIM,NPDIM) :: Z
+      REAL, DIMENSION(NDDIM,NFDIM) :: XJCold
       REAL, DIMENSION(NFDIM) :: XLAMBDA, XLAMBDA2, FWEIGHT,
-     >                          EXPFAC, OPAC, ETAC
+     >                          EXPFAC, OPAC, ETAC, XLAMBDAold
       REAL, DIMENSION(NFDIM,MAXKONT) :: SIGMAKI
       REAL, DIMENSION(NFDIM,0:MAXION) :: SIGMAFF
       REAL, DIMENSION(4,NDIM) :: ALTESUM
@@ -77,42 +78,47 @@
       REAL, DIMENSION(NDDIM,NDIM) :: POPNUM
 
       REAL, DIMENSION(MAXXDAT) :: XDATA
-      REAL, DIMENSION(MAXATOM,MAXATOM) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXATOM,MAXION) :: SIGMATHK, SEXPOK, EDGEK
+      REAL, DIMENSION(MAXION) :: TFEEXC
 
 C***  IRON: COMMON BLOCK FOR IRON-SPECIFIC DATA
-C***  include "dimblock"
-      INTEGER, PARAMETER :: INDEXMAX = 1E7, NFEREADMAX = 3E5    !std
-C      INTEGER, PARAMETER :: INDEXMAX = 4E7, NFEREADMAX = 5E5    !vd20
-C      INTEGER, PARAMETER :: INDEXMAX = 1E8, NFEREADMAX = 6E5    !xxl
-
-      COMMON /IRON/ FEDUMMY(NFEREADMAX),
-     >              INDRB(MAXFEIND),INDRF(MAXFEIND), SIGMAFE(INDEXMAX),
-     >              IFRBSTA(MAXFEIND), IFRBEND(MAXFEIND),
-     >              IFENUP(MAXFEIND), IFELOW(MAXFEIND),
-     >              SIGMAINT(MAXFEIND)
+C      INTEGER, PARAMETER :: INDEXMAX = 4000000, NFEREADMAX = 100000     !standard vd100
+C      INTEGER, PARAMETER :: INDEXMAX = 7000000, NFEREADMAX = 300000     !standard vd100
+C      INTEGER, PARAMETER :: INDEXMAX = 5000000, NFEREADMAX = 150000     !vd50
+c      INTEGER, PARAMETER :: INDEXMAX = 15000000, NFEREADMAX = 400000    !vd20
+      INTEGER, PARAMETER :: INDEXMAX = 100000000, NFEREADMAX = 600000    !custom hydro
+c      INTEGER, PARAMETER :: INDEXMAX = 100000000, NFEREADMAX = 600000    !xxl branch
+C      INTEGER, PARAMETER :: INDEXMAX = 12000000, NFEREADMAX = 300000    !Goetz       
+      REAL, DIMENSION(NFEREADMAX) :: FEDUMMY
+      REAL, DIMENSION(INDEXMAX) :: SIGMAFE
+      REAL, DIMENSION(MAXFEIND) :: SIGMAINT
+      INTEGER, DIMENSION(MAXFEIND) :: INDRB, INDRF, IFRBSTA, IFRBEND,
+     >                                IFENUP, IFELOW
+      LOGICAL :: bFEULSEP
 
       INTEGER :: N, ND, NDold, JOBNUM, NATOM, LASTIND, IDX, IERR,
-     >           NAUTO, IDUMMY, MAXITTAU, ITTAU, LASTINDALL,
-     >           LASTKON, LASTFE, LAST, IFLAG, L,
+     >           NAUTO, IDUMMY, MAXITTAU, ITTAU, IERRVELO, LASTINDALL,
+     >           LASTKON, LASTKDR, LASTFE, LAST, IFLAG, L, J,
      >           NA, NF, NF2, MASSORIGIN, NP, JOBNOLD, JOBNOLD2,
-     >           INDRB, INDRF, IFEUP, IFELOW, IFRBSTA, IFRBEND,
-     >           NEXTK, IFENUP, LRTinput, NC, NDv, MDOTINPUT,
-     >           LOW, INDDR, N_WITH_DRLEVELS
+     >           NEXTK, LRTinput, NC, NDv, NFold, LASTSELF, 
+     >           LOW, INDDR, MDOTINPUT, N_WITH_DRLEVELS
 
       REAL :: GLOG, GEFFLOG, GEDD, TROLD, VMINOLD, VMINOLD2, FM,
      >        qpLINK_USER, BLACKEDGE, VA, RCSAVE, Vfac, GFLSAV,
-     >        SIGMAFE, FEDUMMY, VDOPFE, DXFE, XLAM0FE, SIGMAINT,
+     >        VDOPFE, DXFE, XLAM0FE, XMSTARold, DTAUCDTAUTH,
      >        TAUMAX, TAUACC, VFINAL, XMASS, ATMEAN, STAPEL, AMIN,
      >        RSTAR, RMAX, VDOP, XMSTAR, TFAC, XMDOT, XLOGL, RTRANS,
      >        DENSCON_FIX, VMIN, TEFF, TEFFOLD, TMIN, TMIN2, TS, RL,
-     >        R23, OLDRADI, OLDVELO, TROLD2, RCON, TOTOUT, BETA,
+     >        R23, TAU23, OLDRADI, OLDVELO, TROLD2, RCON, TOTOUT, BETA,
      >        VPAR1, VPAR2, BETA2, BETA2FRACTION, HSCALE, VMINhydro,
-     >        VPAR1_2, VPAR2_2, TMODIFY, SPHERIC, XMDOTold, 
-     >        VTURB, RCONold, fHYDROSTART, XMG, XMGold,
+     >        VPAR1_2, VPAR2_2, TMODIFY, SPHERIC, XMDOTold, VoldMod,
+     >        RCONold, fHYDROSTART, XMG, XMGold, VTURBND, RADEXP,
      >        dummy, GRADLAST, GRADIL, STEPDAMP, RINT, PL, PLP,
-     >        RHOINT, VINMAX, GAMMAL, RSTARold,
-     >        RADGAMMASTART, GEDDRAD, GEDDPRINT, XLAMBLUE,
-     >        VFINALSCALE, DTDRIN_OLD
+     >        RHOINT, VINMAX, VMINcard, GAMMAL, RSTARold, TL, ENE,
+     >        RADGAMMASTART, GEDDRAD, GEDDPRINT, RCRIT, POPMIN,
+     >        XLAMBLUE, VNDold, VFINALold, RMAXnew,
+     >        VL, DVDR, NORMINERTIA, DTDRIN_OLD, DV, RRMAXDIFF,
+     >        DCINF_OLD, XLOGLold
 
       CHARACTER(MAXHIST*8) :: MODHIST
       CHARACTER(80), DIMENSION(3) :: RadiusGridParameters
@@ -120,19 +126,20 @@
       CHARACTER(10), DIMENSION(NDIM) :: LEVEL
       CHARACTER(100) :: MODHEAD, MODOLD, MODOLD2
       CHARACTER(10), DIMENSION(MAXATOM) :: ELEMENT
+      CHARACTER(10), DIMENSION(MAXAUTO) :: LEVUPAUTO, LEVAUTO
       CHARACTER(8), DIMENSION(NDDIM) :: VELOCRITERION
+      CHARACTER(8), DIMENSION(NFDIM) :: KEY
       CHARACTER(4), DIMENSION(MAXIND) :: KEYCBB
       CHARACTER(2) :: WRTYPE
       CHARACTER(2), DIMENSION(MAXATOM) :: SYMBOL
-      CHARACTER(80) :: DENSCON_LINE, ThinCard
+      CHARACTER(120) :: DENSCON_LINE, ThinCard,VTURB_LINE,DRLINES_CARD
       CHARACTER(6) :: BUFFER6
-      CHARACTER(8) :: BUFFER8, GEFFKEY
+      CHARACTER(8) :: BUFFER8, GEFFKEY, CVEXTEND
       CHARACTER(9) :: MLRELATION
       CHARACTER(144) :: BUFFER144
-      CHARACTER*80 DRLINES_CARD
 
       LOGICAL :: TTABLE, OLDTEMP, TEXIST, VPLOT, THIN, NEWVELO, BTWOT,
-     >           OLDFGRID, LTESTART
+     >           OLDFGRID
       LOGICAL :: BFEMODEL
       LOGICAL :: BTAUR
       LOGICAL :: bTauFix,             !true if fix option has been set in the TAUMAX CARDS line
@@ -142,15 +149,25 @@
      >           bSaveGEFF,            !if true geff is used for hydrostatic scale height instead of g
      >           bOLDSTART,           !true if OLDSTART CARDS option has been set
      >           bThinImprove,        !true if THIN artistic has already been run in this iteration
-     >           bOldStratification,  !true if OLD STRATIFICATION option has been set in the CARDS file
+     >           bOldMdot,            !true if MDOT option has been set in OLD V line
      >           bHYDROSOLVE,         !true if hydrodynamic consistent model should be obtained
+     >           bOVTauMax,           !true if TAUMAX option has been set on OLD STRATIFICATION card
+     >           bOVTauCut,           !true if TAUCUT option has been set on OLD V line
      >           bHScaleOnly,         !determines if INITVEL calulates only HSCALE or full static law
      >           bFULLHYDROSTAT,      !if true, VELTHIN uses full GAMMA instead of EDDINGTON GAMMA
      >           bGAMMARADMEAN,       !if true, a mean value for GAMMARAD is used instead of individuals
-     >           bOLDRAD,             !use old radiation field for HYDROSTATIC INTEGRATION if possible
      >           bGREYSTART,
-     >           bNDfirst
-      INTEGER :: GEddFix              ! > 0 if GEDD should kept fixed in all calculations
+     >           bNDfirst,
+     >           bSMOCO,
+     >           bOLDMODEL,           !true is old MODEL file exists
+     >           LTESTART,
+     >           bForceDCUpdate,
+     >           bOLDJ,               !true if XJC from old MODEL file is used  
+     >           bDCSCALE             !true if old DENSCON stratification should be scaled to new D_inf
+      INTEGER :: GEddFix,             ! > 0 if GEDD should kept fixed in all calculations
+     >           iOldStratification,  ! > 0 if OLD STRATIFICATION option has been set in the CARDS file
+     >           iOLDRAD              !use continuum approximation (1) or old radiation field (2)
+                                      ! for HYDROSTATIC INTEGRATION if possible
 
       REAL, EXTERNAL :: WRVEL
 
@@ -165,11 +182,15 @@
       INTEGER :: ITAB = 0
        
       !Konstanten
+      REAL, PARAMETER :: PI4 = 12.5663706144    !PI4 = 4*PI
       REAL, PARAMETER :: AMU = 1.66E-24     !atomic mass unit (constant)
+      REAL, PARAMETER :: CLIGHT = 2.99792458E10 !SPEED OF LIGHT IN CM / SECOND
       REAL, PARAMETER :: RSUN = 6.96E10     !SOLAR RADIUS ( CM )
       REAL, PARAMETER :: BOLTZ = 1.38E-16   !BOLTZMANN CONSTANT (ERG/DEG)
       REAL, PARAMETER :: RGAS = 8.3145E7    !Gas Constant (CGS)
       REAL, PARAMETER :: GCONST = 6.670E-8  !GRAVITATION CONSTANT (CGS UNITS)
+      REAL, PARAMETER :: STEBOL = 5.6705E-5     !STEBOL = STEFAN-BOLTZMANN CONSTANT (CGS-UNITS)     
+      REAL, PARAMETER :: TEFFSUN = 5780.        !SOLAR EFFECTIVE TEMPERATURE
       REAL, PARAMETER :: XMSUN = 1.989E33   !XMSUN = Solar Mass (g)
 
       !File and channel handles (=KANAL)
@@ -202,11 +223,11 @@
 
       CALL INSTALL
 
-c      IF (OPSYS .EQ. 'CRAY') THEN
-c        CALL CLOCK(TIM1)
+      IF (OPSYS .EQ. 'CRAY') THEN
+        CALL CLOCK(TIM1)
 c      ELSE
 c        CALL TIME(TIM1)
-c      ENDIF
+      ENDIF
 
       !Put dummy stuff into COMMON block data to ensure storage reservation
       NDv = NDDIM
@@ -221,6 +242,8 @@
 
 C***  INITIALIZE SOME VARIABLES (TODT 04.05.2010)
       TROLD = 0.
+      RCRIT = -1.
+      DTDRIN_OLD = -1.
 
 C***  READ ATOMIC DATA FROM FILE "DATOM"
       CALL       DATOM (NDIM,N,LEVEL,NCHARG , WEIGHT,ELEVEL,EION,MAINQN,
@@ -232,13 +255,38 @@
      $                  SIGMATHK,SEXPOK,EDGEK,NFIRST,
      $                  NLAST,NAUTO,MAXAUTO,LOWAUTO,WAUTO,EAUTO,AAUTO,
      $                  IONAUTO,KRUDAUT,KONTNUP,KONTLOW,LASTKON,MAXKONT,
-     $                  IONGRND, KEYCBF,
+     $                  IONGRND,KEYCBF,
 C***  IRON: ADDITIONAL PARAMETERS FOR IRON-GROUP LINE BLANKETING
      >            'WRSTART', INDEXMAX, NFEREADMAX, MAXFEIND,
      >             LASTFE, SIGMAFE, INDRB, INDRF,
      >             IFENUP, IFELOW, IFRBSTA, IFRBEND, FEDUMMY,
      >             VDOPFE, DXFE, XLAM0FE, SIGMAINT, BFEMODEL,
-     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS)
+     >             LEVUPAUTO, LEVAUTO, N_WITH_DRLEVELS, MAXION)
+
+C***  Check for possible old model and read values that
+C***  might be needed before DECSTAR due to CARDS options
+      CALL OPENMS (hOldMODEL, IDUMMY, IDUMMY, 1, IERR)
+      CALL READMS (hOldMODEL, RSTARold,    1, 'RSTAR   ', IERR)
+      bOLDMODEL = (IERR /= -10)
+      IF (bOLDMODEL) THEN
+        CALL READMS (hOldMODEL, TEFFOLD,     1, 'TEFF    ', IERR)
+        XLOGLold = ALOG10( (RSTARold/RSUN)**2 * (TEFFOLD/TEFFSUN)**4 )
+        CALL READMS (hOldMODEL, XMDOTold,    1, 'XMDOT   ', IERR)
+        IF (IERR == -10) THEN
+          XMDOTold = -999.
+        ENDIF
+        CALL READMS (hOldMODEL, XMSTARold,   1, 'XMSTAR  ', IERR)
+        CALL READMS (hOldMODEL, NDold  ,     1, 'ND      ', IERR)
+        CALL READMS (hOldMODEL, DTDRIN_OLD,  1, 'DTDRIN  ', IERR)
+        CALL READMS (hOldMODEL, VELOold, NDold, 'VELO    ', IERRVELO)
+        VFINALold = VELOold(1)
+        VNDold = VELOold(NDold)
+      ELSE 
+        IERRVELO = -10
+        VNDold = -1.
+        VFINALold = -1.
+      ENDIF
+      CALL CLOSMS (hOldMODEL, IERR)
  
 C***  DECODING INPUT DATA
 C***  VDENS1,VDENS2,DENSCON_FIX und CLUMP_CRIT nach goetz...
@@ -249,19 +297,24 @@
      >              TAUMAX, TAUACC, bTauFix, BTWOT, TFAC, DENSCON_LINE, 
      >              BLACKEDGE, bOLDSTART, RadiusGridParameters, XMDOT,
      >              XLOGL, RTRANS, BTAUR, DENSCON_FIX, MASSORIGIN,
-     >              LRTinput, ELEMENT, bOldStratification, bHYDROSOLVE,
-     >              GEddFix, MLRELATION,
-     >              NC, VTURB, bOLDRAD, RADGAMMASTART, fHYDROSTART, 
-     >              bFULLHYDROSTAT, bGAMMARADMEAN, GEFFKEY, bGREYSTART,
-     >              XLAMBLUE, MDOTINPUT, LTESTART, DRLINES_CARD)
-
+     >              LRTinput, ELEMENT, iOldStratification, bHYDROSOLVE,
+     >              GEddFix, bOldMdot, VoldMod, bOVTauMax, MLRELATION,
+     >              NC, VTURBND, VTURB_LINE,
+     >              iOLDRAD, RADGAMMASTART, fHYDROSTART, 
+     >              bFULLHYDROSTAT, bGAMMARADMEAN, CVEXTEND, bGREYSTART,
+     >              GEFFKEY, POPMIN, XLAMBLUE, LTESTART, 
+     >              bOLDMODEL, XMDOTold, XMSTARold, RSTARold, VNDold,
+     >              VFINALold, bForceDCUpdate, bOLDJ, bOVTauCut, 
+     >              bDCSCALE, TEFFOLD, XLOGLold, MDOTINPUT, 
+     >              DRLINES_CARD)
 
 C***  GENERATION OF THE CONTINUOUS FREQUENCY GRID
       CALL       FGRID (NFDIM, NF, XLAMBDA, FWEIGHT, KEY, NOM, SYMBOL, 
      $                  N, NCHARG, ELEVEL, EION, EINST, NDIM,
-     $                  EDGEK,KODAT,MAXATOM,
+     $                  EDGEK,KODAT,MAXATOM, MAXION,
      $                  INDNUP, INDLOW, LASTIND, KONTNUP, KONTLOW, 
-     >                  LASTKON, OLDFGRID, NF2, XLAMBDA2, VDOP, XLAMBLUE)
+     >                  LASTKON, OLDFGRID, NF2, XLAMBDA2, 
+     >                  VDOP, XLAMBLUE)
  
 C***  ATMEAN = MEAN ATOMIC WEIGHT ( IN AMU )
       !What does ABXYZ contain?
@@ -293,21 +346,40 @@
 C***  MAXIMUM NUMBER OF ITERATIONS
       MAXITTAU = 30
       
-      IF (bOLDSTART .OR. bOLDRAD .OR. bOldStratification) THEN
+      IF (fHYDROSTART > 0.) THEN
+        !Hydrostart needs old stratification
+        iOldStratification = 2
+        THIN = .FALSE.      
+      ENDIF
+      
+      VMINcard = VMIN
+      IF (bOLDJ) THEN
+        CALL OPENMS (hOldMODEL, IDUMMY, IDUMMY, 1, IERR)
+        CALL LOADOLDJ(XJCold, XLAMBDAold, NDold, NFold, 
+     >                NDDIM, NFDIM, hOldMODEL)
+        CALL CLOSMS (hOldMODEL, IERR)
+      ENDIF
+      IF (bOLDSTART .OR. iOLDRAD > 0 .OR. iOldStratification > 0) THEN
         !use old vmin from old MODEL instead of CARDS value if OLDSTART has been set
         CALL OPENMS (hOldMODEL, IDUMMY, IDUMMY, 1, IERR)
-        CALL READMS (hOldMODEL, NDold  ,     1, 'ND      ' , IERR)
         CALL READMS (hOldMODEL, ARAD, NDold-1,   'ARAD    ', IERR)
         CALL READMS (hOldMODEL,RADIUSold,NDold,'R       ',IERR)
-        IF (IERR == -10 .AND. bOldStratification) THEN
+        IF (IERR == -10 .AND. iOldStratification > 0) THEN
           WRITE (hCPR, '(A)') 'Error: Cannot find old radius grid!'
           STOP '*** FATAL ERROR IN WRSTART'
         ENDIF
-        CALL READMS (hOldMODEL,RSTARold,1,'RSTAR   ',IERR)
-        CALL READMS (hOldMODEL, XMGold, 1, 'XMSTAR  ',IERR)
         CALL READMS (hOldMODEL,RCONold,NDold,'RCON    ',IERR)
         CALL READMS (hOldMODEL,TAUROSSOLD,NDold,'TAUROSS ',IERR)
+        CALL READMS (hOldMODEL,TAURCONTOLD, NDold, 'TAURCONT', IERR)
+        IF (IERR == -10) THEN
+          WRITE (hCPR, '(A)') 'Warning: Could not find TAURCONT in '
+     >      // 'old MODEL file. Using TAUROSS instead.'
+          DO L=1, NDold
+            TAURCONTOLD(L) = TAUROSSOLD(L)
+          ENDDO
+        ENDIF
         CALL READMS (hOldMODEL,DENSCON_OLD,NDold,'DENSCON ',IERR)
+        DCINF_OLD = DENSCON_OLD(1)
         DO L=1,NDold
           IF (DENSCON_OLD(L) <= 0. ) THEN
               IF (DENSCON_OLD(1) <= 0.) THEN
@@ -317,17 +389,20 @@
      >            // 'from OLD model during WRSTART'
               ENDIF
               DENSCON_OLD(L) = DENSCON_OLD(1)
-              FILLFAC_OLD(L) = 1. / DENSCON_OLD(L)
-          ELSE
-              FILLFAC_OLD(L) = 1. / DENSCON_OLD(L)
           ENDIF
+          IF (bDCSCALE) THEN
+C***        OLD V DCSCALE option:
+C***        scale old clumping stratification to match a new D_inf
+            DENSCON_OLD(L) = (DENSCON_OLD(L) - 1.) 
+     >        * (DENSCON_FIX - 1.)/(DCINF_OLD - 1.) + 1.
+          ENDIF
+          FILLFAC_OLD(L) = 1. / DENSCON_OLD(L)
         ENDDO
         
-        XMGold = XMGold * GCONST * XMSUN
-        IF (IERR /= -10) THEN
-          CALL READMS (hOldMODEL, VELOold, NDold, 'VELO    ' , IERR)
+        XMGold = XMSTARold * GCONST * XMSUN
           IF (IERR /= -10) THEN
-            IF (bOldStratification) THEN
+          IF (IERRVELO /= -10) THEN
+            IF (iOldStratification > 0) THEN
               VMIN = VELOold(NDold)
               CALL READMS (hOldMODEL,VCRITold,NDold,'VCRIT   ' ,IERR)
               IF (IERR == -10) THEN
@@ -339,23 +414,119 @@
                 OLDVELO(L) = VELOold(L)
               ENDDO              
               NDv = NDold
-              IF (ABS(VFINAL-VELOold(1)) .GT. 0.01) THEN
-                WRITE (hCPR,'(A,/,2(A,F8.2),/,A)') 
-     >           '*** WARNING: VFINAL differs from the OLDSTART model:',
-     >           '*** VFINAL (old): ', VELOold(1), '  (new): ', VFINAL,
-     >           '*** this enforces a scaling!'
-                VFINALSCALE = VFINAL / VELOold(1)                              
+              VFINAL = VELOold(1)
+              IF (VoldMod /= 1.) THEN
+                IF (VoldMod < 0.) THEN
+                  VFINAL = ABS(VoldMod)
+                  VoldMod = VFINAL / VELOold(1)
+                ENDIF
+                !now scale with given facor
                 DO L=1, NDold
-                  OLDVELO(L) = VFINALSCALE * VELOold(L)
+                  OLDVELO(L) = VoldMod * VELOold(L)
                 ENDDO
                 VFINAL = OLDVELO(1)
                 VMIN = OLDVELO(NDold)
+                WRITE (hCPR,'(A,F8.2)') 
+     >            'Adjusted old velocity field to VFINAL = ', VFINAL
               ENDIF
-
-              IF (RADIUSold(1) < RMAX) THEN
+              IF (LEN_TRIM(CVEXTEND) > 0) THEN
+C***            CVEXTEND options allow you to change
+C***            (and especially enlarge) RMAX when using OLD V 
+C***            We do this on a logarithmic scale of r/RSTAR in order 
+C***            to get a suitable stretch on the whole range.
+                RADEXP = LOG10(RMAX)/LOG10(OLDRADI(1))
+                DO L=1, NDold
+                  RADIUSold(L) = RADIUSold(L)**RADEXP
+                ENDDO
+C***            If RCONold is outside of radius grid, we need to ensure this now#
+                IF (RCONold > OLDRADI(1)) THEN
+                  RCONold = 1.1 * RADIUSold(1) + 1.
+                ENDIF      
+C***            @TODO: HOW TO HANDLE OLD V TAU?         
+                IF (CVEXTEND == 'STRETCH') THEN
+C***              In the STRETCH option, we scale the old velocity
+C***              with regards to the radius scale, i.e. the radius
+C***              vector is changed but the velocity field vector is left 
+C***              untouched
+                  IF (RCONold <= OLDRADI(1)) THEN
+                    RCONold = RCONold**RADEXP
+                  ENDIF
+                  DO L=1, NDold
+                    OLDRADI(L) = OLDRADI(L)**RADEXP
+                  ENDDO
+                  WRITE (hCPR,'(A,F8.2)') 'Old velocity field '
+     >              // ' is stretched to a new RMAX by exponentiation '
+     >              // ' of the radius grid to the power ', RADEXP
+                ELSEIF (CVEXTEND == 'EXTRAP') THEN
+C***              In the EXTRAP option the velocity field is simply
+C***              continued outwards using the outermost gradient
+                  CALL SPLINPOX(VL, OLDRADI(1), OLDVELO, OLDRADI, NDold,
+     >                                     DFDX=DVDR)
+ccc               TEST: Outermost point should have intended v_inf 
+                  OLDRADI(1) = RMAX
+                  DO L=1, NDold
+                    IF (RADIUSold(L) > OLDRADI(1)) THEN
+C***                  linear extrapolation of v(r)
+                      VELOold(L) = OLDVELO(1) 
+     >                              + DVDR * (RADIUSold(L)-OLDRADI(1)) 
+                    ELSEIF (RADIUSold(L) < OLDRADI(NDold)) THEN
+C***                  This should only happen due to numerical inaccuracy
+C***                    and thus never more than once!
+                      VELOold(L) = OLDVELO(NDold)
+                    ELSE 
+                      CALL SPLINPOX(VELOold(L), RADIUSold(L), 
+     >                                          OLDVELO, OLDRADI, NDold)
+                    ENDIF
+                  ENDDO
+C***              Copy into OLD*-vectors which are later used for
+C***              estabilishing the new grid in GEOMESH->RGRID->WRVEL                  
+                  DO L=1, NDold
+                    OLDRADI(L) = RADIUSold(L)
+                    OLDVELO(L) = VELOold(L)
+                  ENDDO              
+C***              RCONold is not changed since we only extrapolate                   
+                  WRITE (hCPR,'(A,F8.2)') 'Old velocity field '
+     >              // ' is extended to a new RMAX by extrapolation. '
+                ENDIF
+C***            Ensure outer boundary is exactly at desired RMAX
+                OLDRADI(1) = RMAX
+                RADIUSold(1) = RMAX
+              ELSEIF (RADIUSold(1) < RMAX) THEN
+C***            if this triggers, it is sometimes just due to numerical accuracy
+C***            TODO: Check by how many digits RMAX is given in the CARDS
+C***                  and test if the old value differs by less than this accuracy
+                RRMAXDIFF = ABS(1. - RADIUSold(1)/RMAX)
+                IF (RRMAXDIFF < 1.E-9) THEN
+C***              We attribute this to numerical accuracy: Set Rold(1) = RMAX
+                  OLDRADI(1) = RMAX
+                  RADIUSold(1) = RMAX
+                  WRITE (hCPR,'(A,F12.5)') 
+     >              '*** WARNING: RMAX was adjusted by ', RRMAXDIFF                      
+                ELSE 
+                  RMAXnew = RMAX
                 RMAX = RADIUSold(1)
-                WRITE (hCPR,'(A,F8.2)') 
-     >            '**WARNING: OLD V forces lower RMAX = ', RMAX
+                  WRITE (hCPR,'(A,F12.5)') 
+     >              '*** ERROR: OLD V forces lower RMAX = ', RMAX     
+                  WRITE (hCPR,'(2(A,F12.5))') 
+     >              '*** Current requested RMAX is = ', RMAXnew, 
+     >                  ' which differs by ', RRMAXDIFF     
+                  WRITE (hCPR,'(A)') '*** Please restart the model with'
+     >              // ' one of the following options:'
+                  WRITE (hCPR,'(A,F12.5)') '  1) Adjust the RMAX option'
+     >              // ' on the VELPAR card to the lower value RMAX = ', 
+     >              RMAX
+                  WRITE (hCPR,'(A)') '     (Make sure that the'
+     >              // ' RMAX_IN_RSUN option is switched off)'
+                  WRITE (hCPR,'(A)') '  2) Add the STRETCH option to'
+     >              // ' the OLD STRATIFICATION (or OLD V) card'
+                  WRITE (hCPR,'(A)') '     (This will stretch the old'
+     >              // ' velocity field to the new RMAX)'
+                  WRITE (hCPR,'(A)') '  3) Add the EXTRAP option to the'
+     >              // ' OLD STRATIFICATION (or OLD V) card'
+                  WRITE (hCPR,'(A)') '     (This will extrapolate the'
+     >              // ' old velocity field to the new RMAX)'
+                  STOP '*** FATAL ERROR IN WRSTART' 
+                ENDIF 
               ENDIF
 C***          We Use old RCON if inside the old radius grid
 C***          However, this can only be done after the GEOMESH call,
@@ -363,34 +534,153 @@
 C***          BETA law parameters. Therefore ensure interpolation 
 C***          in WRVEL by setting RCON > RMAX
               RCON = 1.5 * RADIUSold(1)
-
-              IF (fHYDROSTART > 0.) THEN
+C***          TODO: check if the following lines still make sense!!!
+              IF (bOldMdot) THEN
+                CALL READMS (hOldMODEL,XMDOTold,1,'XMDOT   ',IERR)
+                IF (VoldMod /= 1.) THEN
+                  XMDOTold = XMDOTold + LOG10(VoldMod)
+                ENDIF
+                IF (IERR /= -10) THEN
+                  XMDOT = XMDOTold 
+                  FM= 10.**(XMDOT+3.02) * (RSUN/RSTAR)**2
+                  RTRANS = 0.
+                ENDIF
+              ENDIF
+              IF (bOVTauMax .OR. fHYDROSTART > 0.) THEN
                 CALL READMS (hOldMODEL, T, NDold,     'T       ', IERR)
                 CALL READMS (hOldMODEL, RNE, NDold,   'RNE     ', IERR)
                 DO L=1, NDold
                   XMU(L) = ATMEAN / (1. + RNE(L))
                 ENDDO
               ENDIF
+              IF (bOVTauMax) THEN
+                CALL READMS (hOldMODEL, RCSAVE, 1, 'RCSAVE  ', IERR)
+                IF (IERR == -10) THEN
+                  !use sonic point instead of critical point
+                  sploop: DO L=NDold, 1, -1
+                    VA = SQRT(RGAS * T(L) / XMU(L)) * 1.E-5
+                    IF (OLDVELO(L) > VA) THEN
+                      RCSAVE = OLDRADI(L) 
+                      EXIT sploop
+                    ENDIF
+                  ENDDO sploop                         
+                ENDIF
+              ENDIF
+              IF (fHYDROSTART > 0.) THEN
+                CALL READMS (hOldMODEL, ENTOT, NDold, 'ENTOT   ', IERR)
+                CALL READMS (hOldMODEL, OLDGRADI, NDold, 'GRADI   ', IERR)
+                DO L=1, NDold
+                  RHO(L) = ENTOT(L) * AMU * ATMEAN
+                ENDDO
+                CALL READMS (hOldMODEL, VMIC, NDold, 'VMIC    ', IERR)
+                IF (IERR == -10) THEN                
+                  CALL READMS (hOldMODEL,VTURB(NDold),1,'VTURB   ',IERR)
+                  IF (IERR == -10) THEN
+                    VTURB(1:NDold) = 0.
+                  ELSE
+                    DO L=1, NDold-1
+                      VTURB(L) = VTURB(NDold)
+                    ENDDO
+                  ENDIF
+                ELSE
+                  DO L=1, NDold
+                    VTURB(L) = VMIC(L) / SQRT(2.)
+                  ENDDO
+                ENDIF
+                DO L=1, NDold-1
+                  RI(L) = 0.5 * ( OLDRADI(L) + OLDRADI(L+1) )
+                  DR(L) = OLDRADI(L) - OLDRADI(L+1) 
+                  PL  = RHO(L)*(RGAS*T(L)/XMU(L) + (VTURB(L)*1.E5)**2.)
+                  PLP = RHO(L+1)*(RGAS*T(L+1)/XMU(L+1)
+     >                                          +(VTURB(L+1)*1.E5)**2.)
+                  RHOINT = 0.5 * ( RHO(L) + RHO(L+1) )
+                  APRESS(L) = - (PL - PLP) / (DR(L) * RSTAR) / RHOINT
+                ENDDO       
+                
+                VINMAX = MAX(VMINcard, 10 * OLDVELO(NDold))
+                VINMAX = VINMAX * 1.E5
+                RINT = RI(NDold-1) 
+                XMG = GCONST * XMSTAR * XMSUN
+                CALL SPLINPOX (GRADIL, RINT, OLDGRADI, OLDRADI, NDold)
+                RINT = RINT * RSTAR
+                GRADIL = GRADIL * 1.E5 / RSTAR
+                VTEMP(ND) = ( ARAD(ND-1)+APRESS(ND-1)-XMG/(RINT**2) )
+     >                              /GRADIL 
+                IF ( VTEMP(ND) < 0.) THEN
+                  VTEMP(ND) = MAX(VMINcard, 10 * OLDVELO(ND))
+                  VTEMP(ND) = VTEMP(ND) * 1.E5
+                ENDIF
+                WRITE (hCPR,*) VTEMP(ND) /1.E5, GRADIL/1.E5*RSTAR
+                DO WHILE (VTEMP(ND) > VINMAX .OR. VTEMP(ND) < 0.)
+                  IF (VTEMP(ND) < 1.E-10) THEN
+                    GRADIL = GRADIL / 2.
+                  ELSE
+                    GRADIL = GRADIL * 1.2
+                  ENDIF
+                  VTEMP(ND) = ( ARAD(ND-1)+APRESS(ND-1)-XMG/(RINT**2) )
+     >                             / GRADIL
+                  WRITE (hCPR,*) VTEMP(ND) /1.E5, GRADIL/1.E5*RSTAR
+                ENDDO
+                DO L=NDold-1, 2, -1
+                  IF (GRADIL > 0) THEN
+                    GRADLAST = GRADIL
+                  ENDIF
+                  VTEMP(L) = VTEMP(L+1) + GRADIL * DR(L) * RSTAR
+                  RINT = RI(L) * RSTAR
+                  GRADIL = ( ARAD(L)+APRESS(L)-XMG/(RINT**2) ) /VTEMP(L)
+                  IF (GRADIL <= 0.) THEN
+                    GRADIL = GRADLAST * 0.75
+                  ENDIF
+                  GRADIL = MAX(0., GRADIL)
+C                  WRITE (hCPR,*) 'L, v (km/s) :', L, VTEMP(L) /1.E5
+                ENDDO
+                VTEMP(1) = VTEMP(2) + GRADIL * DR(1) * RSTAR
+                
+                !Daempfung mit fHYDROSTART
+                DO L=1, NDold
+                  VELO(L) = fHYDROSTART * VTEMP(L)/1.E5
+     >                       + (1. - fHYDROSTART) * OLDVELO(L)
+                  WRITE (hCPR,*) OLDRADI(L), VELO(L)
+                ENDDO
+                
+                !Glaettung
+                DO L=2, NDold-1
+                  VTEMP(L) = 0.25 * ( LOG10(VELO(L-1)) 
+     >              + 2. * LOG10(VELO(L)) + LOG10(VELO(L+1)) )
+                ENDDO
+                DO L=2, NDold-1
+                  VELO(L) = 10.**VTEMP(L)
+                ENDDO
+                
+                !Kopieren nach OLDVELO
+                DO L=1, NDold
+                  OLDVELO(L) = VELO(L)
+                ENDDO
+                RCON = RADIUS(1) * 1.5
+                WRITE (hCPR,*) '**STARTING with a hydrodynamic approach'
+                WRITE (hCPR,*) '**DAMPING FACTOR ', fHYDROSTART
+                
+              ENDIF
             ENDIF
-          ELSEIF (bOldStratification) THEN
+          ELSEIF (iOldStratification > 0) THEN
             !No stratification data found => create new one
             WRITE (hCPR,*) '**WARNING: OLD STRATIFICATION NOT FOUND **'
-            bOldStratification = .FALSE.
+            iOldStratification = 0
           ENDIF
         ENDIF
         CALL CLOSMS (hOldMODEL, IERR)
+        WRITE (hCPR,*) 'Oldstart: Old model has been read!'
       ELSE 
-c        WRITE (hCPR,*) 'Fresh start: No old model is used!'
+        WRITE (hCPR,*) 'Fresh start: No old model is used!'
         NDold = 1  !must be set for DIMENSION-statements in PREP_GAMMARAD
       ENDIF
       
-      
 C***  Preparation of GAMMARAD for the hydrostatic equation
-      CALL PREP_GAMMARAD (bOLDRAD, bFULLHYDROSTAT, GEDD,
+      CALL PREP_GAMMARAD (iOLDRAD, bFULLHYDROSTAT, GEDD,
      >      GEddFix, GAMMARAD, NDold, ARAD, GLOG, RSTAR,
      >      RADIUSold, RSTARold, XMGold, TAUROSSOLD, RCONold, GEFFLOG,
      >      STAPEL, ATMEAN, XLOGL, XMSTAR, RADGAMMASTART, 
-     >      GEDDRAD, bOldStratification, bGAMMARADMEAN, bSaveGEFF )      
+     >      GEDDRAD, iOldStratification, bGAMMARADMEAN, bSaveGEFF )      
       
       bNDfirst = .TRUE.
       XMG = GCONST * XMSTAR * XMSUN
@@ -412,34 +702,88 @@
 
 C***      INITIALISATION OF THE VELOCITY-FIELD PARAMETERS
 C***      Turbulence pressure added, 13-Mar-2014
-          IF (.NOT. bOldStratification) THEN
+          IF (iOldStratification == 0) THEN
             bHScaleOnly = (THIN .AND. (ITTAU > 1))
             CALL INITVEL (RMAX,TEFF,GEFFLOG,RSTAR,XMASS,
-     >                    VTURB, bHScaleOnly, bHydroStat)
+     >                    VTURBND, bHScaleOnly, bHydroStat)
             IF (ITTAU == 1 .OR. (.NOT. THIN)) NEWVELO=.TRUE.
           ELSE
-C***        Old stratification is used          
+            IF (iOldStratification == 2) THEN
             ND = NDold
             DO L=1, ND
               RADIUS(L) = OLDRADI(L)
               VELO(L) = OLDVELO(L)                
             ENDDO
+C***           Unused old version of OVTauMax option:                
+c              IF (bOVTauMax .AND. XMDOTold /= XMDOT) THEN
+cc                Vfac = VELOold(ND) / VMIN - 1.
+c                Vfac = 10**(XMDOT - XMDOTold) - 1.
+c                VELO = VELOold
+c                vfacloop: DO L=ND, 1, -1
+cc                  Vfac = Vfac * EXP(FLOAT(L-ND) / 5.) + 1.
+c                  
+c                  CALL SPLINPOX(VL, RADIUS(L),VELO,RADIUS,ND,DFDX=DVDR)
+c                  
+c                  NORMINERTIA = VL * DVDR / XMG * RADIUS(L) * RADIUS(L)
+c     >                               * RSTAR * 1.E10
+cc                  WRITE (0,*) 'NORMINERTIA = ', L, NORMINERTIA
+c                  
+c                  Vfac = (VELOold(ND) / VMIN - 1.)
+c     >                       * MAX(1.-NORMINERTIA,0.) + 1.
+c                  
+cc                  IF (RADIUS(L) >= RCSAVE) THEN
+cc                    EXIT vfacloop
+cc                  ENDIF
+c                  VELO(L) = VELO(L) / Vfac
+c                  OLDVELO(L) = VELO(L)
+c                ENDDO vfacloop
+c              ENDIF
+            ENDIF
             NEWVELO=.FALSE.
           ENDIF
 
+C***  OLD V WITH TAUMAX option: Initialize OLD..-variables with shifted
+C***  velocity field for interpolation on new grid.
+          IF (bOVTauMax .AND. VMIN /= VELOold(NDold)) THEN
+              DV = VMIN - VELOold(NDold)
+              DO L=1, NDold
+                OLDVELO(L) = VELOold(L) + DV 
+                OLDRADI(L) = RADIUSold(L)
+              ENDDO
+              WRITE (hCPR,*) 'OVTauMAX: DV = ', DV
+          ENDIF
+            
+
+
 C***      LOOP FOR IMPROVED HYDROSTATIC EQUATION ("THIN WIND" OPTION)
 C***       (MUST BE DONE TWICE, FIRST TO ESTABLISH A RADIUS MESH AND THE 
 C***        TEMPERATURE STRUCTURE, SECOND FOR THE EXACT HYDROSTATIC EQ.)
 
           bThinImprove = .FALSE.
+c          WRITE (0,*) 'ITTAU loop: ', ITTAU
 
 C         ------- THIN WIND loop ----------------------
           thinwind: DO
 
 C***  GENERATION OF THE RADIUS GRID, P-GRID, Z-GRID, AND ND
+            IF (iOldStratification > 1) THEN
+              bNoRGrid = .TRUE.
+              IF (fHYDROSTART > 0.) THEN
+                INCRIT = 'HDSTART '
+              ELSE
+                INCRIT = 'OLDMODEL'
+              ENDIF
+            ELSE
             bNoRGrid = .FALSE.
+            ENDIF
+c            WRITE (hCPR,* ) 'VMIN now = ', VMIN
+c            WRITE (hCPR,* ) 'HSCALE now = ', HSCALE
+c            DO L=1, NDv
+c              WRITE (0,*) 'OLD: ', OLDRADI(L), OLDVELO(L)
+c            ENDDO
             CALL GEOMESH (RADIUS,INCRIT,P,Z,ND,NDDIM,NP,NPDIM,RMAX, 
-     >                    RadiusGridParameters, bNoRGrid, NC)
+     >                    RadiusGridParameters, bNoRGrid,
+     >                    NC, XMG, RSTAR, RCRIT)
             IF (bNDfirst) THEN
               WRITE (hCPR,*) ' ND, NDold: ', ND, NDold
               IF (bGREYSTART) THEN
@@ -453,18 +797,43 @@
 C***  START APPROXIMATION FOR EL. DENSITY PUT INTO ARRAY (NEEDS ND)
             DO L=1, ND
                 RNE(L) = STAPEL
+              XMU(L) = ATMEAN / (1. + RNE(L))
+            ENDDO
+
+C***        TAUROSS must be initialized in the first run            
+            IF (iOldStratification > 0 .AND. ITTAU == 1) THEN
+              DO L=1, ND
+                IF (bOVTauMax) THEN
+C***              If we iterate OLD V on Tau, we cannot use the Tau-Scale from the old model
+C***              but instead will start with OLD DENSCON and then iterate with the new DENSCON
+C***              from ITTAU > 1 onwards
+                  TAURCONT(L) = -99.
+                ELSE
+C***              If we do not iterate OLD V on TauMax, there is just one run, so we need a 
+C***              Tau-Scale for the DENSCON setup.
+C***              (This option should be used if there is no serious change of TAUMAX)
+                  IF (L == 1) THEN
+C***                Numerical interpolation on the edge might give negative value, ensure zero
+                    TAURCONT(L) = 0.
+                  ELSE
+                    CALL SPLINPOX(TAURCONT(L), RADIUS(L),
+     >                             TAURCONTOLD, OLDRADI, NDold)
+                  ENDIF
+                ENDIF
             ENDDO
+            ENDIF
+            
    
 C***  READ TEMPERATURE STRUCTURE FROM OLD MODEL, IF REQUESTED
 C     (note: REQUIRES GEOMESH first for interpolation)      
             IF (OLDTEMP) THEN
               CALL READOLDT (hOldMODEL, ND, NDDIM,T,RADIUS,
      >                      TOLD,ROLD,MODOLD,JOBNOLD,TEFF,TEFFOLD,
-     >                      TAURCONT, TAURCONTOLD, BTAUR, DTDRIN_OLD)
+     >                      TAURCONT, TAURCONTOLD, BTAUR)
               IF (BTWOT) THEN
                 CALL READOLDT (hOldMODEL2, ND,NDDIM,T2,RADIUS,
      >                        TOLD2,ROLD2,MODOLD2,JOBNOLD2,TEFF,
-     >             TEFFOLD2, TAURCONT, TAURCONTOLD, BTAUR, DTDRIN_OLD)
+     >                        TEFFOLD2, TAURCONT, TAURCONTOLD, BTAUR)
                 IF (TMIN > 6000.) THEN
                   TMIN2 = TMIN
                 ELSE
@@ -483,8 +852,10 @@
             ENDIF
 
 C***  READ TEMPERATURE OR VELOCITY (OR BOTH) FROM FILE 'TABLE'
-C***  GRADI IS OVERWRITTEN AGAIN BY GRADIFF
-            IF (TTABLE) CALL TABREAD (ND,RADIUS,VELO,GRADI,T,ITAB)
+C***  READING GRADI PREVENTS ODD FEATURES DUE TO NUMERICAL DIFF IN GRADIFF
+            IF (TTABLE) THEN
+              CALL TABREAD (ND,RADIUS,VELO,GRADI,T,ITAB)
+            ENDIF
  
 C***  ENTOT = TOTAL NUMBER DENSITY OF ALL ATOMS
             DO L=1,ND
@@ -492,40 +863,24 @@
               IF (.NOT.TTABLE .OR. ITAB < 2) THEN
                 IF (NEWVELO) THEN
                   VELO(L) = WRVEL(RL)
+                ELSEIF (RL > OLDRADI(1)) THEN
+                  VELO(L) = OLDVELO(1)
                 ELSE
                   CALL SPLINPOX(VELO(L), RL, OLDVELO, OLDRADI, NDv)
                 ENDIF
               ENDIF
+cc              WRITE (0,*) 'L, R, V ', L, RL, VELO(L)
               RHO(L) = FM / RL / RL / VELO(L) / 1.E5
               ENTOT(L) = RHO(L) / AMU / ATMEAN
+cc              WRITE (0,*) 'L, R, ENTOT ', L, RL, ENTOT(L)*RNE(L)
             ENDDO            
 
+            IF (.NOT. TTABLE .OR. ITAB < 2) THEN
             CALL       GRADIFF  (ND,VELO,GRADI,RADIUS)
-            DO L=1,ND
-              XMU(L) = ATMEAN / (1. + RNE(L))
-              IF (bFULLHYDROSTAT) THEN
-                IF (bOLDRAD) THEN
-                  IF (RADIUS(L) > RADIUSold(1)) THEN
-                    GAMMAL = GAMMARAD(1)
-                  ELSEIF (RADIUS(L) < RADIUSold(NDold)) THEN
-                    GAMMAL = GAMMARAD(NDold)
-                  ELSE
-                    CALL SPLINPOX(GAMMAL, RADIUS(L), 
-     >                           GAMMARAD, RADIUSold, NDold)
-                  ENDIF
-                ELSEIF (RADGAMMASTART >= 0.) THEN
-                  GAMMAL = RADGAMMASTART
-                ELSE 
-                  GAMMAL = GEDD
-                ENDIF
-                GEFFL(L) = (10.**GLOG) * (1. - GAMMAL)
-              ELSE
-                !either Thompson only or fixed => no depth-dependent value
-                GEFFL(L) = (10.**GLOG) * (1. - GEDD)     
               ENDIF
-            ENDDO
 C***  Definition of the Depth-dependent Clumping Factor
-            IF (bOldStratification) THEN
+            IF (iOldStratification > 0 .AND. 
+     >              (.NOT. bForceDCUpdate .OR. TAURCONT(ND) < 0.)) THEN
               DO L=1, ND
                 IF (RADIUS(L) > RADIUSold(1)) THEN
                   DENSCON(L) = DENSCON_OLD(1)
@@ -541,10 +896,24 @@
                 ENDIF
               ENDDO
             ELSE
+c              WRITE (0,*) 'DEBUG before CLUMP_STRUCT ---------------'
+c              WRITE (0,*) 'L, RADIUS(L), VELO(L), TAU(L)'
+c              DO L=1, ND
+c                WRITE (0,'(I3,3(1X,G15.5))') L, RADIUS(L), VELO(L), TAUROSS(L)
+c              ENDDO
+c              WRITE (0,*) 'DEBUG before CLUMP_STRUCT ---------------'
               CALL CLUMP_STRUCT (DENSCON, FILLFAC, ND, DENSCON_FIX, 
      >                           VELO, TAURCONT, DENSCON_LINE, 
      >                           RADIUS, T, XMU)
+c              WRITE (0,*) 'DEBUG after CLUMP_STRUCT ~~~~~~~~~~~~~~~'
+c              WRITE (0,*) 'L, RADIUS(L), VELO(L), TAU(L)'
+c              DO L=1, ND
+c                WRITE (0,*) L, DENSCON(L)
+c              ENDDO
+c              WRITE (0,*) 'DEBUG after CLUMP_STRUCT ~~~~~~~~~~~~~~~'
             ENDIF
+            CALL VTURB_SETUP (VTURB, VTURB_LINE, ND, 
+     >                        VELO, RADIUS, TAURCONT, T, XMU)
 
 C***  ITAB = 2: ONLY TABULATED INPUT OF V(R), I.E. T(R) MUST BE CALCULATED
             IF (ITAB .EQ. 2) TTABLE=.FALSE.
@@ -572,9 +941,9 @@
      >                     IGAUNT, NOM, NF,
      >                     XLAMBDA, FWEIGHT,
      >                     TAUTHOM, TAURCONT,
-     >                     MAXATOM, SIGMATHK, SEXPOK, EDGEK, KODAT,
-     >                     KONTNUP, KONTLOW, LASTKON, 
-     >                     DENSCON, FILLFAC
+     >                     MAXATOM, MAXION, SIGMATHK, SEXPOK, EDGEK, 
+     >                     KODAT, KONTNUP, KONTLOW, LASTKON, 
+     >                     DENSCON, FILLFAC, POPMIN
      >        ) 
             ELSE
               DO L=1, ND
@@ -582,11 +951,43 @@
               ENDDO
             ENDIF
 
+            DO L=1,ND
             !Added XMU in WRSTART for use in VELTHIN and to avoid problems 
             !  with first steal run if hydro or TAUFIX is enabled
             !  XMU is recalculated here because RNE has been changed by GREY
-            DO L=1,ND
                 XMU(L) = ATMEAN / (1. + RNE(L))
+              IF (bFULLHYDROSTAT) THEN
+                IF (iOLDRAD == 2) THEN
+                  IF (RADIUS(L) > RADIUSold(1)) THEN
+                    GAMMAL = GAMMARAD(1)
+                  ELSEIF (RADIUS(L) < RADIUSold(NDold)) THEN
+                    GAMMAL = GAMMARAD(NDold)
+                  ELSE
+                    CALL SPLINPOX(GAMMAL, RADIUS(L), 
+     >                           GAMMARAD, RADIUSold, NDold)
+                  ENDIF
+                ELSEIF (iOLDRAD == 1 .AND. .NOT. bGREYSTART) THEN
+                  IF (L == ND) THEN
+                    DTAUCDTAUTH = (TAURCONT(ND) - TAURCONT(ND-1)) /
+     >                               (TAUTHOM(ND) - TAUTHOM(ND-1))
+                  ELSEIF (L == 1) THEN
+                    DTAUCDTAUTH = (TAURCONT(2) - TAURCONT(1)) /
+     >                               (TAUTHOM(2) - TAUTHOM(1))
+                  ELSE 
+                    DTAUCDTAUTH = (TAURCONT(L+1) - TAURCONT(L-1)) /
+     >                               (TAUTHOM(L+1) - TAUTHOM(L-1))
+                  ENDIF
+                  GAMMAL = DTAUCDTAUTH * GEDD
+                ELSEIF (RADGAMMASTART >= 0.) THEN
+                  GAMMAL = RADGAMMASTART
+                ELSE 
+                  GAMMAL = GEDD
+                ENDIF
+                GEFFL(L) = (10.**GLOG) * (1. - GAMMAL)
+              ELSE
+                !either Thompson only or fixed => no depth-dependent value
+                GEFFL(L) = (10.**GLOG) * (1. - GEDD)     
+              ENDIF
             ENDDO
 
             IF (bHYDROSOLVE) THEN
@@ -600,7 +1001,7 @@
             ENDIF
             
 C***  NEW VELOCITY FIELD FROM INTEGRATION OF HYDROSTATIC EQUATION
-            IF (((.NOT.TTABLE) .OR. (ITAB .LT. 2)) .AND. THIN) THEN
+            IF ((ITAB .LT. 2) .AND. THIN) THEN
               CALL VELTHIN(T, RADIUS, VELO, ND, RSTAR, RMAX,
      >                    GEFFL, XMU, VTURB, ThinCard, VELOCRITERION)
 
@@ -636,17 +1037,82 @@
 
 
 C***  AUTOMATICAL ADJUSTMENT OF VMIN (OPTIONAL: IF TAUMAX SPECIFIED)
-          IF (bOldStratification) THEN
+          IF (iOldStratification > 0 .AND. (fHYDROSTART > 0.)) THEN
+            XMDOT = LOG10(FM) - 2. * LOG10(RSUN/RSTAR) - 3.02
+            IF (TAUMAX > 0.) THEN
+              
+              WRITE (hCPR,FMT='(A,I3,A,F8.4,A,F9.4,A)') 
+     >          ' **  TAUMAX ITERATION: ITTAU=', ITTAU, 
+     >          '   TAUROSS=', TAURCONT(ND), 
+     >          '  LOG MDOT = ', XMDOT, ' [Msun/yr]'
+              
+              STEPDAMP = 1./ ( 1 +  LOG10( FLOAT(ITTAU) ) )
+              
+              IF (TAURCONT(ND) > TAUMAX+TAUACC) THEN
+                FM = FM * 10**(-0.1 * STEPDAMP)
+                IF (ITTAU < MAXITTAU) CYCLE tauit
+              ENDIF
+
+              IF (TAURCONT(ND) < TAUMAX-TAUACC) THEN
+                FM = FM * 10**(0.1 * STEPDAMP)
+                IF (ITTAU < MAXITTAU) CYCLE tauit
+              ENDIF            
+           ENDIF
+            
+           EXIT tauit 
+            
+          ELSEIF (iOldStratification > 0 .AND. 
+     >         (.NOT. bOVTauMax) .AND. (.NOT. bOVTauCut)) THEN
+c          ELSEIF (iOldStratification > 0) THEN
 C***        Use old RCON in case of OLD STRATIFICATION 
 C***        if inside of both, old and new grid
             IF (RCONold < RADIUSold(1) .AND. RCONold < RADIUS(1)) THEN
               RCON = RCONold
             ENDIF          
-            WRITE (0,FMT='(A,F10.4,A,F11.6)') 
+            WRITE (hCPR,FMT='(A,F10.4,A,F11.6)') 
      >          ' *** OLD STRATIFICATION USED: TAURCONT=', TAURCONT(ND), 
      >          '   VMIN=', VMIN
             EXIT tauit
           ELSEIF (TAUMAX > .0) THEN
+            IF (bOVTauMax .AND. ITTAU == 1) THEN
+              WRITE (hCPR,FMT='(A,F10.4)') 
+     >          ' *** OLD STRATIFICATION USED: will be'
+     >          // ' shifted to match the desired TAUMAX of ', TAUMAX
+              IF (bForceDCUpdate) THEN
+C***            We need at least 2 iterations if we update the DENSCON-Scale
+C***            and iterate on TAUMAX
+                CYCLE
+              ENDIF
+            ENDIF
+
+            IF (bOVTauCut) THEN
+C***          OLD V TAUCUT option: Only use the part of OLD V 
+C***                               which is in the Tau-scale of the new model
+              IF ( TAURCONT(ND) < (TAUMAX - TAUACC) .AND. 
+     >              (ABS(TAURCONT(ND))-TROLD) > TAUACC ) THEN
+C***            Common block for velo field has not to be filled with the new
+C***            radius grid and the v(r)-part old the old velocity field up to
+C***            the new TAURCONT(ND)
+C***            @todo: sensible iteration system (derived TAU should not change) 
+                NDv = ND
+                DO L=1, NDv
+                  CALL SPLINPOX(VL, TAURCONT(L), VELOold, TAURCONTOLD, NDold)
+                  OLDVELO(L) = VL
+                  OLDRADI(L) = RADIUS(L)
+                ENDDO          
+                VMIN = OLDVELO(NDv)
+                TROLD = TAURCONT(ND)
+                WRITE (hCPR,FMT='(A,I3,A,F10.4)') 
+     >            ' *** OLD V TAUCUT Iteration: IT=', ITTAU, 
+     >            '  TAURCONT=', TAURCONT(ND) 
+                CYCLE      
+              ELSE
+                WRITE (hCPR,FMT='(A,F10.4,A,F11.6)') 
+     >            ' *** OLD V WITH CUT AT: TAURCONT=', TAURCONT(ND), 
+     >            '   VMIN=', VMIN
+                EXIT tauit
+              ENDIF
+            ENDIF
 
             IF (VMIN == VMINhydro) THEN
               TAUMAX = REAL(CEILING(TAURCONT(ND)))   !taumax = next larger integer 
@@ -665,21 +1131,20 @@
    77       FORMAT (' *** TAUMAX ITERATION: ITTAU=', I3,
      >          '   TAURCONT=', F10.4, '  VMIN=', G12.4)
 
-C***        make an extrapolation at every ten steps
+            !MAKE BISECTION IN EVERY THIRD STEP
             VMINOLD2 = VMINOLD
             VMINOLD = VMIN
             TROLD2 = TROLD
             TROLD = TAURCONT(ND)
-            IF (ABS(TAURCONT(ND)-TAUMAX) > TAUACC  .AND.  
+C***        Check how effective this really is            
+            IF ((ABS(TAURCONT(ND))-TAUMAX) > TAUACC  .AND.  
      >        ITTAU/10*10 == ITTAU .AND. ITTAU > 2) THEN
+C     >         ITTAU .GT. 2) THEN
 C***            VMIN = 0.5 * (VMINOLD + VMINOLD2)
                 VMIN = (VMINOLD2*(TROLD-TAUMAX) - VMINOLD * 
      >          (TROLD2-TAUMAX)) /  (TROLD - TROLD2)
-                IF (VMIN > .0) THEN
+
                    IF (ITTAU < MAXITTAU) CYCLE
-                ELSE
-                   VMIN = VMINOLD
-                ENDIF
             ENDIF
 
 C***        TAUROSS TOO LARGE:
@@ -703,16 +1168,26 @@
 
 
 C***  VELOCITY GRADIENT BY DIFFERENTIATION (final calculation)
+      IF (ITAB < 2) THEN
       CALL       GRADIFF  (ND,VELO,GRADI,RADIUS)
+      ENDIF
 
       !Store VELOCRITERION as two-character vector in model file
       VCRIT = '        '
-      IF (bOldStratification) THEN
+      IF (iOldStratification > 1) THEN
         !if old v is used, take also old VCRIT as starting approach
         ! (note: this might not be exact if taumax changes signifcantly!)
         DO L=1, ND
           VCRIT(L) = VCRITold(L)
         ENDDO
+      ELSEIF (iOldStratification == 1) THEN
+        DO L=1, ND
+          VCRIT(L) = 'IP      '
+        ENDDO
+      ELSEIF (TTABLE .AND. ITAB > 1) THEN
+        DO L=1, ND
+          VCRIT(L) = 'TAB     '
+        ENDDO
       ELSE      
         DO L=1, ND
           !Note: static identifier "ST" is already set above if used
@@ -763,12 +1238,21 @@
       ELSE
         CALL WRITMS (3,-1.0   ,1,    'GEDD    ', IFLAG, IDUMMY, IERR)
       ENDIF
-      IF (GEDDRAD > 0. .AND. .NOT. bOldStratification) THEN
+      IF (GEDDRAD > 0. .AND. iOldStratification == 0) THEN
         CALL WRITMS (3,GEDDRAD,1,    'GEDDRAD ', IFLAG, IDUMMY, IERR)
       ENDIF
       CALL WRITMS (3,T,ND,         'T       ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,VELO,ND,      'VELO    ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,VMIN,1,       'VMIN    ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,VFINAL,1,     'VFINAL  ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,HSCALE,1,     'HSCALE  ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,BETA,1,       'BETA    ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,BETA2,1,      'BETA2   ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,BETA2FRACTION,1,'B2FRAC  ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,VPAR1,1,      'VPAR1   ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,VPAR2,1,      'VPAR1   ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,VPAR1_2,1,    'VPAR12  ', IFLAG, IDUMMY, IERR)
+!       CALL WRITMS (3,VPAR2_2,1,    'VPAR22  ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,GRADI,ND,     'GRADI   ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,TAURCONT,ND,  'TAURCONT', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,RSTAR,1,      'RSTAR   ', IFLAG, IDUMMY, IERR)
@@ -787,6 +1271,7 @@
       CALL WRITMS (3,KEY,NF,       'KEY     ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,POPNUM,ND*N,  'POPNUM  ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,POPNUM,ND*N,  'POPLTE  ', IFLAG, IDUMMY, IERR)
+      CALL WRITMS (3,LEVEL, N,     'LEVEL   ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,RNE,ND,       'RNE     ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,XMU,ND,       'XMU     ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,ABXYZ,NATOM,  'ABXYZ   ', IFLAG, IDUMMY, IERR)
@@ -798,18 +1283,21 @@
       READ(UNIT=BUFFER6, FMT='(A6)') TOTOUT
       CALL WRITMS (3,TOTOUT,1,     'TOTOUT  ', IFLAG, IDUMMY, IERR)
       CALL WRITMS (3,XDATA,MAXXDAT,'XDATA   ', IFLAG, IDUMMY, IERR)
-      CALL WRITMS (3,VTURB,1,      'VTURB   ', IFLAG, IDUMMY, IERR)
+      DO L=1, ND
+        VMIC(L) = VTURB(L) * SQRT(2.)
+      ENDDO
+      CALL WRITMS (3,VMIC, ND,     'VMIC    ', IFLAG, IDUMMY, IERR)
       IF (THIN) THEN
         DO L=1, ND
           GRSTATIC(L) = 1. - GEFFL(L) / (10.**GLOG)
         ENDDO
         CALL WRITMS (3,GRSTATIC, ND, 'GRSTATIC', IFLAG, IDUMMY, IERR)
       ENDIF
-      IF (OLDTEMP .AND. bOldStratification) THEN
-         CALL WRITMS (3,DTDRIN_OLD, 1, 'DTDRIN  ', IFLAG, IDUMMY, IERR)
+      IF (OLDTEMP .AND. iOldStratification > 0 
+     >                          .AND. DTDRIN_OLD > 0.) THEN
+        CALL WRITMS (3, DTDRIN_OLD, 1, 'DTDRIN  ', IFLAG, IDUMMY, IERR)
       ENDIF
       
-
 C***  WRITE THE BEGINNING OF THE MODEL HISTORY      
       MODHIST(9:32) = '/      0. WRSTART       '
       LAST=4    !3 * 8 +  offset (8)
@@ -843,10 +1331,11 @@
             WSTABIL(INDDR) = EION(LOW) - ELEVEL(LOW) + EAUTO(INDDR)
          ENDDO
       ENDIF
-      CALL JSTART (NF,XLAMBDA, ND,RADIUS,T,XJC,XJL,ELEVEL, N, EINST,
-     >             NDIM, INDNUP, INDLOW, LASTINDALL, LASTIND, 
-     >             NAUTO, WSTABIL, R23, TAUGREY, LTESTART, BLACKEDGE, 
-     >             KRUDAUT)
+      CALL JSTART (NF,XLAMBDA,KEY,ND,RADIUS,T,XJC,XJL,ELEVEL,
+     >             N,EINST,NDIM,INDNUP,INDLOW, LASTINDALL, LASTIND,
+     >             NAUTO, WSTABIL, R23, TAUGREY, 
+     >             LTESTART, BLACKEDGE, bOLDJ, XJCold, XLAMBDAold,
+     >             RADIUSold, NFold, NDold, KRUDAUT)
  
       CALL CLOSMS (3, IERR)
 C**********************************************************************
@@ -860,7 +1349,7 @@
       CALL PRIPARAM (MODHEAD, TEFF, RSTAR, XMDOT, XLOGL, RTRANS, 
      >        VFINAL, VDOP, DENSCON, FILLFAC, GLOG, GEFFLOG, GEDDPRINT, 
      >        GEddFix, RMAX, XMSTAR, WRTYPE, MASSORIGIN, LRTinput, ND, 
-     >        MLRELATION, VTURB, MDOTINPUT)
+     >        MLRELATION, VTURB(ND), MDOTINPUT)
 
 
 
@@ -878,8 +1367,9 @@
       CALL PRIMOD (ND,RADIUS,INCRIT,ENTOT,T,VELO,GRADI,NP,OLDTEMP,
      $             MODHEAD,JOBNUM,MODOLD,JOBNOLD,TTABLE,TAURCONT,R23,
      $             TEFFOLD,THIN, ITTAU, MAXITTAU, RCON, BTWOT, MODOLD2, 
-     >             JOBNOLD2, TFAC, BETA, VPAR1, VPAR2, DENSCON, BETA2, 
-     >             BETA2FRACTION, HSCALE, bNoDetails,.TRUE., VTURB)
+     >             JOBNOLD2, TFAC, BETA, VPAR1, VPAR2, DENSCON,
+     >             BETA2, BETA2FRACTION, HSCALE,
+     >             bNoDetails,.TRUE., VTURB(ND))
  
 C***  PLOT OF THE VELOCITY LAW
       IF (VPLOT) CALL PLOTV (ND,RADIUS,VELO,MODHEAD,JOBNUM)
diff -bur ./zoneint.f ../../powr-refactor/src/zoneint.f
--- ./zoneint.f	2024-07-28 13:14:47.000000000 +0200
+++ ../../powr-refactor/src/zoneint.f	2023-09-27 10:14:15.133755938 +0200
@@ -46,7 +46,7 @@
       REAL, DIMENSION(NBLINE) :: XMAXLIN
       REAL POROLENGTHRAY(LTOT), POROLENGTHFINE(MAXXN)
       INTEGER, DIMENSION(NATOM) :: KODAT
-      REAL ZINTER(4)
+      REAL ZINTER(2)      
       REAL, DIMENSION
      > (-NFDIMPHITAB:NFDIMPHITAB, NDDIM, NLDIMPHITAB,MAXMOD) :: PHITAB
 
@@ -231,8 +231,7 @@
 C***     Check if current point lies in second-model domain
             IMOD=1
             IF (NMOD .EQ. 2) THEN
-               IF ((ZFINE(I)-ZINTER(1))*(ZFINE(I)-ZINTER(2)) .LT. .0
-     >            .OR. (ZFINE(I)-ZINTER(3))*(ZFINE(I)-ZINTER(4)).LT. .0)
+               IF ((ZFINE(I)-ZINTER(1))*(ZFINE(I)-ZINTER(2)) .LT. .0)
      >            IMOD=2
             ENDIF
 
@@ -292,8 +291,7 @@
 C***     Check if current point lies in second-model domain
          IMOD=1
          IF (NMOD .EQ. 2) THEN
-            IF ((ZFINE(I)-ZINTER(1))*(ZFINE(I)-ZINTER(2)) .LT. .0
-     >          .OR. (ZFINE(I)-ZINTER(3))*(ZFINE(I)-ZINTER(4)) .LT. .0)
+            IF ((ZFINE(I)-ZINTER(1))*(ZFINE(I)-ZINTER(2)) .LT. .0) 
      >         IMOD=2
          ENDIF
 
@@ -443,9 +441,8 @@
 C***        Check if current point lies in second-model domain
             IMOD=1
             IF (NMOD .EQ. 2) THEN
-              IF ((ZFINE(I+1)-ZINTER(1))*(ZFINE(I+1)-ZINTER(2)) .LT. .0
-     >             .OR.(ZFINE(I+1)-ZINTER(3))*(ZFINE(I+1)-ZINTER(4))
-     >             .LT. .0) IMOD=2
+               IF ((ZFINE(I+1)-ZINTER(1))*(ZFINE(I+1)-ZINTER(2)) .LT. .0) 
+     >            IMOD=2
             ENDIF
 
 C***        ADD LINE PLUS CONTINUUM OPACITIES
